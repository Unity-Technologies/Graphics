#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal glcore ps5

#pragma kernel FilterSpatially

#include "Common.hlsl"
#include "PatchUtil.hlsl"
#include "RingBuffer.hlsl"
#include "Packages/com.unity.render-pipelines.core/Runtime/Sampling/QuasiRandom.hlsl"

StructuredBuffer<uint> _RingConfigBuffer;
StructuredBuffer<SphericalHarmonics::RGBL1> _InputPatchIrradiances;
StructuredBuffer<PatchUtil::PatchGeometry> _PatchGeometries;
RWStructuredBuffer<SphericalHarmonics::RGBL1> _OutputPatchIrradiances;
StructuredBuffer<uint> _CellPatchIndices;
StructuredBuffer<int3> _CascadeOffsets;

uint _FrameIdx;
float _VolumeVoxelMinSize;
uint _CascadeCount;
uint _VolumeSpatialResolution;
uint _SampleCount;
uint _RingConfigOffset;
float _Radius;
float3 _VolumeTargetPos;

[numthreads(64, 1, 1)]
void FilterSpatially(uint patchIdx : SV_DispatchThreadID)
{
    if (!RingBuffer::IsPositionInUse(_RingConfigBuffer, _RingConfigOffset, patchIdx))
        return;

    const PatchUtil::PatchGeometry patchGeo = _PatchGeometries[patchIdx];

    QrngKronecker2D rng;
    rng.Init(uint2(patchIdx, 0), _FrameIdx * _SampleCount);

    SphericalHarmonics::RGBL1 patchIrradianceSum = _InputPatchIrradiances[patchIdx];
    float weightSum = 1.0f;

    float3 up;
    float3 right;
    OrthoBasisFromVector(patchGeo.normal, up, right);

    const int cascadeResolution = PatchUtil::ResolveCascadeIndex(_VolumeTargetPos, patchGeo.position, _VolumeSpatialResolution, _CascadeCount, _VolumeVoxelMinSize);
    const uint cascadeIdx = cascadeResolution != -1 ? cascadeResolution : _CascadeCount - 1;

    for (uint sampleIdx = 0; sampleIdx < _SampleCount; ++sampleIdx)
    {
        const float2 jitter = rng.GetSample(0) * 2.0f - 1.0f;
        const float3 displacement = (up * jitter.x + right * jitter.y) * PatchUtil::GetVoxelSize(_VolumeVoxelMinSize, cascadeIdx) * _Radius;

        SphericalHarmonics::RGBL1 irradiance;
        bool result = PatchUtil::ReadHemisphericalIrradiance(
            _InputPatchIrradiances, _CellPatchIndices, _VolumeSpatialResolution, _CascadeOffsets, _VolumeTargetPos, _CascadeCount, _VolumeVoxelMinSize,
            patchGeo.position + displacement, patchGeo.normal, irradiance);

        if (result)
        {
            float weight = 1.0f - length(jitter) * INV_SQRT2;
            weightSum += weight;
            SphericalHarmonics::AddMut(patchIrradianceSum, SphericalHarmonics::MulPure(irradiance, weight));
        }

        rng.NextSample();
    }

    _OutputPatchIrradiances[patchIdx] = SphericalHarmonics::MulPure(patchIrradianceSum, rcp(weightSum));
}
