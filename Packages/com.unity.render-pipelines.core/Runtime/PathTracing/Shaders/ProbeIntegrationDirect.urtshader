#pragma only_renderers d3d11 vulkan metal glcore
#define UNIFIED_RT_GROUP_SIZE_X 128
#define UNIFIED_RT_GROUP_SIZE_Y 1
#define UNIFIED_RT_RAYGEN_FUNC IntegrateDirectRadiance

#include "Packages/com.unity.render-pipelines.core/Runtime/UnifiedRayTracing/FetchGeometry.hlsl"

#define RESAMPLED_IMPORTANCE_SAMPLING
#define LIGHT_SAMPLING_ROUND_ROBIN

#include "PathTracing.hlsl"
#include "SphericalHarmonicsUtils.hlsl"

uint g_LightIndexInCell;
RWStructuredBuffer<float3> g_Positions;
RWStructuredBuffer<float> g_RadianceShl2;
uint g_PositionsOffset;
uint g_SampleOffset;
uint g_SampleCount;

void IntegrateDirectRadiance(UnifiedRT::DispatchInfo dispatchInfo)
{
    const uint threadIdx = dispatchInfo.dispatchThreadID.x;
    const uint inProbeIdx = threadIdx / g_SampleCount + g_PositionsOffset;
    const uint inProbeSampleIdx = threadIdx % g_SampleCount;
    const uint outProbeIdx = threadIdx;

    PathTracingSampler rngState;
    rngState.Init(inProbeIdx, g_SampleOffset + inProbeSampleIdx);

    // Local array to accumulate radiance into, using SoA layout.
    float3 accumulatedRadianceSH[SH_COEFFICIENTS_PER_CHANNEL];
    for (int i = 0; i < SH_COEFFICIENTS_PER_CHANNEL; ++i)
    {
        accumulatedRadianceSH[i] = 0.0f;
    }

    // Set up some stuff we need to sample lights.
    UnifiedRT::RayTracingAccelStruct accelStruct = UNIFIED_RT_GET_ACCEL_STRUCT(g_SceneAccelStruct);
    float3 worldPosition = g_Positions[inProbeIdx];

    SampleLightsOptions options;
    options.isDirect = true;
    options.receiveShadows = true;
    options.shadowRayMask = ShadowRayMask();
    options.lightsRenderingLayerMask = 0xFFFFFFFF;
    options.numLightCandidates = min(g_LightEvaluations, MAX_LIGHT_EVALUATIONS);

    uint numLightsInCell = GetNumLights(worldPosition);
	// If there are no lights to sample, continuing is a waste of time.
	[branch] if (numLightsInCell == 0)
	    return;

    LightSample lightSample = (LightSample)0;
    #ifdef LIGHT_SAMPLING_ROUND_ROBIN
    [branch] if (g_LightIndexInCell >= numLightsInCell)
        return;

    PTLight light = GetLightInCell(worldPosition, g_LightIndexInCell);
    if (SampleLightRadiance(dispatchInfo, accelStruct, g_AccelStructInstanceList, worldPosition, 0.0f, options, light, rngState, lightSample))
    #else
    if (SampleLightsRadiance(dispatchInfo, accelStruct, g_AccelStructInstanceList, worldPosition, 0.0f, options, rngState, lightSample))
    #endif
    {
        // Project into SH.
        accumulatedRadianceSH[0] += lightSample.radiance * SHL0();
        accumulatedRadianceSH[1] += lightSample.radiance * SHL1_1(lightSample.direction);
        accumulatedRadianceSH[2] += lightSample.radiance * SHL10(lightSample.direction);
        accumulatedRadianceSH[3] += lightSample.radiance * SHL11(lightSample.direction);

        accumulatedRadianceSH[4] += lightSample.radiance * SHL2_2(lightSample.direction);
        accumulatedRadianceSH[5] += lightSample.radiance * SHL2_1(lightSample.direction);
        accumulatedRadianceSH[6] += lightSample.radiance * SHL20(lightSample.direction);
        accumulatedRadianceSH[7] += lightSample.radiance * SHL21(lightSample.direction);
        accumulatedRadianceSH[8] += lightSample.radiance * SHL22(lightSample.direction);
    }

    #ifdef LIGHT_SAMPLING_ROUND_ROBIN
    const float monteCarloNormalization = 1.0f / (float)g_SampleCount / (float)numLightsInCell;
    #else
    const float monteCarloNormalization = 1.0f / (float)g_SampleCount;
    #endif
    for (uint channel = 0; channel < SH_COLOR_CHANNELS; ++channel)
    {
        for (uint i = 0; i < SH_COEFFICIENTS_PER_CHANNEL; ++i)
        {
            g_RadianceShl2[SHIndex(outProbeIdx, channel, i)] += accumulatedRadianceSH[i][channel] * monteCarloNormalization;
        }
    }
}
