#pragma only_renderers d3d11 vulkan metal glcore
#pragma multi_compile _ SPARSE_GRID
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonLighting.hlsl"

#include "PathTracingCommon.hlsl"
#include "PathTracingRandom.hlsl"
#include "PathTracingLightGrid.hlsl"

#if defined(SHADER_API_MOBILE) && defined(SHADER_API_METAL)
// On pre A9 (iPhone 6S and earlier) devices, the max groupshared size is 16352. So to avoid exceeding that limit, we reduce the group size.
#define GROUP_SIZE_X 4
#define GROUP_SIZE_Y 4
#define GROUP_SIZE_Z 2
#else
#define GROUP_SIZE_X 4
#define GROUP_SIZE_Y 4
#define GROUP_SIZE_Z 4
#endif

#define MAX_RESERVOIRS_PER_VOXEL 64

groupshared float s_SampleCount[GROUP_SIZE_X * GROUP_SIZE_Y * GROUP_SIZE_Z * MAX_RESERVOIRS_PER_VOXEL];

#ifndef PI
#define PI 3.14159265358979323846f
#endif

// Input parameters and lighting state
StructuredBuffer<PTLight>       g_LightList;
uint                            g_NumLights;
uint                            g_MaxLightsPerCell;
uint                            g_NumCandidates;
uint                            g_BuildPass;

// Output indices and grid
RWStructuredBuffer<ThinReservoir>   g_LightGridCellsData;
RWStructuredBuffer<uint2>           g_LightGrid;
RWStructuredBuffer<uint>            g_TotalLightsInGridCount;

float4 PlaneFromNormalAndPosition(float3 normal, float3 pos)
{
    return float4(normal, -dot(normal, pos));
}

void GetBoxLightFrustumPlanes(float3 lightOrigin, float3 lightBasisX, float3 lightBasisY, float3 lightBasisZ, float halfSizeX, float halfSizeY, float range, out float4 frustumPlanes[6])
{
    // sides along X
    frustumPlanes[0] = PlaneFromNormalAndPosition(-lightBasisX, lightOrigin + lightBasisX * halfSizeX);
    frustumPlanes[1] = PlaneFromNormalAndPosition(lightBasisX, lightOrigin - lightBasisX * halfSizeX);
    // sides along Y
    frustumPlanes[2] = PlaneFromNormalAndPosition(-lightBasisY, lightOrigin + lightBasisY * halfSizeY);
    frustumPlanes[3] = PlaneFromNormalAndPosition(lightBasisY, lightOrigin - lightBasisY * halfSizeY);
    // sides along Z
    frustumPlanes[4] = PlaneFromNormalAndPosition(lightBasisZ, lightOrigin);
    frustumPlanes[5] = PlaneFromNormalAndPosition(-lightBasisZ, lightOrigin + lightBasisZ * range);
}

void GetPyramidLightFrustumPlanes(float3 lightOrigin, float3 lightBasisX, float3 lightBasisY, float3 lightBasisZ, float halfSizeX, float halfSizeY, float range, out float4 frustumPlanes[6])
{
    float2 nX = normalize(float2(1.0, halfSizeX));
    float2 nY = normalize(float2(1.0, halfSizeY));

    // the plane's normals point towards the interior of the frustum

    // Pyramid sides along X
    frustumPlanes[0] = PlaneFromNormalAndPosition(nX.y * lightBasisZ + nX.x * lightBasisX, lightOrigin);
    frustumPlanes[1] = PlaneFromNormalAndPosition(nX.y * lightBasisZ - nX.x * lightBasisX, lightOrigin);
    // Pyramid sides along Y
    frustumPlanes[2] = PlaneFromNormalAndPosition(nY.y * lightBasisZ + nY.x * lightBasisY, lightOrigin);
    frustumPlanes[3] = PlaneFromNormalAndPosition(nY.y * lightBasisZ - nY.x * lightBasisY, lightOrigin);
    // Pyramid near and far planes
    frustumPlanes[4] = PlaneFromNormalAndPosition(lightBasisZ, lightOrigin);
    frustumPlanes[5] = PlaneFromNormalAndPosition(-lightBasisZ, lightOrigin + lightBasisZ * range);
}

// Estimate the maximum emission in a voxel / Target function for RIS
float3 EstimateEmission(PTLight light, float3 worldPosition)
{
    // Evaluate the light's distance attenuation
    float distAttenuation = 1.0;
    if (light.type != DIRECTIONAL_LIGHT && light.type != ENVIRONMENT_LIGHT && light.type != BOX_LIGHT && light.type != EMISSIVE_MESH)
    {
        // First compute the point light attenuation
        float d = length(light.position - worldPosition);

        // To be conservative on the attenuation, we substruct the cell radius of the grid.
        // We also substract the radius (of the bounding sphere) of the light
        float r = 0.0f;
        if (light.type == DISC_LIGHT)
            r = light.width;
        if (light.type == RECTANGULAR_LIGHT)
            r = 0.5f * sqrt(light.width * light.width + light.height * light.height);

        // To be conservative on the attenuation, we substruct the cell radius of the grid
        d = max(0.01f, d - GetCellSize() - r);

        distAttenuation = SmoothWindowedDistanceAttenuation(d * d, rcp(d), light.attenuation.x, light.attenuation.y);
    }

    // Evaluate the lights's emission + culling by light's bounding shape
    const float Deg2Rad = PI * 2.0f / 360.0f;
    float3 emission = float3(1.0f, 1.0f, 1.0f);
    if (light.type == DIRECTIONAL_LIGHT || light.type == POINT_LIGHT)
    {
        emission = light.intensity;
    }
    else if (light.type == ENVIRONMENT_LIGHT || light.type == EMISSIVE_MESH)
    {
        emission = float3(1.0f, 1.0f, 1.0f);
    }
    else if (light.type == BOX_LIGHT) // Frustum vs cell AABB culling
    {
        float4 frustumPlanes[6];
        GetBoxLightFrustumPlanes(light.position, light.right, light.up, light.forward, 0.5 * light.width, 0.5 * light.height, light.range, frustumPlanes);

        float3 aabbCenter = worldPosition;
        float3 aabbExtent = 0.5 * GetCellSize();
        bool intersection = IntersectFrustumPlanesAABB(frustumPlanes, aabbCenter, aabbExtent);

        emission = intersection ? light.intensity : 0.0f;
    }
    else if (light.type == PYRAMID_LIGHT) // Frustum vs cell AABB culling
    {
        float4 frustumPlanes[6];
        GetPyramidLightFrustumPlanes(light.position, light.right, light.up, light.forward, 0.5 * light.width, 0.5 * light.height, light.range, frustumPlanes);

        float3 aabbCenter = worldPosition;
        float3 aabbExtent = 0.5 * GetCellSize();
        bool intersection = IntersectFrustumPlanesAABB(frustumPlanes, aabbCenter, aabbExtent);

        emission = intersection ? light.intensity : 0.0f;
    }
    else // SPOT_LIGHT || RECTANGULAR_LIGHT || DISC_LIGHT (cone vs cell's bounding sphere culling)
    {
        float coneAngle = (light.type == SPOT_LIGHT) ? 0.5 * light.spotAngle.x * Deg2Rad : 0.5f * 180.0f * Deg2Rad;
        float4 bSphere = float4(worldPosition, 0.5 * GetCellSize());
        bool intersection = IntersectSphericalConeWithSphere(light.position, light.forward, light.range, cos(coneAngle), sin(coneAngle), bSphere);

        emission = intersection ? light.intensity : 0.0f;
    }

    return distAttenuation * emission;
}


float GetLightTargetFunction(float3 pos, uint lightIndex)
{
    PTLight light = g_LightList[lightIndex];
    float3 emission = EstimateEmission(light, pos);
    return Luminance(emission);
}


#pragma kernel BuildConservativeLightGrid
[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, GROUP_SIZE_Z)]
void BuildConservativeLightGrid(in uint3 gidx : SV_DispatchThreadID, in uint threadIndex : SV_GroupIndex)
{
    if (gidx.x >= g_GridDimX || gidx.y >= g_GridDimY || gidx.z >= g_GridDimZ)
        return;

    uint cellIndex = GetCellIndex(gidx);

    PathTracingSampler rngState;
    rngState.Init(gidx.xy, gidx.z);

    float3 pos = GetCellPosition(gidx);

    if (g_BuildPass == 0) // compute number of lights overlapping current cell
    {
        uint lightCount = 0;
        for (uint lightIndex = 0; lightIndex < g_NumLights; ++lightIndex)
        {
            if (GetLightTargetFunction(pos, lightIndex) > 0)
                lightCount++;
        }

        uint unusedOldValue;
        InterlockedAdd(g_TotalLightsInGridCount[0], lightCount, unusedOldValue);
        g_LightGrid[cellIndex] = uint2(0, lightCount);
    }
    else // write lights overlapping current cell to g_LightGridCellsData
    {
        #if SPARSE_GRID
            uint lightCount = g_LightGrid[cellIndex].y;
            uint firstCellLightDataIndex;
            InterlockedAdd(g_TotalLightsInGridCount[0], lightCount, firstCellLightDataIndex);
            g_LightGrid[cellIndex].x = firstCellLightDataIndex;
            uint cellDataStart = firstCellLightDataIndex;
        #else
            uint cellDataStart = cellIndex * g_MaxLightsPerCell;
        #endif
            uint lightDataIndex = 0;

        for (uint lightIndex = 0; lightIndex < g_NumLights; ++lightIndex)
        {
            // Conservative culling mode: if there is a contribution, save the light index / reservoir
            // This should be used when the number of candidates equals the number of ligths
            if (GetLightTargetFunction(pos, lightIndex) > 0)
            {
                ThinReservoir reservoir = { lightIndex, 1.0f};
                g_LightGridCellsData[cellDataStart + lightDataIndex] = reservoir;
                lightDataIndex++;
            }

            #if !(SPARSE_GRID)
            if (lightDataIndex >= g_MaxLightsPerCell)
                break;
            #endif
        }

        #if !(SPARSE_GRID)
        uint lightCount = lightDataIndex;
        g_LightGrid[cellIndex] = uint2(cellDataStart, lightCount);
        #endif
    }
}

void UpdateReservoir(int reservoirIndex, int lightIndex, float targetFunction, float r)
{
    float candidateRISWeight = targetFunction;

    ThinReservoir reservoir = g_LightGridCellsData[reservoirIndex];
    float totalWeights = reservoir.weight + candidateRISWeight;

    if (r * totalWeights < candidateRISWeight)
    {
        reservoir.lightIndex = lightIndex;
        reservoir.weight = totalWeights;
    }

    g_LightGridCellsData[reservoirIndex] = reservoir;
}

void NormalizeReservoirWeights(uint offset, float3 pos, uint numReservoirs, uint threadIndex)
{
    for (uint i = 0; i < numReservoirs; ++i)
    {
        ThinReservoir reservoir = g_LightGridCellsData[offset + i];
        float numSamples = s_SampleCount[threadIndex * MAX_RESERVOIRS_PER_VOXEL + i];

        float sampleTargetDensity = GetLightTargetFunction(pos, reservoir.lightIndex);
        float risSampleWeight = (reservoir.weight / numSamples) / sampleTargetDensity;
        reservoir.weight = risSampleWeight;
        g_LightGridCellsData[offset + i] = reservoir;
    }
}

#pragma kernel BuildRegirLightGrid
[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, GROUP_SIZE_Z)]
void BuildRegirLightGrid(in uint3 gidx : SV_DispatchThreadID, in uint threadIndex : SV_GroupIndex)
{
    if (gidx.x >= g_GridDimX || gidx.y >= g_GridDimY || gidx.z >= g_GridDimZ)
        return;

    uint cellIndex = GetCellIndex(gidx);

    PathTracingSampler rngState;
    rngState.Init(gidx.xy, gidx.z);

    float3 pos = GetCellPosition(gidx);

    uint reservoirIndex = 0;
    for (uint lightIndex = 0; lightIndex < g_NumCandidates; ++lightIndex)
    {
        float targetFunction = GetLightTargetFunction(pos, lightIndex);

        // Conservative culling mode: if there is a contribution, save the light index / reservoir
        // This should be used when the number of candidates equals the number of ligths
        if (targetFunction > 0)
        {
            ThinReservoir reservoir = { lightIndex, targetFunction };

            if (reservoirIndex < g_NumReservoirs)
            {
                g_LightGridCellsData[cellIndex * g_NumReservoirs + reservoirIndex] = reservoir;
                s_SampleCount[threadIndex * MAX_RESERVOIRS_PER_VOXEL + reservoirIndex] = 1.0f;
                reservoirIndex++;
            }
            else
            {
                // When we run out of free reservoirs, we rely on reservoir sampling to update an existing one
                // The reservoirs are stratified based on the lightIndex % g_NumReservoirs
                uint reservoirLocalIndex = lightIndex % max(g_NumReservoirs, 1);
                uint reservoirGlobalIndex = cellIndex * g_NumReservoirs + reservoirLocalIndex;
                float rnd = rngState.GetSample1D(lightIndex);
                UpdateReservoir(reservoirGlobalIndex, lightIndex, targetFunction, rnd);
                s_SampleCount[threadIndex * MAX_RESERVOIRS_PER_VOXEL + reservoirLocalIndex] += 1;
            }
        }
    }

    NormalizeReservoirWeights(cellIndex * g_NumReservoirs, pos, reservoirIndex, threadIndex);
    g_LightGrid[cellIndex] = uint2(cellIndex * g_NumReservoirs, reservoirIndex);
}
