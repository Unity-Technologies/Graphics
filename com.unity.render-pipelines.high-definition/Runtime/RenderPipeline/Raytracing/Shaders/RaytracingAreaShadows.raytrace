// We need 2 bounces given that we want to see the direct lighting of the reflected surfaces
#pragma max_recursion_depth 1

#define HAS_LIGHTLOOP
#define LIGHTLOOP_SINGLE_PASS

// We are using DX12 here
#define SHADER_TARGET 50
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Macros.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition\Runtime\Material\Material.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition\Runtime\Lighting\Lighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl"

// HDRP include
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingIntersection.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/SphericalRectangle.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingSampling.hlsl"

// Light Data
uint 									_TargetAreaLight;
float4x4                                _AreaWorldToLocal;

// The target acceleration structure that we will evaluate the reflexion in
Texture2D<float>			          	_StencilTexture;
Texture2D<float>						_DepthTexture;

// Flag value that defines if a given pixel recieves reflections or not
// int   									_SsrStencilExclusionValue;
int                                     _RaytracingNumSamples;

// Output structure of the shadows raytrace shader
RWTexture2D<float4>     _SNTextureUAV;
RWTexture2D<float4>     _UNTextureUAV;

[shader("miss")]
void MissShaderShadows(inout RayIntersection rayIntersection : SV_RayPayload)
{
	rayIntersection.color = float3(1.0f, 1.0f, 1.0f);
}

// Here we decided to use a "Damier" pattern to define which importance sampling technique to use for the MIS
bool GenerateMISSample(uint2 pixelCoordinates, LightData areaLightData, PositionInputs posInput, BSDFData bsdfData, float3 viewVector, float2 noiseValue, out float3 sampleDir, out float3 samplePos, out float visiblityTerm, out float invPDF)
{
    // Generate the importance sampling technique mask
    const int ISMask[4] = {0, 0, 0, 0};
    uint2 samplingMask = pixelCoordinates.xy % 2;
    int ISTechnique = ISMask[samplingMask.x + samplingMask.y * 2];

    // Dimension of the area light
    float halfWidth  = areaLightData.size.x * 0.5;
    float halfHeight = areaLightData.size.y * 0.5;

    // Compute the world space position of the center of the lightlight
    float3 areaLightPosWS = areaLightData.positionRWS + _WorldSpaceCameraPos;

    // Let's first compute the position of the rectangle's corners in world space
    float3 v0 = areaLightPosWS + areaLightData.right *  halfWidth + areaLightData.up *  halfHeight;
    float3 v1 = areaLightPosWS + areaLightData.right *  halfWidth + areaLightData.up * -halfHeight;
    float3 v2 = areaLightPosWS + areaLightData.right * -halfWidth + areaLightData.up * -halfHeight;
    float3 v3 = areaLightPosWS + areaLightData.right * -halfWidth + areaLightData.up *  halfHeight;

    // TODO: Finish the implementation of the MIS
    bool validity = false;
    if(ISTechnique == 0)
    {
        SphericalRectangle sr;
        validity = SetupSphericalRectangle(v0, v1, v2, v3, areaLightPosWS, areaLightData.forward, posInput.positionWS, bsdfData.normalWS, sr);
        if(validity)
        {
            // 0 mask is light source sampling
            validity = SampleSphericalRectangle(sr, noiseValue.xy, sampleDir, samplePos, visiblityTerm, invPDF);
        }
    }
    else
    {
        // 1 mask means BRDF sampling
        // Let's generate a sample according to the brdf
        float3x3 localToWorld;
        localToWorld[0] = bsdfData.bitangentWS;
        localToWorld[1] = bsdfData.tangentWS;
        localToWorld[2] = bsdfData.normalWS;
        float NdotH;
        float VdotH;
        float LdotH;
        SampleGGXDir2(noiseValue, viewVector, localToWorld, bsdfData.perceptualRoughness, sampleDir, visiblityTerm, NdotH, VdotH, LdotH);

        // Compute the invPDF of the sample
        invPDF = 4.0f * LdotH / D_GGX(NdotH, bsdfData.perceptualRoughness) * NdotH;

        // First we need to figure out if this sample touches the area light
        float t;
        validity = intersect_plane(posInput.positionWS, sampleDir, areaLightData.forward, areaLightPosWS, t);

        if(validity)
        {
            // Let's compute the sample pos
            samplePos = posInput.positionWS + t * sampleDir;

            // The next question is: This the sample point inside the triangle? To do that for the moment we move it to the local space pof the light
            float4 lsPoint = mul(_AreaWorldToLocal, float4(samplePos, 1.0));

            if(abs(lsPoint.x) < halfWidth && abs(lsPoint.y) < halfHeight)
            {
                validity =  true;
            }
        }
    }
    return validity;
}

[shader("raygeneration")]
void RayGenShadows()
{
	uint2 LaunchIndex = DispatchRaysIndex();
    uint2 LaunchDim = DispatchRaysDimensions();

	// Pixel coordinate of the current pixel
    uint2 currentPixelCoord = uint2(LaunchIndex.x, LaunchDim.y - LaunchIndex.y - 1);

    // Reset the value of the buffer
    _UNTextureUAV[currentPixelCoord] = float4(0.0f, 0.0, 0.0, 1.0f);
	_SNTextureUAV[currentPixelCoord] = float4(0.0f, 0.0, 0.0, 1.0f);
	
    /*
    // Read the stencil value of the pixel
    uint stencilVal = UnpackByte(LOAD_TEXTURE2D(_StencilTexture, currentPixelCoord).r);
    
    // Check if this pixel should not recieve ssr, for the moment we compute it for everyone
    bool doesntReceiveSSR = (stencilVal & _SsrStencilExclusionValue) != 0;
    if (doesntReceiveSSR)
    {
        return;
    }
	*/

	// Read the depth value
	float depthValue  = _DepthTexture[currentPixelCoord];
	if(depthValue == 0.0f)
		return;

    // Convert this to a world space position
    PositionInputs posInput = GetPositionInput(currentPixelCoord, 1.0/LaunchDim.xy, depthValue, _InvViewProjMatrix, _ViewMatrix, 0);
    posInput.positionWS += _WorldSpaceCameraPos;

    // Let's now decode the BSDF data from the  gbuffer
    BSDFData bsdfData;
    BuiltinData builtinData;
    uint  featureFlags = UINT_MAX;
    DecodeFromGBuffer(posInput.positionSS, featureFlags, bsdfData, builtinData);

	// Compute the incident vector on the surfaces
	float3 incidentWS = normalize(posInput.positionWS - _WorldSpaceCameraPos);
	
	// Decode the world space normal
    NormalData normalData;	
    DecodeFromNormalBuffer(currentPixelCoord, normalData);

    float3 viewVector = normalize(_WorldSpaceCameraPos - posInput.positionWS);

	// Fetch the data of the area light
	LightData areaLightData = _LightDatas[_TargetAreaLight];

    // Compute the light's dimensions
    float halfWidth  = areaLightData.size.x * 0.5;
    float halfHeight = areaLightData.size.y * 0.5;

	// Compute the world space position of the light
    float3 areaLightPosWS = areaLightData.positionRWS + _WorldSpaceCameraPos - areaLightData.right * halfWidth - areaLightData.up * halfHeight;

	// Let's first compute the position of the rectangle's corners in world space
    float3 v0 = areaLightPosWS + areaLightData.right *  halfWidth + areaLightData.up *  halfHeight;
    float3 v1 = areaLightPosWS + areaLightData.right *  halfWidth - areaLightData.up * halfHeight;
    float3 v2 = areaLightPosWS - areaLightData.right * halfWidth - areaLightData.up * halfHeight;
    float3 v3 = areaLightPosWS - areaLightData.right * halfWidth + areaLightData.up *  halfHeight;

    for(int i  = 0; i < _RaytracingNumSamples; ++i)
    {
        // Get the following noise value
        float2 noiseValue = GetRaytracingNoiseSample(currentPixelCoord, i);

        // Let's now sample the point on the light source
        float3 sampleDir;
        float3 samplePos;
        float visiblityTerm;
        float invPDF;
    	bool validity = GenerateMISSample(currentPixelCoord, areaLightData, posInput, bsdfData, viewVector, noiseValue, sampleDir, samplePos, visiblityTerm, invPDF);
        
    	// If we could not sample , or the sample is not in the hemisphere or the sample is on the backface of the light
        if(!validity || dot(sampleDir, normalData.normalWS) <= 0.0 || dot(sampleDir, areaLightData.forward) > 0.0)
        {
        	continue;
        }

        // Let's shift the sample position by a bias
        samplePos = samplePos + areaLightData.forward * _RaytracingRayBias;

    	// Create the ray descriptor for this pixel
    	RayDesc rayDescriptor;
    	rayDescriptor.Origin = posInput.positionWS + normalData.normalWS * _RaytracingRayBias;
    	rayDescriptor.Direction = normalize(sampleDir);
    	rayDescriptor.TMin = _RaytracingRayBias;
    	rayDescriptor.TMax = length(samplePos - rayDescriptor.Origin);

    	// Create and init the RayIntersection structure for this
    	RayIntersection rayIntersection;
    	rayIntersection.color = float3(0.0, 0.0, 0.0);
    	rayIntersection.incidentDirection = rayDescriptor.Direction;
    	
    	// Evaluate the ray visibility term and PDF
    	TraceRay(_RaytracingAccelerationStructure,  RAY_FLAG_FORCE_NON_OPAQUE | RAY_FLAG_CULL_BACK_FACING_TRIANGLES, 0xFF, 0, 1, 0, rayDescriptor, rayIntersection);

        PreLightData preLightData = GetPreLightData(viewVector, posInput, bsdfData);

        float3 diffuseLighting = float3(0.0, 0.0, 0.0);
        float3 specularLighting = float3(0.0, 0.0, 0.0);
        BSDF( viewVector, normalize(sampleDir), visiblityTerm, posInput.positionWS, preLightData, bsdfData, diffuseLighting, specularLighting);

        // Subsurface scattering mode
        float3 modifiedDiffuseColor = GetModifiedDiffuseColorForSSS(bsdfData);

        // Apply the albedo to the direct diffuse lighting (only once). The indirect (baked)
        // diffuse lighting has already multiply the albedo in ModifyBakedDiffuseLighting().
        // Note: In deferred bakeDiffuseLighting also contain emissive and in this case emissiveColor is 0
        diffuseLighting = diffuseLighting;
        specularLighting = specularLighting;
        
        _SNTextureUAV[currentPixelCoord] += float4((diffuseLighting + specularLighting) * rayIntersection.color * invPDF, 1.0f);
        _UNTextureUAV[currentPixelCoord] += float4((diffuseLighting + specularLighting) * invPDF , 1.0f);
    }
    _SNTextureUAV[currentPixelCoord] *= 1.0f / _RaytracingNumSamples;
    _UNTextureUAV[currentPixelCoord] *= 1.0f / _RaytracingNumSamples;
}

[shader("closesthit")]
void ClosestHitMain(inout RayIntersection rayIntersection : SV_RayPayload, AttributeData attributeData : SV_IntersectionAttributes)
{    
    rayIntersection.color = float3(0.0, 0.0, 0.0);
}