#pragma kernel ValidateHistory

#pragma kernel TemporalAccumulationSingle                       TEMPORAL_ACCUMULATION=TemporalAccumulationSingle SINGLE_CHANNEL
#pragma kernel TemporalAccumulationSingleArray                  TEMPORAL_ACCUMULATION=TemporalAccumulationSingleArray SINGLE_CHANNEL HISTORY_IS_ARRAY
#pragma kernel TemporalAccumulationColor                        TEMPORAL_ACCUMULATION=TemporalAccumulationColor
#pragma kernel TemporalAccumulationColorArray                   TEMPORAL_ACCUMULATION=TemporalAccumulationColorArray HISTORY_IS_ARRAY

#pragma kernel CopyHistory

#pragma kernel BlendHistorySingleArray                          BLEND_HISTORY_ARRAY=BlendHistorySingleArray SINGLE_CHANNEL OUTPUT_IS_ARRAY
#pragma kernel BlendHistorySingleArrayNoValidity                BLEND_HISTORY_ARRAY=BlendHistorySingleArrayNoValidity SINGLE_CHANNEL OUTPUT_IS_ARRAY NO_VALIDITY
#pragma kernel BlendHistoryColorArray                           BLEND_HISTORY_ARRAY=BlendHistoryColorArray OUTPUT_IS_ARRAY

#pragma kernel OutputHistoryArray                               OUTPUT_IS_ARRAY

#pragma multi_compile _ FULL_RESOLUTION_FILTER

#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

// Common includes
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonLighting.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Sampling/Sampling.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"

// HDRP includes
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Builtin/BuiltinData.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/TemporalAntialiasing.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/Denoising/DenoisingUtils.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/HDTemporalFilter.cs.hlsl"

// #pragma enable_d3d11_debug_symbols

// Tile size of this compute shaders
#define TEMPORAL_FILTER_TILE_SIZE 8

// Depth buffer of the current frame
TEXTURE2D_X(_DepthTexture);
// Stencil buffer of the current frame
TEXTURE2D_X_UINT2(_StencilTexture);
int _ObjectMotionStencilBit;
// Depth buffer of the previous frame
TEXTURE2D_X(_HistoryDepthTexture);
// Normal buffer of the previous frame
TEXTURE2D_X(_HistoryNormalTexture);
// Buffer that stores the result of the validation pass of the history
RW_TEXTURE2D_X(uint, _ValidationBufferRW);
// Velocity buffer for history rejection
TEXTURE2D_X(_VelocityBuffer);
// This holds the fov angle of a pixel
float _PixelSpreadAngleTangent;
// Value that tells us if the current history should be discarded based on scene-level data
float _HistoryValidity;
// Controls if the motion of the receiver is a valid rejection codition.
int _ReceiverMotionRejection;
// Controls if the motion of the receiver is a valid rejection codition.
int _OccluderMotionRejection;
// Value that tells us if the current history should be discarded based on scene-level data
int _EnableExposureControl;

// The maximal normal difference threshold
#define MAX_NORMAL_DIFFERENCE 0.65
// The minimal motion distance
#define MINIMAL_MOTION_DISTANCE 0.0001

[numthreads(TEMPORAL_FILTER_TILE_SIZE, TEMPORAL_FILTER_TILE_SIZE, 1)]
void ValidateHistory(uint3 dispatchThreadId : SV_DispatchThreadID, uint2 groupThreadId : SV_GroupThreadID, uint2 groupId : SV_GroupID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);

    // Fetch the current pixel coordinates
    uint2 centerCoord = groupId * TEMPORAL_FILTER_TILE_SIZE + groupThreadId;

    // Get the posinputs of the current version of the pixel
    float depth = LOAD_TEXTURE2D_X(_DepthTexture, centerCoord).r;
    PositionInputs posInputs = GetPositionInput(centerCoord, _ScreenSize.zw, depth, UNITY_MATRIX_I_VP, GetWorldToViewMatrix());

    // Initialize the history validation result
    uint historyRejectionResult = 0;

    // If the current point we are processing is a background point or the whole history should be discarded for an other reason, we invalidate the history
    if (depth == UNITY_RAW_FAR_CLIP_VALUE || _HistoryValidity == 0.0f)
    {
        _ValidationBufferRW[COORD_TEXTURE2D_X(centerCoord)] = HISTORYREJECTIONFLAGS_COMBINED;
        return;
    }

    // Decode the velocity of the pixel
    float2 velocity = float2(0.0, 0.0);
    DecodeMotionVector(LOAD_TEXTURE2D_X(_CameraMotionVectorsTexture, (float2)centerCoord), velocity);

    // Compute the pixel coordinate for the history tapping
    float2 historyTapCoord = (float2)((posInputs.positionNDC - velocity) * _ScreenSize.xy);

    // If the pixel was outside of the screen during the previous frame, invalidate the history
    if (historyTapCoord.x >= _ScreenSize.x || historyTapCoord.x < 0 || historyTapCoord.y >= _ScreenSize.y || historyTapCoord.y < 0)
    {
        _ValidationBufferRW[COORD_TEXTURE2D_X(centerCoord)] = HISTORYREJECTIONFLAGS_REPROJECTION | HISTORYREJECTIONFLAGS_PREVIOUS_DEPTH | HISTORYREJECTIONFLAGS_POSITION | HISTORYREJECTIONFLAGS_NORMAL | HISTORYREJECTIONFLAGS_MOTION;
        return;
    }

    // Fetch the depth of the history pixel. If the history position was a background point, invalidate the history
    float historyDepth = SAMPLE_TEXTURE2D_X_LOD(_HistoryDepthTexture, s_linear_clamp_sampler, historyTapCoord * _ScreenSize.zw * _RTHandleScaleHistory.zw, 0).r;
    if (historyDepth == UNITY_RAW_FAR_CLIP_VALUE)
    {
        _ValidationBufferRW[COORD_TEXTURE2D_X(centerCoord)] = HISTORYREJECTIONFLAGS_PREVIOUS_DEPTH | HISTORYREJECTIONFLAGS_POSITION | HISTORYREJECTIONFLAGS_NORMAL | HISTORYREJECTIONFLAGS_MOTION;
        return;
    }

    // Real the normal data for this pixel
    NormalData normalData;
    DecodeFromNormalBuffer(centerCoord, normalData);

    // Compute the world space position (from previous frame)
    float3 historyPositionWS = ComputeWorldSpacePosition(posInputs.positionNDC - velocity, historyDepth, UNITY_MATRIX_PREV_I_VP);

    // Compute the max reprojection distance. This is evaluated as the max between a fixed radius value and an approximation of the footprint of the pixel.
    float maxRadius = ComputeMaxReprojectionWorldRadius(posInputs.positionWS, normalData.normalWS, _PixelSpreadAngleTangent);

    // Is it too far from the current position?
    if (length(historyPositionWS - posInputs.positionWS) > maxRadius)
        historyRejectionResult = historyRejectionResult | HISTORYREJECTIONFLAGS_POSITION;

    // Compute the world space normal (from previous frame)
    float4 historyNormal = LOAD_TEXTURE2D_X(_HistoryNormalTexture, historyTapCoord);
    NormalData historyNormalData;
    DecodeFromNormalBuffer(historyNormal, historyNormalData);

    // If the current normal is too different from the previous one, discard the history.
    if (dot(normalData.normalWS, historyNormalData.normalWS) < MAX_NORMAL_DIFFERENCE)
        historyRejectionResult = historyRejectionResult | HISTORYREJECTIONFLAGS_NORMAL;

    // Was the object of this pixel moving?
    uint stencilValue = GetStencilValue(LOAD_TEXTURE2D_X(_StencilTexture, centerCoord));
    if ((stencilValue & _ObjectMotionStencilBit) != 0)
        historyRejectionResult = historyRejectionResult | HISTORYREJECTIONFLAGS_MOTION;

    // If none of the previous conditions have failed, the the history is valid
    _ValidationBufferRW[COORD_TEXTURE2D_X(centerCoord)] = historyRejectionResult;
}

// Validation buffer that tells us if the history should be ignored for a given pixel.
TEXTURE2D_X_UINT(_ValidationBuffer);
#ifdef HISTORY_IS_ARRAY
// This buffer holds the previously accumualted signal
TEXTURE2D_ARRAY(_HistoryBuffer);
// This buffers holds additional previously accumulated data
TEXTURE2D_ARRAY(_HistoryValidityBuffer);
#else
// This buffer holds the previously accumualted signal
TEXTURE2D_X(_HistoryBuffer);
#endif
// Noisy Input Buffer from the current rame
TEXTURE2D_X(_DenoiseInputTexture);
// In the case of an array signal, this tells us which slice of the array we should be fetching
int _DenoisingHistorySlice;
// This value tells us which channels hold the value
float4 _DenoisingHistoryMask;
// Generic output buffer for our kernels
RW_TEXTURE2D_X(float4, _AccumulationOutputTextureRW);

[numthreads(TEMPORAL_FILTER_TILE_SIZE, TEMPORAL_FILTER_TILE_SIZE, 1)]
void TEMPORAL_ACCUMULATION(uint3 dispatchThreadId : SV_DispatchThreadID, uint2 groupThreadId : SV_GroupThreadID, uint2 groupId : SV_GroupID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);

    // Fetch the current pixel coordinate
    uint2 currentCoord = groupId * TEMPORAL_FILTER_TILE_SIZE + groupThreadId;
    #ifdef FULL_RESOLUTION_FILTER
    uint2 sourceCoord = currentCoord;
    #else
    uint2 sourceCoord = currentCoord * 2;
    #endif

    // If the depth of this pixel is the depth of the background, we can end the process right away
    float depth = LOAD_TEXTURE2D_X(_DepthTexture, sourceCoord).r;
    if (depth == UNITY_RAW_FAR_CLIP_VALUE)
    {
        _AccumulationOutputTextureRW[COORD_TEXTURE2D_X(currentCoord)] = float4(0.0, 0.0, 0.0, 0);
        return;
    }

    // Fetch the position of the current pixel
    PositionInputs posInputs = GetPositionInput(sourceCoord, _ScreenSize.zw, depth, UNITY_MATRIX_I_VP, GetWorldToViewMatrix());

    // Compute the velocity information for this pixel
    float2 velocity = float2(0.0, 0.0);
    DecodeMotionVector(LOAD_TEXTURE2D_X(_CameraMotionVectorsTexture, (float2)sourceCoord), velocity);
    #ifdef FULL_RESOLUTION_FILTER
    float2 historyTapCoord = (float2)((posInputs.positionNDC - velocity) * _ScreenSize.xy);
    #else
    // Remap the history tap coord into half res space and compensate for the half resolution half pixel shift
    float2 historyTapCoord = (float2)((posInputs.positionNDC - velocity) * _ScreenSize.xy * 0.5) + 0.25;
    #endif

    // Fetch the current value, history value and current sample count
#if HISTORY_IS_ARRAY
    #if SINGLE_CHANNEL
        float color = LOAD_TEXTURE2D_X(_DenoiseInputTexture, currentCoord).x;
        float history = dot(_DenoisingHistoryMask, SAMPLE_TEXTURE2D_ARRAY_LOD(_HistoryBuffer, s_linear_clamp_sampler, historyTapCoord * _ScreenSize.zw * _RTHandleScaleHistory.zw, INDEX_TEXTURE2D_ARRAY_X(_DenoisingHistorySlice), 0));
        float sampleCount = dot(_DenoisingHistoryMask, SAMPLE_TEXTURE2D_ARRAY_LOD(_HistoryValidityBuffer, s_linear_clamp_sampler, historyTapCoord * _ScreenSize.zw * _RTHandleScaleHistory.zw, INDEX_TEXTURE2D_ARRAY_X(_DenoisingHistorySlice), 0));
    #else
        float3 color = LOAD_TEXTURE2D_X(_DenoiseInputTexture, currentCoord).xyz;
        // In case we are processing a color texture, it is always stored in the first three channels
        float3 history = SAMPLE_TEXTURE2D_ARRAY_LOD(_HistoryBuffer, s_linear_clamp_sampler, historyTapCoord * _ScreenSize.zw * _RTHandleScaleHistory.zw, INDEX_TEXTURE2D_ARRAY_X(_DenoisingHistorySlice), 0).xyz;
        float sampleCount = SAMPLE_TEXTURE2D_ARRAY_LOD(_HistoryValidityBuffer, s_linear_clamp_sampler, historyTapCoord * _ScreenSize.zw * _RTHandleScaleHistory.zw, INDEX_TEXTURE2D_ARRAY_X(_DenoisingHistorySlice), 0).x;
    #endif
#else
    #if SINGLE_CHANNEL
        float color = LOAD_TEXTURE2D_X(_DenoiseInputTexture, currentCoord).x;
        float2 history = SAMPLE_TEXTURE2D_X_LOD(_HistoryBuffer, s_linear_clamp_sampler, historyTapCoord * _ScreenSize.zw * _RTHandleScaleHistory.zw, 0).xy;
        float sampleCount = history.y;
    #else
        float3 color = LOAD_TEXTURE2D_X(_DenoiseInputTexture, currentCoord).xyz;
        float4 history = SAMPLE_TEXTURE2D_X_LOD(_HistoryBuffer, s_linear_clamp_sampler, historyTapCoord * _ScreenSize.zw * _RTHandleScaleHistory.zw, 0);
        history.xyz = max(history.xyz, 0);
        float sampleCount = history.w;
        if (_EnableExposureControl == 1)
        {
            // Grab the previous frame and current frame exposures
            float prevExposure = GetPreviousExposureMultiplier();
            float currentExposure = GetCurrentExposureMultiplier();

            // Compute the exposure ratio (while avoiding zeros)
            float expRatio = (prevExposure * currentExposure) != 0.0 ? currentExposure / prevExposure : 100.0;

            // Evaluate if the exposure multiplier was at least twice bigger or smaller
            bool validExposurechange = max(expRatio, 1.0 / expRatio) < 2.0;

            // If the exposure change was considered valid, we can keep the result and re-exposed it. Otherwise, we cannot use the history buffer
            if (validExposurechange)
                history.xyz = history.xyz * GetInversePreviousExposureMultiplier() * currentExposure;
            else
                sampleCount = 0.0;
        }
    #endif
#endif

    // Get the velocity of the current sample
    float movingIntersection = _OccluderMotionRejection ? LOAD_TEXTURE2D_X(_VelocityBuffer, currentCoord).r > MINIMAL_MOTION_DISTANCE : 0.0f;

    // Accumulation factor that tells us how much we need to keep the history data
    float accumulationFactor = 0.0;

    // Evaluate our validation mask
    float validationMask = (_ReceiverMotionRejection ? (LOAD_TEXTURE2D_X(_ValidationBuffer, sourceCoord).x) : (LOAD_TEXTURE2D_X(_ValidationBuffer, sourceCoord).x & (~HISTORYREJECTIONFLAGS_MOTION))) != 0 ? 0.0f : 1.0f;

    // Combine the validation mask with the history validity
    bool historyInvalid = ((float)validationMask * _HistoryValidity) < 1.0f;

    // If the history is invalid or the history was flagged as moving (sampleCount == 0.0)
    if (historyInvalid || sampleCount == 0.0 || movingIntersection)
    {
        // We only take the current value
        accumulationFactor = 0.0;
        history = 0.0;
        // And the sample count of history becomes 1 (or 0 if the previous sample was mooving)
        sampleCount = movingIntersection ? 0.0 : 1.0;
    }
    else
    {
        // Otherwise we compute the accumulation factor
        accumulationFactor = sampleCount >= 8.0 ? 0.93 : (sampleCount / (sampleCount + 1.0));
        // Update the sample count
        sampleCount = min(sampleCount + 1.0, 8.0);
    }

    // Store our accumulated value
    #if SINGLE_CHANNEL
    _AccumulationOutputTextureRW[COORD_TEXTURE2D_X(currentCoord)] = float4(color * (1.0 - accumulationFactor) + history.x * accumulationFactor, sampleCount, 0.0, 1.0);
    #else
    _AccumulationOutputTextureRW[COORD_TEXTURE2D_X(currentCoord)] = float4(color * (1.0 - accumulationFactor) + history.xyz * accumulationFactor, sampleCount);
    #endif
}

RW_TEXTURE2D_X(float4, _DenoiseOutputTextureRW);

[numthreads(TEMPORAL_FILTER_TILE_SIZE, TEMPORAL_FILTER_TILE_SIZE, 1)]
void CopyHistory(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);

    #ifdef FULL_RESOLUTION_FILTER
    if (any(dispatchThreadId.xy > uint2(_ScreenSize.xy)))
    #else
    if (any(dispatchThreadId.xy > uint2(_ScreenSize.xy / 2)))
    #endif
        return;  // Out of bounds, discard

    _DenoiseOutputTextureRW[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = LOAD_TEXTURE2D_X(_DenoiseInputTexture, dispatchThreadId.xy);
}

// Output is array textures
TEXTURE2D_ARRAY(_DenoiseInputArrayTexture);
RW_TEXTURE2D_X(float4, _IntermediateDenoiseOutputTextureRW);
TEXTURE2D_X(_IntermediateDenoiseOutputTexture);
RW_TEXTURE2D_ARRAY(float4, _DenoiseOutputArrayTextureRW);

#if !defined(NO_VALIDITY)
    TEXTURE2D_ARRAY(_ValidityInputArrayTexture);
    RW_TEXTURE2D_X(float4, _IntermediateValidityOutputTextureRW);
    TEXTURE2D_X(_IntermediateValidityOutputTexture);
    RW_TEXTURE2D_ARRAY(float4, _ValidityOutputTextureRW);
#endif

[numthreads(TEMPORAL_FILTER_TILE_SIZE, TEMPORAL_FILTER_TILE_SIZE, 1)]
void BLEND_HISTORY_ARRAY(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);

    if (any(dispatchThreadId.xy > uint2(_ScreenSize.xy)))
        return;  // Out of bounds, discard

        // Define which slice we shall be reading from.
        int inputSlice = INDEX_TEXTURE2D_ARRAY_X(_DenoisingHistorySlice);

        // In the case the output being an array, we only need to override the channels that we are currently processing
        float4 previousHistoryValues = LOAD_TEXTURE2D_ARRAY(_DenoiseInputArrayTexture, dispatchThreadId.xy, inputSlice);
    #if !defined(NO_VALIDITY)
        float4 previousValidityValues = LOAD_TEXTURE2D_ARRAY(_ValidityInputArrayTexture, dispatchThreadId.xy, inputSlice);
    #endif

    #if SINGLE_CHANNEL
        _IntermediateDenoiseOutputTextureRW[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = (1.0 - _DenoisingHistoryMask) * previousHistoryValues
                                              + _DenoisingHistoryMask * LOAD_TEXTURE2D_X(_DenoiseInputTexture, dispatchThreadId.xy).x;
        #if !defined(NO_VALIDITY)
        _IntermediateValidityOutputTextureRW[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = (1.0 - _DenoisingHistoryMask) * previousValidityValues
                                              + _DenoisingHistoryMask * LOAD_TEXTURE2D_X(_DenoiseInputTexture, dispatchThreadId.xy).y;
        #endif
    #else
        // If this is a color data, it means we need to override the first three channels
        _IntermediateDenoiseOutputTextureRW[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = float4(LOAD_TEXTURE2D_X(_DenoiseInputTexture, dispatchThreadId.xy).xyz, previousHistoryValues.w);
        #if !defined(NO_VALIDITY)
        _IntermediateValidityOutputTextureRW[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = float4(LOAD_TEXTURE2D_X(_DenoiseInputTexture, dispatchThreadId.xy).www, previousValidityValues.w);
        #endif
    #endif
}

[numthreads(TEMPORAL_FILTER_TILE_SIZE, TEMPORAL_FILTER_TILE_SIZE, 1)]
void OutputHistoryArray(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);

    if (any(dispatchThreadId.xy > uint2(_ScreenSize.xy)))
        return;  // Out of bounds, discard

    // Define which pixel we shall be reading from, writing to.
    uint3 targetPixel = uint3(dispatchThreadId.xy, INDEX_TEXTURE2D_ARRAY_X(_DenoisingHistorySlice));

    // If this is a color data, it means we need to override the first three channels
    _DenoiseOutputArrayTextureRW[targetPixel] = LOAD_TEXTURE2D_X(_IntermediateDenoiseOutputTexture, dispatchThreadId.xy);
    #if !defined(NO_VALIDITY)
    _ValidityOutputTextureRW[targetPixel] = LOAD_TEXTURE2D_X(_IntermediateValidityOutputTexture, dispatchThreadId.xy);
    #endif
}
