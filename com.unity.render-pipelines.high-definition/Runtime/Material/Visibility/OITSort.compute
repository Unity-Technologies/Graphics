#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/TextureXR.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Visibility/VisibilityOITResources.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/PostProcessDefines.hlsl"

//#pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

#pragma kernel OITSort_Init
#pragma kernel OITSort_BinPixels
#pragma kernel OITSort_Swap
#pragma kernel OITSort_Network_4
#pragma kernel OITSort_Network_8
#pragma kernel OITSort_Network_16
#pragma kernel OITSort_Network_32
#pragma kernel OITSort_GroupShared

// BUG: For some reason, the binding system refuses to work unless the visibility buffer resource is provided as read/write instead of read only.
//      This may have something to do with it moving from an SRV -> UAV descriptor type when the write capability is added.
//      When this is resolved, this section of code should be removed and this shader should use VisibilityOIT::GetVisibilitySamplePackedDepth instead.
RWByteAddressBuffer _RWVisOITBuffer;

uint GetVisibilitySamplePackedDepth(uint i, uint listOffset)
{
    return ((_RWVisOITBuffer.Load3(((listOffset + i) * 3) << 2).y >> 16) & 0xFFFF);
}

[numthreads(1, 1, 1)]
void OITSort_Init()
{
    uint previousSum = 0;

    // Calculate the pixel list offets via prefix sum
    for (uint sortVariantIndex = 0; sortVariantIndex < kSorting_NumVariants; ++sortVariantIndex)
    {
        uint currentSum = _OITSortMemoryBuffer[kSorting_SumsOffset + sortVariantIndex];

        _OITSortMemoryBuffer[kSorting_PixelListOffsetsOffset + sortVariantIndex] = previousSum;

        previousSum += currentSum;
    }

    // Set up indirect args
    // This part is unfortunately still manual since the shaders have different thread group sizes

    uint sum2   = _OITSortMemoryBuffer[kSorting_SumsOffset + 0];
    uint sum4   = _OITSortMemoryBuffer[kSorting_SumsOffset + 1];
    uint sum8   = _OITSortMemoryBuffer[kSorting_SumsOffset + 2];
    uint sum16  = _OITSortMemoryBuffer[kSorting_SumsOffset + 3];
    uint sum32  = _OITSortMemoryBuffer[kSorting_SumsOffset + 4];
    uint sumBig = _OITSortMemoryBuffer[kSorting_SumsOffset + 5];

    uint3 numGroups2   = uint3((sum2 + 63) / 64, 1, 1);
    uint3 numGroups4   = uint3((sum4 + 63) / 64, 1, 1);
    uint3 numGroups8   = uint3((sum8 + 63) / 64, 1, 1);
    uint3 numGroups16  = uint3((sum16 + 63) / 64, 1, 1);
    uint3 numGroups32  = uint3((sum32 + 63) / 64, 1, 1);
    uint3 numGroupsBig = uint3(sumBig, 1, 1);

    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 0]  = numGroups2.x;
    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 1]  = numGroups2.y;
    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 2]  = numGroups2.z;

    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 3]  = numGroups4.x;
    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 4]  = numGroups4.y;
    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 5]  = numGroups4.z;

    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 6]  = numGroups8.x;
    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 7]  = numGroups8.y;
    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 8]  = numGroups8.z;

    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 9]  = numGroups16.x;
    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 10] = numGroups16.y;
    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 11] = numGroups16.z;

    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 12] = numGroups32.x;
    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 13] = numGroups32.y;
    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 14] = numGroups32.z;

    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 15] = numGroupsBig.x;
    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 16] = numGroupsBig.y;
    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 17] = numGroupsBig.z;
}

[numthreads(8, 8, 1)]
void OITSort_BinPixels(int3 dispatchThreadID : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadID.z);

    if (any(dispatchThreadID.xy >= (int2)_ScreenSize.xy))
        return;

    uint outputPixel = dispatchThreadID.y * (int)_ScreenSize.x + dispatchThreadID.x;
    uint listCount = _VisOITListsCounts.Load(outputPixel << 2);

    //// List sizes of 0 or 1 don't need any sorting
    if (listCount < 2)
        return;

    uint sortVariantOffset = Sorting::GetVariantOffset(listCount);

    uint sortCounterAddr = kSorting_CountersOffset + sortVariantOffset;
    uint sortIndexOffsetAddr = kSorting_PixelListOffsetsOffset + sortVariantOffset;

    uint globalSortIndexOffset = _OITSortMemoryBuffer[sortIndexOffsetAddr];
    uint localSortIndexOffset;
    InterlockedAdd(_OITSortMemoryBuffer[sortCounterAddr], 1, localSortIndexOffset);

    uint sortIndexAddr = kSorting_PixelListDataOffset + globalSortIndexOffset + localSortIndexOffset;
    _OITSortMemoryBuffer[sortIndexAddr] = outputPixel;
}

[numthreads(64, 1, 1)]
void OITSort_Swap(int3 dispatchThreadId : SV_DispatchThreadID)
{
    uint threadIndex = dispatchThreadId.x;

    // Load pixel index
    uint sortVariantOffset = 0;
    uint sortSumAddr = kSorting_SumsOffset + sortVariantOffset;

    uint numPixels = _OITSortMemoryBuffer[sortSumAddr];

    // Note: this is always 0 since this is the first group
    //uint sortIndexOffsetAddr = 6 + sortVariantOffset;
    //uint globalSortIndexOffset = _OITSortMemoryBuffer.Load(sortIndexOffsetAddr);
    uint globalSortIndexOffset = 0;

    if (threadIndex < numPixels)
    {
        uint pixelIndexAddr = kSorting_PixelListDataOffset + globalSortIndexOffset + threadIndex;
        uint pixelIndex = _OITSortMemoryBuffer[pixelIndexAddr];

        // This variant ONLY works on exactly 2 samples
        uint listCount = 2;
        uint listOffset = _VisOITListsOffsets.Load(pixelIndex << 2);

        uint sampleDepth0 = GetVisibilitySamplePackedDepth(0, listOffset);
        uint sampleDepth1 = GetVisibilitySamplePackedDepth(1, listOffset);

        uint keyIndex0 = 0;
        uint keyIndex1 = 1;

        if (sampleDepth0 < sampleDepth1)
        {
            keyIndex0 = 1;
            keyIndex1 = 0;
        }

        uint sortIndicesBaseAddr = kSorting_PixelListDataOffset + (_ScreenSize.x * _ScreenSize.y) + listOffset;

        _OITSortMemoryBuffer[sortIndicesBaseAddr + 0] = keyIndex0;
        _OITSortMemoryBuffer[sortIndicesBaseAddr + 1] = keyIndex1;
    }
}

// Please turn this into a v_swap ;)
void SwapUint(inout uint a, inout uint b)
{
    uint temp = a;
    a = b;
    b = temp;
}

uint GenerateSortKey(uint keyIndex, uint listCount, uint listOffset)
{
    uint key = 0;
    if (keyIndex < listCount)
    {
        uint packedDepth = GetVisibilitySamplePackedDepth(keyIndex, listOffset);
        key = ((packedDepth & 0xFFFF) << 16) | (0xFF << 8) | (keyIndex & 0xFF);
    }
    return key;
}

#define CSWAP(a, b) if (a < b) SwapUint(a, b)
#define MAX_NETWORK_INPUTS_4 4
#define MAX_NETWORK_INPUTS_8 8
#define MAX_NETWORK_INPUTS_16 16
#define MAX_NETWORK_INPUTS_32 32

[numthreads(64, 1, 1)]
void OITSort_Network_4(int3 dispatchThreadId : SV_DispatchThreadID)
{
    uint threadIndex = dispatchThreadId.x;

    uint sortVariantOffset = 1;
    uint sortIndexOffsetAddr = kSorting_PixelListOffsetsOffset + sortVariantOffset;
    uint globalSortIndexOffset = _OITSortMemoryBuffer.Load(sortIndexOffsetAddr);

    // Load pixel index
    uint sortSumAddr = kSorting_SumsOffset + sortVariantOffset;

    uint numPixels = _OITSortMemoryBuffer[sortSumAddr];

    if (threadIndex < numPixels)
    {
        uint pixelIndexAddr = kSorting_PixelListDataOffset + globalSortIndexOffset + threadIndex;
        uint pixelIndex = _OITSortMemoryBuffer[pixelIndexAddr];

        uint listCount = _VisOITListsCounts.Load(pixelIndex << 2);
        uint listOffset = _VisOITListsOffsets.Load(pixelIndex << 2);

        // Generate sort keys from depth
        uint sortKeys[MAX_NETWORK_INPUTS_4];
        for (uint sortKeyIndex = 0; sortKeyIndex < MAX_NETWORK_INPUTS_4; ++sortKeyIndex)
        {
            sortKeys[sortKeyIndex] = GenerateSortKey(sortKeyIndex, listCount, listOffset);
        }

        // Sort the keys (4 input batcher)
        CSWAP(sortKeys[0], sortKeys[2]);
        CSWAP(sortKeys[1], sortKeys[3]);
        CSWAP(sortKeys[0], sortKeys[1]);
        CSWAP(sortKeys[2], sortKeys[3]);
        CSWAP(sortKeys[1], sortKeys[2]);

        uint sortIndicesBaseAddr = kSorting_PixelListDataOffset + (_ScreenSize.x * _ScreenSize.y) + listOffset;

        for (uint storeIndex = 0; storeIndex < MAX_NETWORK_INPUTS_4; ++storeIndex)
        {
            uint sortedIndex = (sortKeys[storeIndex] & 0xFF);
            uint sortIndexAddr = sortIndicesBaseAddr + storeIndex;

            if (storeIndex < listCount)
            {
                _OITSortMemoryBuffer[sortIndexAddr] = sortedIndex;
            }
        }
    }
}

[numthreads(64, 1, 1)]
void OITSort_Network_8(int3 dispatchThreadId : SV_DispatchThreadID)
{
    uint threadIndex = dispatchThreadId.x;

    uint sortVariantOffset = 2;
    uint sortIndexOffsetAddr = kSorting_PixelListOffsetsOffset + sortVariantOffset;
    uint globalSortIndexOffset = _OITSortMemoryBuffer.Load(sortIndexOffsetAddr);

    // Load pixel index
    uint sortSumAddr = kSorting_SumsOffset + sortVariantOffset;

    uint numPixels = _OITSortMemoryBuffer[sortSumAddr];

    if (threadIndex < numPixels)
    {
        uint pixelIndexAddr = kSorting_PixelListDataOffset + globalSortIndexOffset + threadIndex;
        uint pixelIndex = _OITSortMemoryBuffer[pixelIndexAddr];

        uint listCount = _VisOITListsCounts.Load(pixelIndex << 2);
        uint listOffset = _VisOITListsOffsets.Load(pixelIndex << 2);

        // Generate sort keys from depth
        uint sortKeys[MAX_NETWORK_INPUTS_8];
        for (uint sortKeyIndex = 0; sortKeyIndex < MAX_NETWORK_INPUTS_8; ++sortKeyIndex)
        {
            sortKeys[sortKeyIndex] = GenerateSortKey(sortKeyIndex, listCount, listOffset);
        }

        // Sort the keys (8 input batcher)
        CSWAP(sortKeys[0], sortKeys[4]);
        CSWAP(sortKeys[1], sortKeys[5]);
        CSWAP(sortKeys[2], sortKeys[6]);
        CSWAP(sortKeys[3], sortKeys[7]);
        CSWAP(sortKeys[0], sortKeys[2]);
        CSWAP(sortKeys[1], sortKeys[3]);
        CSWAP(sortKeys[4], sortKeys[6]);
        CSWAP(sortKeys[5], sortKeys[7]);
        CSWAP(sortKeys[2], sortKeys[4]);
        CSWAP(sortKeys[3], sortKeys[5]);
        CSWAP(sortKeys[0], sortKeys[1]);
        CSWAP(sortKeys[6], sortKeys[7]);
        CSWAP(sortKeys[2], sortKeys[3]);
        CSWAP(sortKeys[4], sortKeys[5]);
        CSWAP(sortKeys[1], sortKeys[4]);
        CSWAP(sortKeys[3], sortKeys[6]);
        CSWAP(sortKeys[1], sortKeys[2]);
        CSWAP(sortKeys[3], sortKeys[4]);
        CSWAP(sortKeys[5], sortKeys[6]);

        uint sortIndicesBaseAddr = kSorting_PixelListDataOffset + (_ScreenSize.x * _ScreenSize.y) + listOffset;

        for (uint storeIndex = 0; storeIndex < MAX_NETWORK_INPUTS_8; ++storeIndex)
        {
            uint sortedIndex = (sortKeys[storeIndex] & 0xFF);
            uint sortIndexAddr = sortIndicesBaseAddr + storeIndex;

            if (storeIndex < listCount)
            {
                _OITSortMemoryBuffer[sortIndexAddr] = sortedIndex;
            }
        }
    }
}

[numthreads(64, 1, 1)]
void OITSort_Network_16(int3 dispatchThreadId : SV_DispatchThreadID)
{
    uint threadIndex = dispatchThreadId.x;

    uint sortVariantOffset = 3;
    uint sortIndexOffsetAddr = kSorting_PixelListOffsetsOffset + sortVariantOffset;
    uint globalSortIndexOffset = _OITSortMemoryBuffer.Load(sortIndexOffsetAddr);

    // Load pixel index
    uint sortSumAddr = kSorting_SumsOffset + sortVariantOffset;

    uint numPixels = _OITSortMemoryBuffer[sortSumAddr];

    if (threadIndex < numPixels)
    {
        uint pixelIndexAddr = kSorting_PixelListDataOffset + globalSortIndexOffset + threadIndex;
        uint pixelIndex = _OITSortMemoryBuffer[pixelIndexAddr];

        uint listCount = _VisOITListsCounts.Load(pixelIndex << 2);
        uint listOffset = _VisOITListsOffsets.Load(pixelIndex << 2);

        // Generate sort keys from depth
        uint sortKeys[MAX_NETWORK_INPUTS_16];
        for (uint sortKeyIndex = 0; sortKeyIndex < MAX_NETWORK_INPUTS_16; ++sortKeyIndex)
        {
            sortKeys[sortKeyIndex] = GenerateSortKey(sortKeyIndex, listCount, listOffset);
        }

        // Sort the keys (16 input green)
        CSWAP(sortKeys[0], sortKeys[1]);
        CSWAP(sortKeys[2], sortKeys[3]);
        CSWAP(sortKeys[4], sortKeys[5]);
        CSWAP(sortKeys[6], sortKeys[7]);
        CSWAP(sortKeys[8], sortKeys[9]);
        CSWAP(sortKeys[10], sortKeys[11]);
        CSWAP(sortKeys[12], sortKeys[13]);
        CSWAP(sortKeys[14], sortKeys[15]);
        CSWAP(sortKeys[0], sortKeys[2]);
        CSWAP(sortKeys[4], sortKeys[6]);
        CSWAP(sortKeys[8], sortKeys[10]);
        CSWAP(sortKeys[12], sortKeys[14]);
        CSWAP(sortKeys[1], sortKeys[3]);
        CSWAP(sortKeys[5], sortKeys[7]);
        CSWAP(sortKeys[9], sortKeys[11]);
        CSWAP(sortKeys[13], sortKeys[15]);
        CSWAP(sortKeys[0], sortKeys[4]);
        CSWAP(sortKeys[8], sortKeys[12]);
        CSWAP(sortKeys[1], sortKeys[5]);
        CSWAP(sortKeys[9], sortKeys[13]);
        CSWAP(sortKeys[2], sortKeys[6]);
        CSWAP(sortKeys[10], sortKeys[14]);
        CSWAP(sortKeys[3], sortKeys[7]);
        CSWAP(sortKeys[11], sortKeys[15]);
        CSWAP(sortKeys[0], sortKeys[8]);
        CSWAP(sortKeys[1], sortKeys[9]);
        CSWAP(sortKeys[2], sortKeys[10]);
        CSWAP(sortKeys[3], sortKeys[11]);
        CSWAP(sortKeys[4], sortKeys[12]);
        CSWAP(sortKeys[5], sortKeys[13]);
        CSWAP(sortKeys[6], sortKeys[14]);
        CSWAP(sortKeys[7], sortKeys[15]);
        CSWAP(sortKeys[5], sortKeys[10]);
        CSWAP(sortKeys[6], sortKeys[9]);
        CSWAP(sortKeys[3], sortKeys[12]);
        CSWAP(sortKeys[13], sortKeys[14]);
        CSWAP(sortKeys[7], sortKeys[11]);
        CSWAP(sortKeys[1], sortKeys[2]);
        CSWAP(sortKeys[4], sortKeys[8]);
        CSWAP(sortKeys[1], sortKeys[4]);
        CSWAP(sortKeys[7], sortKeys[13]);
        CSWAP(sortKeys[2], sortKeys[8]);
        CSWAP(sortKeys[11], sortKeys[14]);
        CSWAP(sortKeys[5], sortKeys[6]);
        CSWAP(sortKeys[9], sortKeys[10]);
        CSWAP(sortKeys[2], sortKeys[4]);
        CSWAP(sortKeys[11], sortKeys[13]);
        CSWAP(sortKeys[3], sortKeys[8]);
        CSWAP(sortKeys[7], sortKeys[12]);
        CSWAP(sortKeys[6], sortKeys[8]);
        CSWAP(sortKeys[10], sortKeys[12]);
        CSWAP(sortKeys[3], sortKeys[5]);
        CSWAP(sortKeys[7], sortKeys[9]);
        CSWAP(sortKeys[3], sortKeys[4]);
        CSWAP(sortKeys[5], sortKeys[6]);
        CSWAP(sortKeys[7], sortKeys[8]);
        CSWAP(sortKeys[9], sortKeys[10]);
        CSWAP(sortKeys[11], sortKeys[12]);
        CSWAP(sortKeys[6], sortKeys[7]);
        CSWAP(sortKeys[8], sortKeys[9]);

        uint sortIndicesBaseAddr = kSorting_PixelListDataOffset + (_ScreenSize.x * _ScreenSize.y) + listOffset;

        for (uint storeIndex = 0; storeIndex < MAX_NETWORK_INPUTS_16; ++storeIndex)
        {
            uint sortedIndex = (sortKeys[storeIndex] & 0xFF);
            uint sortIndexAddr = sortIndicesBaseAddr + storeIndex;

            if (storeIndex < listCount)
            {
                _OITSortMemoryBuffer[sortIndexAddr] = sortedIndex;
            }
        }
    }
}

[numthreads(64, 1, 1)]
void OITSort_Network_32(int3 dispatchThreadId : SV_DispatchThreadID)
{
    uint threadIndex = dispatchThreadId.x;

    uint sortVariantOffset = 4;
    uint sortIndexOffsetAddr = kSorting_PixelListOffsetsOffset + sortVariantOffset;
    uint globalSortIndexOffset = _OITSortMemoryBuffer.Load(sortIndexOffsetAddr);

    // Load pixel index
    uint sortSumAddr = kSorting_SumsOffset + sortVariantOffset;

    uint numPixels = _OITSortMemoryBuffer[sortSumAddr];

    if (threadIndex < numPixels)
    {
        uint pixelIndexAddr = kSorting_PixelListDataOffset + globalSortIndexOffset + threadIndex;
        uint pixelIndex = _OITSortMemoryBuffer[pixelIndexAddr];

        uint listCount = _VisOITListsCounts.Load(pixelIndex << 2);
        uint listOffset = _VisOITListsOffsets.Load(pixelIndex << 2);

        // Generate sort keys from depth
        uint sortKeys[MAX_NETWORK_INPUTS_32];
        for (uint sortKeyIndex = 0; sortKeyIndex < MAX_NETWORK_INPUTS_32; ++sortKeyIndex)
        {
            sortKeys[sortKeyIndex] = GenerateSortKey(sortKeyIndex, listCount, listOffset);
        }

        // Sort the keys (32 input batcher newtwork)
        CSWAP(sortKeys[0], sortKeys[16]);
        CSWAP(sortKeys[1], sortKeys[17]);
        CSWAP(sortKeys[2], sortKeys[18]);
        CSWAP(sortKeys[3], sortKeys[19]);
        CSWAP(sortKeys[4], sortKeys[20]);
        CSWAP(sortKeys[5], sortKeys[21]);
        CSWAP(sortKeys[6], sortKeys[22]);
        CSWAP(sortKeys[7], sortKeys[23]);
        CSWAP(sortKeys[8], sortKeys[24]);
        CSWAP(sortKeys[9], sortKeys[25]);
        CSWAP(sortKeys[10], sortKeys[26]);
        CSWAP(sortKeys[11], sortKeys[27]);
        CSWAP(sortKeys[12], sortKeys[28]);
        CSWAP(sortKeys[13], sortKeys[29]);
        CSWAP(sortKeys[14], sortKeys[30]);
        CSWAP(sortKeys[15], sortKeys[31]);
        CSWAP(sortKeys[0], sortKeys[8]);
        CSWAP(sortKeys[1], sortKeys[9]);
        CSWAP(sortKeys[2], sortKeys[10]);
        CSWAP(sortKeys[3], sortKeys[11]);
        CSWAP(sortKeys[4], sortKeys[12]);
        CSWAP(sortKeys[5], sortKeys[13]);
        CSWAP(sortKeys[6], sortKeys[14]);
        CSWAP(sortKeys[7], sortKeys[15]);
        CSWAP(sortKeys[16], sortKeys[24]);
        CSWAP(sortKeys[17], sortKeys[25]);
        CSWAP(sortKeys[18], sortKeys[26]);
        CSWAP(sortKeys[19], sortKeys[27]);
        CSWAP(sortKeys[20], sortKeys[28]);
        CSWAP(sortKeys[21], sortKeys[29]);
        CSWAP(sortKeys[22], sortKeys[30]);
        CSWAP(sortKeys[23], sortKeys[31]);
        CSWAP(sortKeys[8], sortKeys[16]);
        CSWAP(sortKeys[9], sortKeys[17]);
        CSWAP(sortKeys[10], sortKeys[18]);
        CSWAP(sortKeys[11], sortKeys[19]);
        CSWAP(sortKeys[12], sortKeys[20]);
        CSWAP(sortKeys[13], sortKeys[21]);
        CSWAP(sortKeys[14], sortKeys[22]);
        CSWAP(sortKeys[15], sortKeys[23]);
        CSWAP(sortKeys[0], sortKeys[4]);
        CSWAP(sortKeys[1], sortKeys[5]);
        CSWAP(sortKeys[2], sortKeys[6]);
        CSWAP(sortKeys[3], sortKeys[7]);
        CSWAP(sortKeys[24], sortKeys[28]);
        CSWAP(sortKeys[25], sortKeys[29]);
        CSWAP(sortKeys[26], sortKeys[30]);
        CSWAP(sortKeys[27], sortKeys[31]);
        CSWAP(sortKeys[8], sortKeys[12]);
        CSWAP(sortKeys[9], sortKeys[13]);
        CSWAP(sortKeys[10], sortKeys[14]);
        CSWAP(sortKeys[11], sortKeys[15]);
        CSWAP(sortKeys[16], sortKeys[20]);
        CSWAP(sortKeys[17], sortKeys[21]);
        CSWAP(sortKeys[18], sortKeys[22]);
        CSWAP(sortKeys[19], sortKeys[23]);
        CSWAP(sortKeys[0], sortKeys[2]);
        CSWAP(sortKeys[1], sortKeys[3]);
        CSWAP(sortKeys[28], sortKeys[30]);
        CSWAP(sortKeys[29], sortKeys[31]);
        CSWAP(sortKeys[4], sortKeys[16]);
        CSWAP(sortKeys[5], sortKeys[17]);
        CSWAP(sortKeys[6], sortKeys[18]);
        CSWAP(sortKeys[7], sortKeys[19]);
        CSWAP(sortKeys[12], sortKeys[24]);
        CSWAP(sortKeys[13], sortKeys[25]);
        CSWAP(sortKeys[14], sortKeys[26]);
        CSWAP(sortKeys[15], sortKeys[27]);
        CSWAP(sortKeys[0], sortKeys[1]);
        CSWAP(sortKeys[30], sortKeys[31]);
        CSWAP(sortKeys[4], sortKeys[8]);
        CSWAP(sortKeys[5], sortKeys[9]);
        CSWAP(sortKeys[6], sortKeys[10]);
        CSWAP(sortKeys[7], sortKeys[11]);
        CSWAP(sortKeys[12], sortKeys[16]);
        CSWAP(sortKeys[13], sortKeys[17]);
        CSWAP(sortKeys[14], sortKeys[18]);
        CSWAP(sortKeys[15], sortKeys[19]);
        CSWAP(sortKeys[20], sortKeys[24]);
        CSWAP(sortKeys[21], sortKeys[25]);
        CSWAP(sortKeys[22], sortKeys[26]);
        CSWAP(sortKeys[23], sortKeys[27]);
        CSWAP(sortKeys[4], sortKeys[6]);
        CSWAP(sortKeys[5], sortKeys[7]);
        CSWAP(sortKeys[8], sortKeys[10]);
        CSWAP(sortKeys[9], sortKeys[11]);
        CSWAP(sortKeys[12], sortKeys[14]);
        CSWAP(sortKeys[13], sortKeys[15]);
        CSWAP(sortKeys[16], sortKeys[18]);
        CSWAP(sortKeys[17], sortKeys[19]);
        CSWAP(sortKeys[20], sortKeys[22]);
        CSWAP(sortKeys[21], sortKeys[23]);
        CSWAP(sortKeys[24], sortKeys[26]);
        CSWAP(sortKeys[25], sortKeys[27]);
        CSWAP(sortKeys[2], sortKeys[16]);
        CSWAP(sortKeys[3], sortKeys[17]);
        CSWAP(sortKeys[6], sortKeys[20]);
        CSWAP(sortKeys[7], sortKeys[21]);
        CSWAP(sortKeys[10], sortKeys[24]);
        CSWAP(sortKeys[11], sortKeys[25]);
        CSWAP(sortKeys[14], sortKeys[28]);
        CSWAP(sortKeys[15], sortKeys[29]);
        CSWAP(sortKeys[2], sortKeys[8]);
        CSWAP(sortKeys[3], sortKeys[9]);
        CSWAP(sortKeys[6], sortKeys[12]);
        CSWAP(sortKeys[7], sortKeys[13]);
        CSWAP(sortKeys[10], sortKeys[16]);
        CSWAP(sortKeys[11], sortKeys[17]);
        CSWAP(sortKeys[14], sortKeys[20]);
        CSWAP(sortKeys[15], sortKeys[21]);
        CSWAP(sortKeys[18], sortKeys[24]);
        CSWAP(sortKeys[19], sortKeys[25]);
        CSWAP(sortKeys[22], sortKeys[28]);
        CSWAP(sortKeys[23], sortKeys[29]);
        CSWAP(sortKeys[2], sortKeys[4]);
        CSWAP(sortKeys[3], sortKeys[5]);
        CSWAP(sortKeys[6], sortKeys[8]);
        CSWAP(sortKeys[7], sortKeys[9]);
        CSWAP(sortKeys[10], sortKeys[12]);
        CSWAP(sortKeys[11], sortKeys[13]);
        CSWAP(sortKeys[14], sortKeys[16]);
        CSWAP(sortKeys[15], sortKeys[17]);
        CSWAP(sortKeys[18], sortKeys[20]);
        CSWAP(sortKeys[19], sortKeys[21]);
        CSWAP(sortKeys[22], sortKeys[24]);
        CSWAP(sortKeys[23], sortKeys[25]);
        CSWAP(sortKeys[26], sortKeys[28]);
        CSWAP(sortKeys[27], sortKeys[29]);
        CSWAP(sortKeys[2], sortKeys[3]);
        CSWAP(sortKeys[4], sortKeys[5]);
        CSWAP(sortKeys[6], sortKeys[7]);
        CSWAP(sortKeys[8], sortKeys[9]);
        CSWAP(sortKeys[10], sortKeys[11]);
        CSWAP(sortKeys[12], sortKeys[13]);
        CSWAP(sortKeys[14], sortKeys[15]);
        CSWAP(sortKeys[16], sortKeys[17]);
        CSWAP(sortKeys[18], sortKeys[19]);
        CSWAP(sortKeys[20], sortKeys[21]);
        CSWAP(sortKeys[22], sortKeys[23]);
        CSWAP(sortKeys[24], sortKeys[25]);
        CSWAP(sortKeys[26], sortKeys[27]);
        CSWAP(sortKeys[28], sortKeys[29]);
        CSWAP(sortKeys[1], sortKeys[16]);
        CSWAP(sortKeys[3], sortKeys[18]);
        CSWAP(sortKeys[5], sortKeys[20]);
        CSWAP(sortKeys[7], sortKeys[22]);
        CSWAP(sortKeys[9], sortKeys[24]);
        CSWAP(sortKeys[11], sortKeys[26]);
        CSWAP(sortKeys[13], sortKeys[28]);
        CSWAP(sortKeys[15], sortKeys[30]);
        CSWAP(sortKeys[1], sortKeys[8]);
        CSWAP(sortKeys[3], sortKeys[10]);
        CSWAP(sortKeys[5], sortKeys[12]);
        CSWAP(sortKeys[7], sortKeys[14]);
        CSWAP(sortKeys[9], sortKeys[16]);
        CSWAP(sortKeys[11], sortKeys[18]);
        CSWAP(sortKeys[13], sortKeys[20]);
        CSWAP(sortKeys[15], sortKeys[22]);
        CSWAP(sortKeys[17], sortKeys[24]);
        CSWAP(sortKeys[19], sortKeys[26]);
        CSWAP(sortKeys[21], sortKeys[28]);
        CSWAP(sortKeys[23], sortKeys[30]);
        CSWAP(sortKeys[1], sortKeys[4]);
        CSWAP(sortKeys[3], sortKeys[6]);
        CSWAP(sortKeys[5], sortKeys[8]);
        CSWAP(sortKeys[7], sortKeys[10]);
        CSWAP(sortKeys[9], sortKeys[12]);
        CSWAP(sortKeys[11], sortKeys[14]);
        CSWAP(sortKeys[13], sortKeys[16]);
        CSWAP(sortKeys[15], sortKeys[18]);
        CSWAP(sortKeys[17], sortKeys[20]);
        CSWAP(sortKeys[19], sortKeys[22]);
        CSWAP(sortKeys[21], sortKeys[24]);
        CSWAP(sortKeys[23], sortKeys[26]);
        CSWAP(sortKeys[25], sortKeys[28]);
        CSWAP(sortKeys[27], sortKeys[30]);
        CSWAP(sortKeys[1], sortKeys[2]);
        CSWAP(sortKeys[3], sortKeys[4]);
        CSWAP(sortKeys[5], sortKeys[6]);
        CSWAP(sortKeys[7], sortKeys[8]);
        CSWAP(sortKeys[9], sortKeys[10]);
        CSWAP(sortKeys[11], sortKeys[12]);
        CSWAP(sortKeys[13], sortKeys[14]);
        CSWAP(sortKeys[15], sortKeys[16]);
        CSWAP(sortKeys[17], sortKeys[18]);
        CSWAP(sortKeys[19], sortKeys[20]);
        CSWAP(sortKeys[21], sortKeys[22]);
        CSWAP(sortKeys[23], sortKeys[24]);
        CSWAP(sortKeys[25], sortKeys[26]);
        CSWAP(sortKeys[27], sortKeys[28]);
        CSWAP(sortKeys[29], sortKeys[30]);

        uint sortIndicesBaseAddr = kSorting_PixelListDataOffset + (_ScreenSize.x * _ScreenSize.y) + listOffset;

        for (uint storeIndex = 0; storeIndex < MAX_NETWORK_INPUTS_32; ++storeIndex)
        {
            uint sortedIndex = (sortKeys[storeIndex] & 0xFF);
            uint sortIndexAddr = sortIndicesBaseAddr + storeIndex;

            if (storeIndex < listCount)
            {
                _OITSortMemoryBuffer[sortIndexAddr] = sortedIndex;
            }
        }
    }
}

groupshared uint sRadixScratch[256];

[numthreads(256, 1, 1)]
void OITSort_GroupShared(uint3 groupThreadId : SV_GroupThreadID, uint3 groupId: SV_GroupID)
{
    uint threadIndex = groupThreadId.x;

    // Load pixel index

    uint sortVariantOffset = 5;
    uint sortIndexOffsetAddr = kSorting_PixelListOffsetsOffset + sortVariantOffset;
    uint globalSortIndexOffset = _OITSortMemoryBuffer.Load(sortIndexOffsetAddr);

    uint pixelIndexAddr = kSorting_PixelListDataOffset + globalSortIndexOffset + groupId.x;
    uint pixelIndex = _OITSortMemoryBuffer[pixelIndexAddr];

    uint listCount = _VisOITListsCounts.Load(pixelIndex << 2);
    uint listOffset = _VisOITListsOffsets.Load(pixelIndex << 2);

    uint kWaveSize = 32;
    uint kNumWaves = 256 / kWaveSize;
    uint waveIndex = threadIndex / kWaveSize;

    uint numBins = 16;

    uint sortKey = GenerateSortKey(threadIndex, listCount, listOffset);

    // Flip the key so the depth is in the LSBs since we only sort the bottom 16-bits
    // Also flip the depth key value so we get a descending order sort
    sortKey = (sortKey << 16) | (0xFFFF - (sortKey >> 16));

    // 16-bit radix sort (we don't bother sorting the top half since they contain indices)
    for (uint radixPassIndex = 0; radixPassIndex < 4; ++radixPassIndex)
    {
        // Initialize the sum bins to 0
        sRadixScratch[threadIndex] = 0;

        uint binIndex = ((sortKey >> (radixPassIndex * 4)) & 0xF);

        GroupMemoryBarrierWithGroupSync();

        // Increment the bin associated with the current value to sort
        uint localOffset;
        InterlockedAdd(sRadixScratch[binIndex * kNumWaves + waveIndex], 1, localOffset);

        GroupMemoryBarrierWithGroupSync();

        bool isPrefixSumThread = (threadIndex < 128);

        // Compute an inclusive prefix sum on the sum buckets
        for (uint offset = 1; offset < 8; offset <<= 1)
        {
            uint localThreadIndex = threadIndex % 8;
            uint binOffset = (threadIndex / 8) * 8;

            uint sum = 0;
            if (isPrefixSumThread && (localThreadIndex >= offset))
            {
                sum = sRadixScratch[binOffset + localThreadIndex - offset];
            }

            GroupMemoryBarrierWithGroupSync();

            if (isPrefixSumThread)
            {
                sRadixScratch[binOffset + localThreadIndex] += sum;
            }

            GroupMemoryBarrierWithGroupSync();
        }

        localOffset = (waveIndex > 0) ? sRadixScratch[binIndex * kNumWaves + waveIndex - 1] + localOffset : localOffset;

        GroupMemoryBarrierWithGroupSync();

        if (threadIndex < 16)
        {
            sRadixScratch[128 + threadIndex] = sRadixScratch[threadIndex * kNumWaves + 7];
        }

        GroupMemoryBarrierWithGroupSync();

        for (uint offset = 1; offset < 16; offset <<= 1)
        {
            uint sum = 0;
            if (threadIndex >= offset)
            {
                sum = sRadixScratch[128 + threadIndex - offset];
            }

            GroupMemoryBarrierWithGroupSync();

            sRadixScratch[128 + threadIndex] += sum;

            GroupMemoryBarrierWithGroupSync();
        }

        uint globalOffset = sRadixScratch[128 + binIndex];

        GroupMemoryBarrierWithGroupSync();

        uint outputIndex = globalOffset + localOffset;

        sRadixScratch[outputIndex] = sortKey;

        GroupMemoryBarrierWithGroupSync();

        sortKey = sRadixScratch[threadIndex];
    }

    uint sortIndicesBaseAddr = kSorting_PixelListDataOffset + (_ScreenSize.x * _ScreenSize.y) + listOffset;
    uint sortIndexAddr = sortIndicesBaseAddr + threadIndex;

    uint sortedIndex = ((sortKey >> 16) & 0xFF);

    if (threadIndex < listCount)
    {
        _OITSortMemoryBuffer[sortIndexAddr] = sortedIndex;
    }
}
