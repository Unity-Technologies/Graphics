#pragma only_renderers d3d11 playstation xboxone vulkan metal switch

#pragma multi_compile_local _ CLOUD_LAYER_DOUBLE_MODE

#pragma kernel BakeCloudTexture KERNEL_NAME=BakeCloudTexture

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/SkyUtils.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"

#ifndef CLOUD_LAYER_DOUBLE_MODE
    #define NUM_LAYERS  1
    #define LAYER       0
#else
    #define NUM_LAYERS  2
    #define LAYER       dispatchThreadId.z
#endif

TEXTURE2D(_CloudMapA);
SAMPLER(sampler_CloudMapA);

#ifdef CLOUD_LAYER_DOUBLE_MODE
TEXTURE2D(_CloudMapB);
SAMPLER(sampler_CloudMapB);
#endif

RW_TEXTURE2D_ARRAY(float2, _CloudTextureOutput);

float4 _Params;
float4 _Params1[NUM_LAYERS];
float4 _Params2[NUM_LAYERS];

#define _SunDirection           _Params.xyz
#define _CloudUpperHemisphere   (_Params.w > 0)
#define _Resolution             abs(_Params.w)
#define _Opacities              _Params1[LAYER]
#define _CloudRotation          _Params2[LAYER].x
#define _LightingSteps          _Params2[LAYER].y
#define _Thickness              _Params2[LAYER].z


float3 InverseLatLong(float2 uv, bool upperHemisphereOnly)
{
    const float2 invAtan = float2(0.1591, 0.3183);

    uv.y = upperHemisphereOnly ? uv.y * 0.5 + 0.5 : uv.y;
    uv = (uv - 0.5) / invAtan;

    float y = sin(uv.y);
    float scale = sqrt(1.0 - y*y);

    return float3(sin(uv.x) * scale, y, cos(uv.x) * scale);
}

float SampleCloudMap(TEXTURE2D(_CloudMap), SAMPLER(sampler_CloudMap), float2 uv, float4 weights)
{
    float4 cloudLayerColor = SAMPLE_TEXTURE2D_LOD(_CloudMap, sampler_CloudMap, uv, 0);

	float4 clouds = cloudLayerColor * weights;
    return max(max(clouds.r, clouds.g), max(clouds.b, clouds.a));
}

float3 RotationUp(float3 p, float2 cos_sin)
{
    float3 rotDirX = float3(cos_sin.x, 0, -cos_sin.y);
    float3 rotDirY = float3(cos_sin.y, 0,  cos_sin.x);

    return float3(dot(rotDirX, p), p.y, dot(rotDirY, p));
}

float2 ComputeCloudLighting(TEXTURE2D(_CloudMap), SAMPLER(sampler_CloudMap), float2 uv, uint3 dispatchThreadId)
{
    float opacity = SampleCloudMap(_CloudMap, sampler_CloudMap, uv, _Opacities);
    float2 finalColor = float2(1.0, opacity);

    int numSteps = (int)_LightingSteps;
    if (numSteps != 0 && opacity != 0.0)
    {
        float3 sun = -_SunDirection;
        sun = RotationUp(sun, float2(cos(_CloudRotation*PI*2.0), sin(_CloudRotation*PI*2.0)));

        float3 dir = InverseLatLong(uv, _CloudUpperHemisphere);
        float3 marchStep = normalize(sun - dir) * 0.03 / numSteps;

        float density = opacity;
        int i = 0;
        while (++i < numSteps)
        {
            float3 ray = normalize(dir + marchStep * i);

            float2 coords = GetLatLongCoords(ray, _CloudUpperHemisphere);
            density += SampleCloudMap(_CloudMap, sampler_CloudMap, coords, _Opacities);
        }
        density *= 3.0 / _LightingSteps;

        float angle = Smoothstep01(max(dot(sun, dir) - 0.7, 0.0));
        float height = max(0.1 - dir.y, 0.0) * abs(sun.y - dir.y);

        finalColor.x = exp(-density * _Thickness * (1.0-angle/0.7) * (1.0-height/0.1));
    }

    return finalColor;
}

[numthreads(8, 8, NUM_LAYERS)]
void KERNEL_NAME(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    float2 uv = float2(dispatchThreadId.x * _Resolution, dispatchThreadId.y * _Resolution * 2.0f);

#ifndef CLOUD_LAYER_DOUBLE_MODE
    float2 cloudLayerColor = ComputeCloudLighting(_CloudMapA, sampler_CloudMapA, uv, dispatchThreadId);
#else
    float2 cloudLayerColor = LAYER == 0 ?
        ComputeCloudLighting(_CloudMapA, sampler_CloudMapA, uv, dispatchThreadId) :
        ComputeCloudLighting(_CloudMapB, sampler_CloudMapB, uv, dispatchThreadId);
#endif

    dispatchThreadId.x = frac(uv.x + _CloudRotation) / _Resolution;
    _CloudTextureOutput[dispatchThreadId] = cloudLayerColor;
}
