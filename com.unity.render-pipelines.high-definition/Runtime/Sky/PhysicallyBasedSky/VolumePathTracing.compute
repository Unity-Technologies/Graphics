#pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

#pragma kernel main

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightDefinition.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/PhysicallyBasedSky/PhysicallyBasedSkyCommon.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/SkyUtils.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/AtmosphericScattering/AtmosphericScattering.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/CookieSampling.hlsl"

#define DEBUG

#define MAKE_FLT(sgn, exponent, fraction) asfloat((((sgn) & 0x1) << 31) | (((exponent) & 0xFF) << 23) | ((fraction) & 0xFFFFFF))
#define FLT_SNAN MAKE_FLT(0x1, 0xFF, 0x1)
#ifdef DEBUG
    #define ASSERT(x) if (!(bool)(x)) return FLT_SNAN
#else  // DEBUG
    #define ASSERT(x) x
#endif // DEBUG

static const uint s_RandomPrimes[10] = { 0xD974CF83, 0xFAF269B5, 0xAE727FA9, 0x5BA52335, 0xA4E819D5, 0xDD638559, 0xC0972367, 0x4B190D9B, 0xD1894DB5, 0xA78BCBB3 };

TEXTURECUBE(_GroundAlbedoTexture);
TEXTURECUBE(_GroundEmissionTexture);
TEXTURECUBE(_SpaceEmissionTexture);

RW_TEXTURE2D_X(float4, _ColorBuffer);

int _HasGroundAlbedoTexture;    // bool...
int _HasGroundEmissionTexture;  // bool...
int _HasSpaceEmissionTexture;   // bool...
int _RenderSunDisk;             // bool...

float _GroundEmissionMultiplier;
float _SpaceEmissionMultiplier;
uint  _DispatchThreadCount;
uint  _DispatchWidth;
uint  _PassIndex;
uint  _BounceCount;

// 3x3, but Unity can only set 4x4...
float4x4 _PlanetRotation;
float4x4 _SpaceRotation;

struct Ray
{
    float3 origin;
    float3 direction;
    float  frequency;
    float  maxDist;
};

// 'l' is the length of the permutation vector (e.g. the number of strata per dimension).
uint permute(uint i, uint l, uint p)
{
    ASSERT(l != 0);

    if (p == 0) return i; // Identity permutation when (p == 0)

    uint w = l - 1;

    w |= w >> 1;
    w |= w >> 2;
    w |= w >> 4;
    w |= w >> 8;
    w |= w >> 16;
    do
    {
        i ^= p; i *= 0xe170893d;
        i ^= p >> 16;
        i ^= (i & w) >> 4;
        i ^= p >> 8; i *= 0x0929eb3f;
        i ^= p >> 23;
        i ^= (i & w) >> 1; i *= 1 | p >> 27;
        i *= 0x6935fa69;
        i ^= (i & w) >> 11; i *= 0x74dcb303;
        i ^= (i & w) >> 2;  i *= 0x9e501cc3;
        i ^= (i & w) >> 2;  i *= 0xc860a3df;
        i &= w;
        i ^= i >> 5;
    } while (i >= l);

    return (i + p) % l;
}

float randfloat(uint i, uint p)
{
    if (p == 0) return 0.5f; // always 0.5 when (p == 0)

    i ^= p;
    i ^= i >> 17;
    i ^= i >> 10; i *= 0xb36534e5;
    i ^= i >> 12;
    i ^= i >> 21; i *= 0x93fc4795;
    i ^= 0xdf6e307f;
    i ^= i >> 17; i *= 1 | p >> 18;

    float f = i * (1.0f / 4294967808.0f);

    ASSERT(0 <= f && f < 1);

    return f;
}

// Multi-dimensional correlated multi-jittered sequence.
// We specialize it for 6D, which means we generate s^6 points.
float cmj6D(uint pointIndex, uint dimIndex, uint seed)
{
    dimIndex = dimIndex % (6 - 1);

    const uint s = 4;           // Number of strata per dimension
    const uint t = 6;           // Strength of the orthogonal array (number of dimensions)
    const uint n = 4096;        // Size of the sequence: n = s^t
    const uint p = seed;        // Pseudo-random permutation seed
    const uint i = permute(pointIndex, n, p); // Shuffle the points
    const uint j = dimIndex;

    ASSERT(i < n);
    ASSERT(j < t);

    const uint p1 = (p * (j + 1)) * 0x51633e2d;
    const uint p2 = (p * (j + 1)) * 0x68bc21eb;
    const uint p3 = (p * (j + 1)) * 0x02e5be93;

    // TODO: we do not actually need 't' registers.
    // The compiler should be able to fuse the loops below.
    // This formulation is retained for comparison with the reference implementation.
    uint digits[t];

    uint k = i, d = 0;

    // digits = toBaseS(i, s);
    for (d = 0; d < t; k /= s, d++)
    {
        digits[d] = k % s;
    }

    uint stratum = permute(digits[j], s, p1);

    uint poly = 0;

    // digits = allButJ(digits, j);
    // poly   = evalPoly(digits, s);
    for (d = (t - 1); d != j; d--)
    {
        poly = (poly * s) + digits[d]; // Horner's rule
    }
    for (d = (j - 1); d != uint(-1); d--)
    {
        poly = (poly * s) + digits[d]; // Horner's rule
    }

    uint  stm      = n / s; // pow(s, t - 1)
    uint  sStratum = permute(poly, stm, p2);
    float jitter   = randfloat(i, p3);
    float result   = (stratum + (sStratum + jitter) / stm);

    return result / s;
}

// Computes (Exp[x^2] * Erfc[x]) for (x >= 0).
// Range of inputs:  [0, Inf].
// Range of outputs: [0, 1].
float Exp2Erfc(float x)
{
    float t, u, y, z;

    t = 3.97886080735226 / (x + 3.97886080735226);
    u = t - 0.5;
#ifdef DOUBLE_PRECISION
    // Original implementation kindly provided by Takuya Ooura.
    // http://www.kurims.kyoto-u.ac.jp/~ooura/gamerf.html
    y = (((((((((0.00127109764952614092 * u + 1.19314022838340944e-4) * u -
        0.003963850973605135) * u - 8.70779635317295828e-4) * u +
        0.00773672528313526668) * u + 0.00383335126264887303) * u -
        0.0127223813782122755) * u - 0.0133823644533460069) * u +
        0.0161315329733252248) * u + 0.0390976845588484035) * u +
        0.00249367200053503304;
#else
    y = (0.0019898212777384947 * u + 0.039833135938877856) * u +
        0.0034132959838498976;
#endif
    z = ((((((((((((y * u - 0.0838864557023001992) * u -
        0.119463959964325415) * u + 0.0166207924969367356) * u +
        0.357524274449531043) * u + 0.805276408752910567) * u +
        1.18902982909273333) * u + 1.37040217682338167) * u +
        1.31314653831023098) * u + 1.07925515155856677) * u +
        0.774368199119538609) * u + 0.490165080585318424) * u +
        0.275374741597376782) * t;

    return z;
}

float ChapmanUpper(float z, float cosTheta)
{
    float sinTheta = sqrt(saturate(1 - cosTheta * cosTheta));

    float zm12 = rsqrt(z);        // z^(-1/2)
    float zp12 = z * zm12;        // z^(+1/2)

    float tp   = 1 + sinTheta;    // 1 + Sin
    float rstp = rsqrt(tp);       // 1 / Sqrt[1 + Sin]
    float rtp  = rstp * rstp;     // 1 / (1 + Sin)
    float stm  = cosTheta * rstp; // Sqrt[1 - Sin] = Cos / Sqrt[1 + Sin]
    float arg  = zp12 * stm;      // Sqrt[z - z * Sin], argument of Erfc
    float e2ec = Exp2Erfc(arg);   // Exp[x^2] * Erfc[x]

    // Term 1 of Equation 46.
    float mul1 = cosTheta * rtp; // Sqrt[(1 - Sin) / (1 + Sin)] = Cos / (1 + Sin)
    float trm1 = mul1 * (1 - 0.5 * rtp);

    // Term 2 of Equation 46.
    float mul2 = SQRT_PI * rstp * e2ec; // Sqrt[Pi / (1 + Sin)] * Exp[x^2] * Erfc[x]
    float trm2 = mul2 * (zp12 * (-1.5 + tp + rtp) +
                         zm12 * 0.25 * (2 * tp - 1) * rtp);
    return trm1 + trm2;
}

float ChapmanHorizontal(float z)
{
    float zm12 = rsqrt(z);           // z^(-1/2)
    float zm32 = zm12 * zm12 * zm12; // z^(-3/2)

    float p = -0.14687275046666018 + z * (0.4699928014933126 + z * 1.2533141373155001);

    // Equation 47.
    return p * zm32;
}

// z = (r / H), Z = (R / H).
float RescaledChapman(float z, float Z, float cosTheta)
{
    float sinTheta = sqrt(saturate(1 - cosTheta * cosTheta));

    // Cos[Pi - theta] = -Cos[theta],
    // Sin[Pi - theta] =  Sin[theta],
    // so we can just use Abs[Cos[theta]].
    float ch = ChapmanUpper(z, abs(cosTheta)) * exp(Z - z); // Rescaling adds 'exp'

    if (cosTheta < 0)
    {
        // Ch[z, theta] = 2 * Exp[z - z_0] * Ch[z_0, Pi/2] - Ch[z, Pi - theta].
        // z_0 = r_0 / H = (r / H) * Sin[theta] = z * Sin[theta].
        float z_0 = z * sinTheta;
        float chP = ChapmanHorizontal(z_0) * exp(Z - z_0); // Rescaling adds 'exp'

        // Equation 48.
        ch = 2 * chP - ch;
    }

    return ch;
}

float RadAtDist(float r, float cosTheta, float t)
{
    float r2 = r * r + t * (t + 2 * (r * cosTheta));

    // Equation 38.
    return sqrt(r2);
}

float CosAtDist(float r, float cosTheta, float t)
{
    float r2 = r * r + t * (t + 2 * (r * cosTheta));

    // Equation 39.
    return (t + r * cosTheta) * rsqrt(r2);
}

// 'r' is the radial distance from the center of the planet.
// 'viewZ' is the Z coordinate of the view direction.
// 'dist' is the distance.
// seaLvlAtt = (sigma_t * k) is the sea-level (height = 0) attenuation coefficient.
// 'R' is the radius of the planet.
// 'H' is the scale height.
// rcpH = rcp(H) is the falloff exponent.
float3 OptDepthSpherExpMedium(float r, float viewZ, float dist, float R,
                              float3 seaLvlAtt, float H, float rcpH)
{
    float rX        = r;
    float cosThetaX = -viewZ; // p = x - s * v
    float rY        = RadAtDist(rX, cosThetaX, dist);
    float cosThetaY = CosAtDist(rX, cosThetaX, dist);

    // Potentially swap X and Y.
    // Convention: at the point Y, the ray points up.
    cosThetaX = (cosThetaY >= 0) ? cosThetaX : -cosThetaX;
    cosThetaY = abs(cosThetaY);

    float Z   = R  * rcpH;
    float zX  = rX * rcpH;
    float zY  = rY * rcpH;

    float chX = RescaledChapman(zX, Z, cosThetaX);
    float chY = ChapmanUpper(zY, cosThetaY) * exp(Z - zY); // Rescaling adds 'exp'

    // We may have swapped X and Y.
    float ch = abs(chX - chY);

    return ch * H * seaLvlAtt;
}

float ConvertCdfToOpticalDepth(float cdf, float maxOpacity)
{
    // Equation 24.
    return -log(1 - cdf * maxOpacity);
}

#define EPS_ABS  0.0001
#define EPS_REL  0.0001
#define MAX_ITER 20

// 'optDepth' is the value to solve for.
// 'maxOptDepth' is the maximum value along the ray, s.t. (maxOptDepth >= optDepth).
// 'maxDist' is the maximum distance along the ray.
float SampleSpherExpMedium(float optDepth, float r, float viewZ, float R,
                           float2 seaLvlAtt, float2 H, float2 rcpH, // Air & aerosols
                           float maxOptDepth, float maxDist)
{
    const float  rcpOptDepth = rcp(optDepth);
    const float2 Z           = R * rcpH;

    // Make an initial guess.
    // Homogeneous assumption.
    float t = optDepth * rcp(maxOptDepth);

    uint  numIter = 0;
    float absDiff = optDepth, relDiff = 1;
    do // Perform a Newtonâ€“Raphson iteration.
    {
        float cosTheta  = -viewZ; // p = x - s * v
        float radAtDist = RadAtDist(r, cosTheta, t);
        float cosAtDist = CosAtDist(r, cosTheta, t);
        // Evaluate the function and its derivatives:
        // f  [t] = OptDepthAtDist[t] - GivenOptDepth = 0,
        // f' [t] = AttCoefAtDist[t],
        // f''[t] = AttCoefAtDist'[t] = -AttCoefAtDist[t] * CosAtDist[t] / H.
        float optDepthAtDist = 0, attAtDist = 0;
        optDepthAtDist += OptDepthSpherExpMedium(r, viewZ, t, R, seaLvlAtt.x, H.x, rcpH.x); // Air
        optDepthAtDist += OptDepthSpherExpMedium(r, viewZ, t, R, seaLvlAtt.y, H.y, rcpH.y); // Aerosols
        attAtDist      += seaLvlAtt.x * exp(Z.x - radAtDist * rcpH.x);
        attAtDist      += seaLvlAtt.y * exp(Z.y - radAtDist * rcpH.y);

        float  f = optDepthAtDist - optDepth;
        float df = attAtDist;

        ASSERT(df != 0);

        // https://en.wikipedia.org/wiki/Newton%27s_method
        float dt = -f * rcp(df);

        // Refine the initial guess.
        t = clamp(t + dt, 0, maxDist); // Basic overshoot handling

        absDiff = abs(optDepthAtDist - optDepth);
        relDiff = abs(optDepthAtDist * rcpOptDepth - 1);

        numIter++;

        // Stop when the accuracy goal has been reached.
        // Note that this uses the accuracy of the old value of 't'.
        // The new value of 't' we just computed should be even more accurate.
    } while ((absDiff > EPS_ABS) && (relDiff > EPS_REL) && (numIter < MAX_ITER));

    // return t;
    return numIter == MAX_ITER ? 1 : 0;
}

#define GROUP_SIZE_1D 8 // 8^2 == 64
#define GROUP_SIZE_2D (GROUP_SIZE_1D * GROUP_SIZE_1D)
#define TILE_SIZE_1D  4 // 4^2 == 16

// 1x path per thread per call.
// Tracing multiple paths can be achieved via multiple passes (0 <= passIndex < 256).
// Do not access globals from within a pure function.
float3 PathTraceSky(uint2 groupCoordInDispatch, uint groupIndexInDispatch,
                    uint2 threadCoordInGroup, uint threadCountInDispatch,
                    uint groupSize1D, uint tileSize1D, uint bounceCount, uint passIndex,
                    float3 rayOrigin, out uint2 positionSS)
{
    uint tileSize2D      = tileSize1D * tileSize1D;
    uint tilesPerGroup1D = groupSize1D / tileSize1D;
    uint tilesPerGroup2D = Sq(tilesPerGroup1D);

    // Integral over ((1 + NumBounces) * 3) dimensions:
    // 2x for filter IS + 1x for photon frequency selection (bounce #0);
    // 1x for scattering location + 2x for the scattering direction (bounce #i).
    uint dimCount = bounceCount * 3 + 3;

    // We constrain our RNG to 6 dimensions.
    // We generate 4096 (4^6) paths stratified into 4 intervals per dimension.
    // That gives us 256 spp within a 4x4 tile of pixels.
    // The stratification properties of Orthogonal Arrays guarantee 256 spp, but make no promises
    // about the uniformity of the distribution within each individual pixel (or stratum).
    // TODO: it seems we get between 249-257 spp. Floating-point issue?
    // As for the order of generated points, every single pass produces 1spp on average,
    // but this could mean several samples for one pixel and 0 for another.
    // Therefore, we must use atomics for accumulation.
    uint2 tileCoordInGroup    = threadCoordInGroup / tileSize1D;
    uint  tileIndexInGroup    = tileCoordInGroup.y * tilesPerGroup1D + tileCoordInGroup.x;
    uint  tileIndexInDispatch = groupIndexInDispatch * tilesPerGroup2D + tileIndexInGroup;
    uint  tileCountInDispatch = threadCountInDispatch / tileSize2D;
    uint2 threadCoordInTile   = threadCoordInGroup % tileSize1D;
    uint  threadIndexInTile   = threadCoordInTile.y * tileSize1D + threadCoordInTile.x;
    uint  pointIndex          = tileSize2D * passIndex + threadIndexInTile; // Tile of points per pass

    uint bounce = 0;

    // We generate a unique point set per tile every 2 bounces.
    uint   seed = permute(tileIndexInDispatch, tileCountInDispatch, s_RandomPrimes[bounce / 2]);
    float3 rnd  = float3(cmj6D(pointIndex, bounce * 3 + 0, seed),
                         cmj6D(pointIndex, bounce * 3 + 1, seed),
                         cmj6D(pointIndex, bounce * 3 + 2, seed));

    // Determine which pixel the path contributes to.
    float2 filterOffset    = rnd.xy; // TODO: do not use a box filter?
    float2 intraTileOffset = filterOffset * tileSize1D;

    positionSS = groupSize1D * groupCoordInDispatch
               + tileSize1D  * tileCoordInGroup
               + (uint2)intraTileOffset;

    float2 screenCoord = positionSS + frac(intraTileOffset);

    Ray ray; // Pinhole camera...

    // Point away from the camera into the scene.
    ray.direction = -normalize(mul(float4(screenCoord, 1, 1), _PixelCoordToViewDirWS).xyz);
    ray.origin    = rayOrigin;
    ray.frequency = floor(rnd.z * 3); // Color channel, for now...

    // Our atmosphere, theoretically, extends to infinity but, numerically,
    // its density exponentially falls off to zero pretty quickly.
    const float A = _AtmosphericRadius;
    const float R = _PlanetaryRadius;

    // Reparametrize the ray.
    float r, rSq, rRcp, cosTheta;
    ApplySphericalSymmetry(ray.origin, ray.direction, /* -> */ r, rSq, rRcp, cosTheta);

    float2 atmosEntryExit = IntersectSphere(A, cosTheta, r, rRcp);
    bool   hitAtmosphere  = atmosEntryExit.y > 0;

    if (!hitAtmosphere)
    {
        return 0; // TODO: sample the space emission texture.
    }

    // Do not path trace outside the atmosphere.
    if (atmosEntryExit.x > 0)
    {
        ray.origin += atmosEntryExit.x * ray.direction;
        // Careful: we may end up on the edge of the atmosphere and, numerically, outside.
        ray.origin *= (1 - 1e-6); // 2 orders of magnitude larger than FLT_EPS

        // Update ray parameters.
        ApplySphericalSymmetry(ray.origin, ray.direction, /* -> */ r, rSq, rRcp, cosTheta);

        atmosEntryExit.y -= atmosEntryExit.x;
        atmosEntryExit.x  = 0;
    }

    float cosHor       = ComputeCosineOfHorizonAngle(rRcp);
    bool  aboveHorizon = (cosTheta >= cosHor);

    if (aboveHorizon)
    {
        ray.maxDist = atmosEntryExit.y;
    }
    else // Intersect the planet
    {
        ray.maxDist = IntersectSphere(R, cosTheta, r, rRcp).x; // Entry
        ASSERT(ray.maxDist > 0);
    }

    for (bounce = 1; bounce <= bounceCount; bounce++) // Bounces are indexed starting from 1
    {
        seed = permute(tileIndexInDispatch, tileCountInDispatch, s_RandomPrimes[bounce / 2]);
        rnd  = float3(cmj6D(pointIndex, bounce * 3 + 0, seed),
                      cmj6D(pointIndex, bounce * 3 + 1, seed),
                      cmj6D(pointIndex, bounce * 3 + 2, seed));

        float3 optDepth = 0; // Air + aerosols + ozone
        optDepth += OptDepthSpherExpMedium(r, -cosTheta, ray.maxDist, R, _AirSeaLevelExtinction,     _AirScaleHeight,     _AirDensityFalloff);
        optDepth += OptDepthSpherExpMedium(r, -cosTheta, ray.maxDist, R, _AerosolSeaLevelExtinction, _AerosolScaleHeight, _AerosolDensityFalloff);

        float maxSampledOptDepth = optDepth[(uint)ray.frequency];
        float maxSampledOpacity  = OpacityFromOpticalDepth(maxSampledOptDepth);
        float sampledOptDepth    = ConvertCdfToOpticalDepth(rnd.x, maxSampledOpacity);

        float t = SampleSpherExpMedium(sampledOptDepth, r, -cosTheta, R,
                                       float2(_AirSeaLevelExtinction[(uint)ray.frequency], _AerosolSeaLevelExtinction),
                                       float2(_AirScaleHeight, _AerosolScaleHeight),
                                       float2(_AirDensityFalloff, _AerosolDensityFalloff),
                                       maxSampledOptDepth, ray.maxDist);

        return t;
        // return OpacityFromOpticalDepth(optDepth);
    }

    return 0;
}

// Floating-point atomics are not supported. Use fixed-point math in units of HALF_MIN instead.
groupshared uint g_RadianceR[GROUP_SIZE_2D];
groupshared uint g_RadianceG[GROUP_SIZE_2D];
groupshared uint g_RadianceB[GROUP_SIZE_2D];
groupshared uint g_SampleCnt[GROUP_SIZE_2D];

[numthreads(GROUP_SIZE_1D, GROUP_SIZE_1D, 1)]
void main(uint2 groupCoordInDispatch  : SV_GroupID,
          uint2 threadCoordInGroup    : SV_GroupThreadID,
          uint  threadIndexInGroup    : SV_GroupIndex,
          uint2 threadCoordInDispatch : SV_DispatchThreadID)
{
    if (_PassIndex > 255) return;

    const uint groupIndexInDispatch = groupCoordInDispatch.y * _DispatchWidth + groupCoordInDispatch.x;

    // Planet-relative coordinates.
    const float3 origin = _WorldSpaceCameraPos - _PlanetCenterPosition;

    uint2  outPositionSS;
    float3 radiance = PathTraceSky(groupCoordInDispatch, groupIndexInDispatch,
                                   threadCoordInGroup, _DispatchThreadCount,
                                   GROUP_SIZE_1D, TILE_SIZE_1D, _BounceCount, _PassIndex,
                                   origin, outPositionSS);

    // // Find the corresponding coordinate in the groupshared memory.
    // uint outPositionGS = (outPositionSS.y % GROUP_SIZE_1D) * GROUP_SIZE_1D
    //                    + (outPositionSS.x % GROUP_SIZE_1D);

    // // Full clear.
    // g_RadianceR[threadIndexInGroup] = 0;
    // g_RadianceG[threadIndexInGroup] = 0;
    // g_RadianceB[threadIndexInGroup] = 0;
    // g_SampleCnt[threadIndexInGroup] = 0;
    // // Partial fill.
    // GroupMemoryBarrierWithGroupSync();
    // InterlockedAdd(g_RadianceR[outPositionGS], round(radiance.r * 16384)); // Fixed-point
    // InterlockedAdd(g_RadianceG[outPositionGS], round(radiance.g * 16384)); // Fixed-point
    // InterlockedAdd(g_RadianceB[outPositionGS], round(radiance.b * 16384)); // Fixed-point
    // InterlockedAdd(g_SampleCnt[outPositionGS], 1);
    // // Full load.
    // uint sampleCount;
    // GroupMemoryBarrierWithGroupSync();
    // radiance.r  = g_RadianceR[threadIndexInGroup] * rcp(16384);
    // radiance.g  = g_RadianceG[threadIndexInGroup] * rcp(16384);
    // radiance.b  = g_RadianceB[threadIndexInGroup] * rcp(16384);
    // sampleCount = g_SampleCnt[threadIndexInGroup];

    // // We store the sample count in the alpha channel.
    // float3 oldRadiance    = _ColorBuffer[COORD_TEXTURE2D_X(threadCoordInDispatch)].rgb;
    // float  oldSampleCount = round(_ColorBuffer[COORD_TEXTURE2D_X(threadCoordInDispatch)].a);
    // float  newSampleCount = oldSampleCount + sampleCount;
    // float4 newValue       = float4((oldRadiance * oldSampleCount + radiance) * rcp(max(newSampleCount, 1)), newSampleCount);
    // _ColorBuffer[COORD_TEXTURE2D_X(threadCoordInDispatch)] = newValue;
    _ColorBuffer[COORD_TEXTURE2D_X(threadCoordInDispatch)] = radiance.r;
}
