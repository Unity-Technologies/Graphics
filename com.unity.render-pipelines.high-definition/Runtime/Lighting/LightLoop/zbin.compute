// #pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 playstation xboxone vulkan metal switch

#pragma kernel main

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition-config/Runtime/ShaderConfig.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesGlobal.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/TilingAndBinningUtilities.hlsl"

/* ------------------------------ Inputs ------------------------------------ */

// 1x list for all entites (sorted by category, we concatenate lists of all views).
StructuredBuffer<float2> _wBoundsBuffer; // {w_min, w_max}

/* ------------------------------ Outputs ----------------------------------- */

// 1x list for all entites (sorted by category, we concatenate lists of all views).
// The size of the buffer can be computed as follows:
// Z_BIN_COUNT * s_TileEntryLimit / 32 * EYE_COUNT * sizeof(UINT).
// For example (1080p): 8192 * 256 / 32 * 1 * 4 = 256KiB
// For categories that can be depth sorted there is a single DWORD per zbin
// where last and first entity indices packed as follows {last << 16 | first}
RWStructuredBuffer<uint> _zBinBuffer; 

/* ------------------------------ Utilities --------------------------------- */

/* ------------------------------ Implementation ---------------------------- */

float2 ComputeZBinLinearDepthBounds(uint bin, float farPlane)
{
    float2 bBounds = float2(bin, bin + 1);
    float2 zBounds = saturate(bBounds * rcp(Z_BIN_COUNT));
    float2 wBounds = zBounds * farPlane;

    return wBounds; // TODO: add epsilon for numerical robustness?
}

#define THREADS_PER_GROUP (64)

#if IS_MULTIPLE(Z_BIN_COUNT, THREADS_PER_GROUP)
    #error "Z_BIN_COUNT must be an integer multiple of THREADS_PER_GROUP."
#endif

[numthreads(THREADS_PER_GROUP, 1, 1)]
void main(uint threadID : SV_GroupIndex, uint3 groupID : SV_GroupID)
{
    const uint t   = threadID;
    const uint g   = groupID.x;
    const uint cat = groupID.y;
    const uint eye = groupID.z;

    const uint bin = IndexFromCoordinate(uint2(t, g), THREADS_PER_GROUP);

    // Entities are sorted by category.
    const uint entityIndex = s_BoundedEntityOffsetPerCategory[cat];
    const uint entityCount = s_BoundedEntityCountPerCategory[cat];

    if (entityCount > 0) // Avoid wasted work
    {
        const float2 binBounds  = ComputeZBinLinearDepthBounds(bin, rcp(_ZBufferParams.w));
        const uint   inputStart = ComputeEntityBoundsBufferIndex(entityIndex, eye);
		
		if (!IsDepthSorted(cat)) // not sorted by depth
		{
			const uint ZBinBufferOffset = ComputeZBinBufferIndex(bin, cat, eye);
			uint  entityOffset = 0;
			uint  entityMask = 0;
			for (uint i = 0; i < entityCount; i++)
			{
				uint newEntityOffset = i / 32;
				if (newEntityOffset > entityOffset)
				{
					_zBinBuffer[ZBinBufferOffset + entityOffset] = entityMask;
					entityMask = 0;
					entityOffset = newEntityOffset;
				}
				float2 entityBounds = _wBoundsBuffer[inputStart + i];
				// !((entityBounds.y < binBounds.x) || (binBounds.y < entityBounds.x))
				if ((entityBounds.y >= binBounds.x) && (binBounds.y >= entityBounds.x)) // overlap
				{
					entityMask |= (1 << i);
				}
			}
			// make sure we store the last dword
			_zBinBuffer[ZBinBufferOffset + entityOffset] = entityMask;
		}
		else //sorted by depth
		{
			// Imagine that we have n entities in this category.
			// In this case, entity indices would be in the range [0, n - 1].
			// Entities are (approximately) sorted by the z-coordinate.
			// "Classically" (as per Drobot's presentation), if entities with indices
			// in the closed interval [a, b] overlap the bin, we store {a, b}.
			// If no entities overlap the bin, we store {65535, 0}.
			// For queries over z-ranges, this method has a disadvantage, since if the bin is empty,
			// we have no information about the entities that surround the bin.
			// What we would like to store instead is (signed) indices {left, right} = {a - 1, b + 1}.
			// This means we include the largest index (on the left) before we add anything to the bin
			// and the smallest index (on the right) after we are done adding everything to the bin
			// (or we just went past the bin without adding anything).
			// In practice, we iterate over [a, b], but the important part is how we compute these numbers.
			int left = -1, right = (int)entityCount;
			bool isEmpty = true;

			// The algorithm is O(n * m) where 'n' is the entity count and 'm' is bin count.
			// Therefore, it will be slow if 'n' is large.
			// TODO: we should consider a sorting-based algorithm, which could be closer to O((n + m) * log(n)).
			// TODO: unroll.
			for (uint i = 0; i < entityCount; i++)
			{
				float2 entityBounds = _wBoundsBuffer[inputStart + i];

				if (entityBounds.y < binBounds.x)
				{
					// No overlap (entity on the left of the bin).
					left = isEmpty ? (int)i : left;
				}
				else if (binBounds.y < entityBounds.x)
				{
					// No overlap (entity on the right of the bin).
					right = min((int)i, right);
				}
				else
				{
					// Overlap.
					isEmpty = false;
					right = (int)i + 1;
				}
			}
			uint outputIndex = ComputeZBinBufferIndex(bin, cat, eye);

			// Before (open interval):
			// left >= -1, right >= 0.
			uint first = (uint)(left + 1);
			uint last = (uint)(right - 1); // -1 becomes 0xFFFF
			// After (closed interval):
			// first >= 0, last >= -1.
			uint outputRange = (last << 16) | first;

			_zBinBuffer[outputIndex] = outputRange;
		}
    }
}
