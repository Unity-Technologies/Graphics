// #pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 playstation xboxone vulkan metal switch

#pragma multi_compile _ IS_DRAWPROCEDURALINDIRECT

#pragma kernel main

#define FINE_BINNING // Keep in sync with 'deferred.compute' and 'classification.compute'

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.cs.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/TilingAndBinningUtilities.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl"

/* ------------------------------ Inputs ------------------------------------ */

StructuredBuffer<uint> g_TileFeatureFlags;

/* ------------------------------ Outputs ----------------------------------- */

RWBuffer<uint>           g_DispatchIndirectBuffer; // Indirect arguments have to be in a _buffer_, not a structured buffer
RWStructuredBuffer<uint> g_TileList;

/* ------------------------------ Utilities --------------------------------- */


/* ------------------------------ Implementation ---------------------------- */

#ifdef PLATFORM_LANE_COUNT
#define NR_THREADS              PLATFORM_LANE_COUNT
#else
#define NR_THREADS              64                                  // default to 64 threads per group on other platforms..
#endif

[numthreads(NR_THREADS, 1, 1)]
void main(uint3 threadID : SV_DispatchThreadID, uint3 groupID : SV_GroupID)
{
    const uint tile = threadID.x;
    const uint eye  = groupID.z;

    const uint clampedTile = min(tile, TILE_BUFFER_DIMS.x * TILE_BUFFER_DIMS.y - 1);

    // Helper threads may perform the same computation on valid data,
    // but do not store the results of the computation to memory.
    const bool isHelperThread = tile != clampedTile;

    if (isHelperThread) return; // Avoid adding too many checks or branches below

    uint bufferIndex  = clampedTile + IndexFromCoordinate(uint3(0, 0, eye), TILE_BUFFER_DIMS);
    uint featureFlags = g_TileFeatureFlags[bufferIndex];

    // Check if there is no material (means it is a sky/background pixel).
    // Note that a tile may have no lights, and yet we still need to render geometry with precomputed illumination.
    if ((featureFlags & MATERIAL_FEATURE_MASK_FLAGS) != 0)
    {
        uint variant = FeatureFlagsToTileVariant(featureFlags);

        uint tileOffset; // This includes the eye index for XR

        // TODO: optimize this using TGSM or wave intrinsics!
        // We really shouldn't spam the atomic counter located in the global memory...
    #ifdef IS_DRAWPROCEDURALINDIRECT
        // We are filling up an indirect argument (uint4) buffer for DrawProceduralIndirect.
        // The buffer contains {vertex count per instance, instance count, start vertex location, and start instance location}.
        InterlockedAdd(g_DispatchIndirectBuffer[variant * 4 + 1], 1, tileOffset);
    #else
        // We are filling up an indirect argument (uint3) buffer for DispatchIndirect.
        // The buffer contains {groupCntX, groupCntY, groupCntZ} = {groupCnt, 1, 1}.
        InterlockedAdd(g_DispatchIndirectBuffer[variant * 3 + 0], 1, tileOffset);
    #endif

        uint listIndex = tileOffset + IndexFromCoordinate(uint4(0, 0, 0, variant), uint3(TILE_BUFFER_DIMS, _XRViewCount));

        g_TileList[listIndex] = (eye << TILE_INDEX_SHIFT_EYE) | clampedTile; // Must retain the eye index
    }
}
