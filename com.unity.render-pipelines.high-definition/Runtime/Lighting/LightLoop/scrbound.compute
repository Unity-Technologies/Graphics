// #pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 playstation xboxone vulkan metal switch

#pragma kernel main

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition-config/Runtime/ShaderConfig.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.cs.hlsl"
#define NO_SHADERVARIABLESGLOBAL_HLSL
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/TilingAndBinningUtilities.hlsl"
#undef  NO_SHADERVARIABLESGLOBAL_HLSL
#define NUM_CLIP_PLANES (6) // Full frustum clipping
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/ClippingUtilities.hlsl"

/* ------------------------------ Inputs ------------------------------------ */

// 1x list for all entites (sorted by category, we concatenate lists of all views).
StructuredBuffer<FiniteLightBound> _EntityBoundsBuffer;

/* ------------------------------ Outputs ----------------------------------- */

// 1x list for all entites (sorted by category, we concatenate lists of all views).
RWStructuredBuffer<float4> _xyBoundsBuffer : register(u0); // {x_min, x_max, y_min, y_max}
RWStructuredBuffer<float2>  _wBoundsBuffer : register(u1); // {w_min, w_max}

/* ------------------------------ Utilities --------------------------------- */

// Given: 'C' is the center of the sphere in the view space, 'r' is its radius;
// 'projScale' and 'projOffset' are used to perform projection of the X (or Y) component of a vector.
float2 ComputeBoundsOfProjectedSphere(float3 C, float r, float projScale, float projOffset)
{
    float xMin, xMax;

    // See sec. 8.2.1 of https://foundationsofgameenginedev.com/#fged2 for an alternative derivation.
    // Goal: find the planes that pass through the origin O, bound the sphere, and form
    // an axis-aligned rectangle at the intersection with the projection plane.
    // Solution (for the X-coordinate):
    // The intersection of the bounding planes and the projection plane must be vertical lines,
    // which means that the bounding planes must be tangent to the Y-axis.
    // The bounding planes must be also tangent to the sphere.
    // Call the intersection points of the two vertical bounding planes and the bounding
    // sphere B and D. Assume that B is on the left of C; D is on the right of C.
    // Note that C may be behind the origin, so the same generally goes for B and D.
    // BC is normal w.r.t. the bounding plane, so it is normal w.r.t. the Y-axis; |BC| = r.
    // As a consequence, it lies in a plane parallel to the the O-X-Z plane.
    // Consider B'C', which is an orthogonal projection of BC onto the actual O-X-Z plane.
    // (Imagine sliding the sphere up or down between the bounding planes).
    // We then consider a triangle OB'C' that lies entirely in the O-X-Z plane.
    // The coordinates are: OB' = (b.x, 0, b.z), OC' = (c.x, 0, c.z).
    float3 B, D;
    // OBC is a right triangle. So is OB'C'.
    // |BC| = |B'C'| = r.
    // |OB'|^2 = |OC'|^2 - |B'C'|^2.
    float lenSqOC = dot(C.xz, C.xz);
    float lenSqOB = lenSqOC - r * r;
    // If |OB'| = 0 or |OC'| = 0, the bounding planes tangent to the sphere do not exist.
    if (lenSqOB > 0) // The sphere does not contain the origin
    {
        float lenOB = sqrt(lenSqOB);
        // |OB' x OC'| = |OB'| * |OC'| * Sin[a'].
        //  OB' . OC'  = |OB'| * |OC'| * Cos[a'].
        // We can determine Sin[a'] = |B'C'| / |OC'| = R / |OC'|.
        // Cos[a'] = Sqrt[1 - Sin[a']^2].
        // (OB' x OC') points along Y.
        // (OB' x OC').y = b.z * c.x - b.x * c.z.
        // Therefore,  b.z * c.x - b.x * c.z = |OB'| * |OC'| * Sin[a'].
        // OB' . OC' = b.x * c.x + b.z * c.z = |OB'| * |OC'| * Cos[a'].
        // Since we don't care about the scale, and |OB'| != 0 and |OC'| != 0,
        // we can equivalently solve
        // z * c.x - x * c.z = |OC'|^3 * Sin[a'].
        // x * c.x + z * c.z = |OC'|^3 * Cos[a'].
        // With 2 equations and 2 unknowns, we can easily solve this linear system.
        // The solutions is
        // x = -c.z * r + c.x * |OB'|.
        // z =  c.x * r + c.z * |OB'|.
        B.x = C.x * lenOB - (C.z * r);
        B.z = C.z * lenOB + (C.x * r);
        // (OD' x OC') points along Y.
        // (OD' x OC').y = d.z * c.x - d.x * c.z.
        // We must solve
        // z * c.x - x * c.z = -|OC'|^3 * Sin[a'].
        // x * c.x + z * c.z =  |OC'|^3 * Cos[a'].
        // The solution is
        // x =  c.z * r + c.x * |OB'|.
        // z = -c.x * r + c.z * |OB'|.
        D.x = C.x * lenOB + (C.z * r);
        D.z = C.z * lenOB - (C.x * r);
        // We can transform OB and OD as direction vectors.
        // Manually optimize the perspective projection (see OptimizeProjectionMatrix).
        float rapBx = (B.x * rcp(B.z)) * projScale + projOffset;
        float rapDx = (D.x * rcp(D.z)) * projScale + projOffset;
        // One problem with the above is that this direction may, for certain spheres,
        // point behind the origin (B.z <= 0 or D.z <= 0).
        // At this point we know that the sphere at least *partially* in front of the origin,
        // and that it is we are not inside the sphere, so there is at least one valid
        // plane (and one valid direction). We just need the second direction to go "in front"
        // of the first one to extend the bounding box.
        xMin = (B.z > 0) ? rapBx : -FLT_INF;
        xMax = (D.z > 0) ? rapDx :  FLT_INF;
    }
    else
    {
        // Conservative estimate (we do not cull the bounding sphere using the view frustum).
        xMin = -1;
        xMax =  1;
    }

    return float2(xMin, xMax);
}

/* ------------------------------ Implementation ---------------------------- */

// !!! IMPORTANT !!!
// The legacy code from Morten provides us special projection matrices (and their inverses).
// These matrices are different from the matrices the HDRP uses.
// There is no clip-space flip (effectively, forced UNITY_UV_STARTS_AT_TOP = 0).
// All coordinate systems are left-handed, Y-up, Z-forward.
// y  z
// | /
// 0 -- x

#ifdef SHADER_API_XBOXONE
// (Sep 16, 2020)
// The Xbox shader compiler expects the lane swizzle mask to be a compile-time constant.
// In our case, the mask is a compile-time constant, but it is defined inside a loop
// that is unrolled at the compile time, and the constants are generated during the
// constant propagation pass of the optimizer. This works fine on PlayStation, but does not work
// on Xbox. In order to avoid writing hideous code specifically for Xbox, we disable the support
// of wave intrinsics on Xbox until the Xbox compiler is fixed.
#undef PLATFORM_SUPPORTS_WAVE_INTRINSICS
#endif

#ifndef PLATFORM_SUPPORTS_WAVE_INTRINSICS
// 1 array * 16 elements * 4 bytes each = 64 bytes.
groupshared uint gs_CullClipFaceMasks[ENTITIES_PER_GROUP]; // 6 faces each (HLSL does not support small data types)
// 6 arrays * 16 elements * 4 bytes each = 384 bytes.
// These are actually floats reinterpreted as uints.
// The reason is because floating-point atomic operations are not supported.
groupshared uint gs_NdcAaBbMinPtX[ENTITIES_PER_GROUP];
groupshared uint gs_NdcAaBbMaxPtX[ENTITIES_PER_GROUP];
groupshared uint gs_NdcAaBbMinPtY[ENTITIES_PER_GROUP];
groupshared uint gs_NdcAaBbMaxPtY[ENTITIES_PER_GROUP];
// Skip Z, we do not need it.
groupshared uint gs_NdcAaBbMinPtW[ENTITIES_PER_GROUP]; // View-space Z coordinate
groupshared uint gs_NdcAaBbMaxPtW[ENTITIES_PER_GROUP]; // View-space Z coordinate
#endif // PLATFORM_SUPPORTS_WAVE_INTRINSICS

// *************************************************************************************************
// The goal of this program is to compute the AABB of a bounded entity in the NDC space ([0, 1] range).
// The entity is represented by a bounding sphere and a right bounding frustum with 6 faces and 8 vertices.
// The resulting bounding volume is defined by the the intersection of the sphere and the frustum.
//
// Since an entity's bounding volume may be partially off-screen, we must clip it before computing the AABB.
// Clipping the resulting AABB (rather than the bounding volume itself) may result in a loose AABB.
//
// To avoid having to deal with the "Moebius twist" property of the perspective transform,
// we perform clipping using the homogeneous (projective) post-perspective coordinates.
// This clipping method in described in Blinn's paper titled "Line Clipping".
//
// The algorithm processes an entity on 4 threads. While all 6 faces may require clipping in the
// worst case, clipping more than 4 faces is very uncommon (typically, we clip 0, 3 or 4).
// Some faces may require culling rather than clipping (the former is simpler).
//
// It's important to realize that face culling may end up culling 5 (or even all 6) faces.
// This means that the clipped volume may be reduced to a single polygon, or nothing at all.
// (Imagine a view volume completely or partially inside a bounding volume).
// Therefore, we must perform view-volume-corner-inside-bounding-volume tests.
//
// Notation:
// rbp - real (3D) coordinates before perspective
// hbp - hom. (4D) coordinates before perspective
// hap - hom. (4D) coordinates after  perspective
// rap - real (3D) coordinates after  perspective (after division by w)
// *************************************************************************************************

[numthreads(THREADS_PER_ENTITY, ENTITIES_PER_GROUP, 1)]
void main(uint3 threadID : SV_GroupThreadID, uint3 groupID : SV_GroupID, uint threadIdx : SV_GroupIndex)
{
    const uint t      = threadID.x;
    const uint entity = threadID.y;
    const uint g      = groupID.x;
    const uint eye    = groupID.z;

    const uint baseVertexOffset   = entity * NUM_VERTS;
    const uint globalEntityIndex  = IndexFromCoordinate(uint2(entity, g), ENTITIES_PER_GROUP);
    const uint clampedEntityIndex = min(globalEntityIndex, _BoundedEntityCount - 1);

    // Helper threads may perform the same computation on valid data,
    // but do not store the results of the computation to memory.
    const bool isHelperThread = globalEntityIndex != clampedEntityIndex;

    const uint             bufferIndex = ComputeEntityBoundsBufferIndex(clampedEntityIndex, eye);
    const FiniteLightBound cullData    = _EntityBoundsBuffer[bufferIndex];

    const float4x4 projMat    = g_mProjectionArr[eye];
    const float4x4 invProjMat = g_mInvProjectionArr[eye];

    // Bounding frustum.
    const float3 rbpC  = cullData.center.xyz;   // View-space
    const float3 rbpX  = cullData.boxAxisX.xyz; // Pre-scaled
    const float3 rbpY  = cullData.boxAxisY.xyz; // Pre-scaled
    const float3 rbpZ  = cullData.boxAxisZ.xyz; // Pre-scaled
    const float scale  = cullData.scaleXY;      // scale.x = scale.y
    // Bounding sphere.
    const float radius = cullData.radius;

    // This cube defines the view frustum.
    const float3 cubeMinCS = float3(-1, -1, 0);
    const float3 cubeMaxCS = float3( 1,  1, 1);

#ifndef PLATFORM_SUPPORTS_WAVE_INTRINSICS
    // (0) Initialize the TGSM.
    if (t == 0) // Avoid bank conflicts
    {
        gs_CullClipFaceMasks[entity] = 0; // Initially all faces are assumed to be inside
        gs_NdcAaBbMinPtX[entity]     = asuint(1.0f);
        gs_NdcAaBbMaxPtX[entity]     = asuint(0.0f);
        gs_NdcAaBbMinPtY[entity]     = asuint(1.0f);
        gs_NdcAaBbMaxPtY[entity]     = asuint(0.0f);
        // Skip Z, we do not need it.
        gs_NdcAaBbMinPtW[entity]     = asuint(FLT_INF);
        gs_NdcAaBbMaxPtW[entity]     = asuint(0.0f);
    }
#endif // PLATFORM_SUPPORTS_WAVE_INTRINSICS

    float4 ndcAaBbMinPt = float4(1, 1, 1, FLT_INF);
    float4 ndcAaBbMaxPt = 0;

    // We must determine whether we have to clip or cull any of the faces.
    // If all vertices of a face are inside with respect to all the culling planes,
    // we can trivially accept that face. If all vertices of a face are behind
    // any single plane, we can trivially reject (cull) that face.
    uint cullClipFaceMask = 0; // Initially inside

    uint i; // Avoid the multiply-declared variable warning

    // (1) Compute the vertices of the bounding frustum.
    for (i = 0; i < VERTS_PER_THREAD; i++)
    {
        uint v = t + i * THREADS_PER_ENTITY;

        // rbpVerts[0] = rbpC - rbpX * scale - rbpY * scale - rbpZ; (-s, -s, -1)
        // rbpVerts[1] = rbpC + rbpX * scale - rbpY * scale - rbpZ; (+s, -s, -1)
        // rbpVerts[2] = rbpC - rbpX * scale + rbpY * scale - rbpZ; (-s, +s, -1)
        // rbpVerts[3] = rbpC + rbpX * scale + rbpY * scale - rbpZ; (+s, +s, -1)
        // rbpVerts[4] = rbpC - rbpX         - rbpY         + rbpZ; (-1, -1, +1)
        // rbpVerts[5] = rbpC + rbpX         - rbpY         + rbpZ; (+1, -1, +1)
        // rbpVerts[6] = rbpC - rbpX         + rbpY         + rbpZ; (-1, +1, +1)
        // rbpVerts[7] = rbpC + rbpX         + rbpY         + rbpZ; (+1, +1, +1)

        float3 m = GenerateVertexOfStandardCube(v);
        m.xy *= ((v & 4) == 0) ? scale : 1; // X, Y in [-scale, scale]

        float3 rbpVertRVS = m.x * rbpX + m.y * rbpY + m.z * rbpZ;
        float3 rbpVertVS  = rbpC + rbpVertRVS;
        // Avoid generating (w = 0).
        rbpVertVS.z = (abs(rbpVertVS.z) > FLT_MIN) ? rbpVertVS.z : FLT_MIN;

        // For the orthographic projection, the resulting (w = 1).
        float4 hapVertCS = mul(projMat, float4(rbpVertVS, 1));

        const float3 hapAaBbMinPt = cubeMinCS * hapVertCS.w;
        const float3 hapAaBbMaxPt = cubeMaxCS * hapVertCS.w;

        // For each vertex, we must determine whether it is within the bounds.
        // For culling and clipping, we must know, per culling plane, whether the vertex
        // is in the positive or the negative half-space.
        uint behindMask = 0; // Initially in front

        // TODO: add epsilon for numerical robustness?
        for (uint j = 0; j < (NUM_CLIP_PLANES / 2); j++)
        {
            // Test: dot(frustumPlane, hapVertCS) < 0:
            // (x < -w), (x > w), (y < -w), (y > w), (z < 0), (z > w).
            behindMask |= ((hapVertCS[j] < hapAaBbMinPt[j]) ? 1 : 0) << (2 * j + 0);
            behindMask |= ((hapVertCS[j] > hapAaBbMaxPt[j]) ? 1 : 0) << (2 * j + 1);
        }

        if (behindMask == 0) // Inside?
        {
            float3 rapVertCS  = hapVertCS.xyz * rcp(hapVertCS.w);
            float3 rapVertNDC = float3(rapVertCS.xy * 0.5 + 0.5, rapVertCS.z);

            ndcAaBbMinPt = min(ndcAaBbMinPt, float4(rapVertNDC, rbpVertVS.z));
            ndcAaBbMaxPt = max(ndcAaBbMaxPt, float4(rapVertNDC, rbpVertVS.z));
        }
        else // Outside
        {
            // Mark all the faces of the bounding frustum associated with this vertex.
            cullClipFaceMask |= GetFaceMaskOfVertex(v);
        }

        gs_HapVertsX[baseVertexOffset + v]          = hapVertCS.x;
        gs_HapVertsY[baseVertexOffset + v]          = hapVertCS.y;
        gs_HapVertsZ[baseVertexOffset + v]          = hapVertCS.z;
        gs_HapVertsW[baseVertexOffset + v]          = hapVertCS.w;
        gs_BehindMasksOfVerts[baseVertexOffset + v] = behindMask;
    }

#ifdef PLATFORM_SUPPORTS_WAVE_INTRINSICS
    for (i = 0; i < FastLog2(THREADS_PER_ENTITY); i++)
    {
        uint andMask = PLATFORM_LANE_COUNT - 1; // All lanes
        uint orMask  = 0;                       // Plays no role
        uint xorMask = 1 << i;                  // Flip bits one by one starting from the LSB

        cullClipFaceMask |= LaneSwizzle(cullClipFaceMask, andMask, orMask, xorMask);
    }

    GroupMemoryBarrier(); // Wait for writes to gs_BehindMasksOfVerts, gs_HapVertsX
#else
    InterlockedOr(gs_CullClipFaceMasks[entity], cullClipFaceMask);

    GroupMemoryBarrier(); // Wait for writes to gs_CullClipFaceMasks, gs_BehindMasksOfVerts, gs_HapVertsX

    cullClipFaceMask = gs_CullClipFaceMasks[entity];
#endif // PLATFORM_SUPPORTS_WAVE_INTRINSICS

    // (2) Test the corners of the view volume.
    if (cullClipFaceMask != 0)
    {
        // The entity is partially outside the view volume.
        // Therefore, some of the corners of the view volume may be inside the entity's bounding frustum.
        // Since we cull faces that are outside the view volume, so we must make sure its corners are accounted for.
        // We can exploit the properties of the frustum by building an entity-space projection matrix.
        // P_v = T * (R * S) * P_l
        // P_l = (R * S)^{-1} * T^{-1} * P_v
        float4x4 invTranslateToEntitySpace      = Translation4x4(-rbpC);
        float4x4 invRotateAndScaleInEntitySpace = Homogenize3x3(Invert3x3(ScaledRotation3x3(rbpX, rbpY, rbpZ)));

        // This (orthographic) projection matrix maps a view-space point to a entity-space [-1, 1]^3 cube.
        float4x4 entitySpaceMatrix = mul(invRotateAndScaleInEntitySpace, invTranslateToEntitySpace);

        if (scale != 1) // Perspective entity space?
        {
            // Compute the parameters of the perspective projection.
            float s = scale;
            float n = 2 * (s * rcp(1 - s)); // Distance from the eye to the near plane
            float f = 2 + n;                // Distance from the eye to the far plane
            float g = f;                    // Distance from the eye to the projection plane
            float e = -1 - n;               // Signed distance from the origin to the eye

            float4x4 invTranslateEye = Translation4x4(float3(0, 0, -e));
            float4x4 perspProjMatrix = PerspectiveProjection4x4(1, g, n, f);

            entitySpaceMatrix = mul(mul(perspProjMatrix, invTranslateEye), entitySpaceMatrix);
        }

        for (i = 0; i < VERTS_PER_THREAD; i++)
        {
            uint v = t + i * THREADS_PER_ENTITY;

            float3 rapVertCS = GenerateVertexOfCustomCube(v, cubeMinCS, cubeMaxCS);
            float4 hbpVertVS = mul(invProjMat, float4(rapVertCS, 1)); // Clip to view space
            float4 hapVertLS = mul(entitySpaceMatrix, hbpVertVS);     // View to entity space

            // TODO: add epsilon for numerical robustness?
            bool inside = Max3(abs(hapVertLS.x), abs(hapVertLS.y), abs(hapVertLS.z)) < hapVertLS.w;

            if (inside)
            {
                float3 rapVertNDC = float3(rapVertCS.xy * 0.5 + 0.5, rapVertCS.z);
                float  rbpVertVSz = hbpVertVS.z * rcp(hbpVertVS.w);

                ndcAaBbMinPt = min(ndcAaBbMinPt, float4(rapVertNDC, rbpVertVSz));
                ndcAaBbMaxPt = max(ndcAaBbMaxPt, float4(rapVertNDC, rbpVertVSz));
            }
        }
    }

    // (3) Cull the faces.
    if (cullClipFaceMask != 0)
    {
        const uint cullFaceMask   = cullClipFaceMask;
        const uint numFacesToCull = countbits(cullFaceMask); // [0, 6]

        for (i = 0; i < FACES_PER_THREAD; i++)
        {
            uint n = t + i * THREADS_PER_ENTITY;

            if (n < numFacesToCull)
            {
                uint f = NthBitLow(cullFaceMask, n);

                if (TryCullFace(f, baseVertexOffset))
                {
                    cullClipFaceMask ^= 1 << f;
                }
            }
        }
    }

#ifdef PLATFORM_SUPPORTS_WAVE_INTRINSICS
    for (i = 0; i < FastLog2(THREADS_PER_ENTITY); i++)
    {
        uint andMask = PLATFORM_LANE_COUNT - 1; // All lanes
        uint orMask  = 0;                       // Plays no role
        uint xorMask = 1 << i;                  // Flip bits one by one starting from the LSB

        cullClipFaceMask &= LaneSwizzle(cullClipFaceMask, andMask, orMask, xorMask);
    }
#else
    InterlockedAnd(gs_CullClipFaceMasks[entity], cullClipFaceMask);

    GroupMemoryBarrier(); // Wait for writes to gs_CullClipFaceMasks

    cullClipFaceMask = gs_CullClipFaceMasks[entity];
#endif

    // (4) Clip the faces.
    if (cullClipFaceMask != 0)
    {
        const uint clipFaceMask   = cullClipFaceMask;
        const uint numFacesToClip = countbits(clipFaceMask); // [0, 6]

        for (i = 0; i < FACES_PER_THREAD; i++)
        {
            uint n = t + i * THREADS_PER_ENTITY;

            if (n < numFacesToClip)
            {
                uint f = NthBitLow(clipFaceMask, n);

                uint   srcBegin, srcSize;
                float4 vertRingBuffer[MAX_CLIP_VERTS];
                ClipFaceAgainstCube(f, cubeMinCS, cubeMaxCS, baseVertexOffset,
                                    srcBegin, srcSize, vertRingBuffer, threadIdx);
                UpdateAaBb(srcBegin, srcSize, vertRingBuffer, threadIdx, g_isOrthographic != 0, invProjMat,
                           ndcAaBbMinPt, ndcAaBbMaxPt);
            }
        }
    }

#ifdef PLATFORM_SUPPORTS_WAVE_INTRINSICS
    for (i = 0; i < FastLog2(THREADS_PER_ENTITY); i++)
    {
        uint andMask = PLATFORM_LANE_COUNT - 1; // All lanes
        uint orMask  = 0;                       // Plays no role
        uint xorMask = 1 << i;                  // Flip bits one by one starting from the LSB

        ndcAaBbMinPt.x = min(ndcAaBbMinPt.x, LaneSwizzle(ndcAaBbMinPt.x, andMask, orMask, xorMask));
        ndcAaBbMaxPt.x = max(ndcAaBbMaxPt.x, LaneSwizzle(ndcAaBbMaxPt.x, andMask, orMask, xorMask));
        ndcAaBbMinPt.y = min(ndcAaBbMinPt.y, LaneSwizzle(ndcAaBbMinPt.y, andMask, orMask, xorMask));
        ndcAaBbMaxPt.y = max(ndcAaBbMaxPt.y, LaneSwizzle(ndcAaBbMaxPt.y, andMask, orMask, xorMask));
        // Skip Z, we do not need it.
        ndcAaBbMinPt.w = min(ndcAaBbMinPt.w, LaneSwizzle(ndcAaBbMinPt.w, andMask, orMask, xorMask));
        ndcAaBbMaxPt.w = max(ndcAaBbMaxPt.w, LaneSwizzle(ndcAaBbMaxPt.w, andMask, orMask, xorMask));
    }
#else
    // Integer comparison works for floating-point numbers as long as the sign bit is 0.
    // We must take care of -0 ourselves. saturate() does not help.
    InterlockedMin(gs_NdcAaBbMinPtX[entity], asuint(CLEAR_SIGN_BIT(ndcAaBbMinPt.x)));
    InterlockedMax(gs_NdcAaBbMaxPtX[entity], asuint(CLEAR_SIGN_BIT(ndcAaBbMaxPt.x)));
    InterlockedMin(gs_NdcAaBbMinPtY[entity], asuint(CLEAR_SIGN_BIT(ndcAaBbMinPt.y)));
    InterlockedMax(gs_NdcAaBbMaxPtY[entity], asuint(CLEAR_SIGN_BIT(ndcAaBbMaxPt.y)));
    // Skip Z, we do not need it.
    InterlockedMin(gs_NdcAaBbMinPtW[entity], asuint(CLEAR_SIGN_BIT(ndcAaBbMinPt.w)));
    InterlockedMax(gs_NdcAaBbMaxPtW[entity], asuint(CLEAR_SIGN_BIT(ndcAaBbMaxPt.w)));

    GroupMemoryBarrier(); // Wait for writes to gs_NdcAaBbMinPtX

    ndcAaBbMinPt.x = asfloat(gs_NdcAaBbMinPtX[entity]);
    ndcAaBbMaxPt.x = asfloat(gs_NdcAaBbMaxPtX[entity]);
    ndcAaBbMinPt.y = asfloat(gs_NdcAaBbMinPtY[entity]);
    ndcAaBbMaxPt.y = asfloat(gs_NdcAaBbMaxPtY[entity]);
    // Skip Z, we do not need it.
    ndcAaBbMinPt.w = asfloat(gs_NdcAaBbMinPtW[entity]);
    ndcAaBbMaxPt.w = asfloat(gs_NdcAaBbMaxPtW[entity]);
#endif // PLATFORM_SUPPORTS_WAVE_INTRINSICS

    // (5) Compute the AABB of the bounding sphere.
    if (radius > 0)
    {
        // Occasionally, an intersection of AABBs of a bounding sphere and a bounding frustum
        // results in a tighter AABB when compared to using the AABB of the frustum alone.
        // That is the case (mostly) for sphere-capped spot lights with very wide angles.
        // Note that, unfortunately, it is not quite as tight as an AABB of a CSG intersection
        // of a sphere and frustum. Also note that the algorithm below doesn't clip the bounding
        // sphere against the view frustum before computing the bounding box, simply because it is
        // too hard/expensive. I will leave it as a TODO in case someone wants to tackle this problem.
        if ((rbpC.z + radius) > 0) // Is the sphere at least *partially* in front of the origin?
        {
            float2 rectMin, rectMax;

            // For the 'x' and 'y' components, the solution is given below.
            if (g_isOrthographic)
            {
                float4x4 orthoProj = OptimizeOrthographicMatrix(projMat);

                // Compute the center and the extents (half-diagonal) of the bounding box.
                float2 center  = mul(orthoProj, float4(rbpC.xyz,     1)).xy;
                float2 extents = mul(orthoProj, float4(radius.xx, 0, 0)).xy; // Axis-aligned ellipse

                rectMin = center - extents;
                rectMax = center + extents;
            }
            else // Perspective
            {
                float2 xBounds = ComputeBoundsOfProjectedSphere(rbpC.xxz, radius, projMat._11, projMat._13); // X-Z plane
                float2 yBounds = ComputeBoundsOfProjectedSphere(rbpC.yyz, radius, projMat._22, projMat._23); // Y-Z plane

                rectMin = float2(xBounds.r, yBounds.r);
                rectMax = float2(xBounds.g, yBounds.g);
            }

            // Transform to the NDC coordinates.
            rectMin = rectMin * 0.5 + 0.5;
            rectMax = rectMax * 0.5 + 0.5;

            // Note: separating the X- and Y-computations across 2 threads is not worth it.
            ndcAaBbMinPt.xy = max(ndcAaBbMinPt.xy, rectMin);
            ndcAaBbMaxPt.xy = min(ndcAaBbMaxPt.xy, rectMax);
            // Skip Z, we do not need it.
            ndcAaBbMinPt.w  = max(ndcAaBbMinPt.w, rbpC.z - radius);
            ndcAaBbMaxPt.w  = min(ndcAaBbMaxPt.w, rbpC.z + radius);
        }
    }

    if (!isHelperThread && (t == 0)) // Avoid bank conflicts
    {
        // TODO: double-check to make sure that off-screen entities get assigned invalid AABBs.
        _xyBoundsBuffer[bufferIndex] = float4(ndcAaBbMinPt.x, ndcAaBbMaxPt.x, ndcAaBbMinPt.y, ndcAaBbMaxPt.y);
        _wBoundsBuffer[bufferIndex]  = float2(ndcAaBbMinPt.w, ndcAaBbMaxPt.w);
    }
}
