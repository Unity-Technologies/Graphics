
#define SHADOW_MINIMAL
#define LIGHT_EVALUATION_NO_HEIGHT_FOG

#define DEBUGGING 0
#define SUPPORTS_AREA_LIGHTS 1

#pragma kernel GatherFirstBounceHit HIT
#pragma kernel GatherFirstBounceMiss MISS

#pragma multi_compile _ INDIRECT

StructuredBuffer<uint3> _Hits;
StructuredBuffer<uint3> _Misses;
RWBuffer<uint> _Counts; // First three hits, last three misses.

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ProbeVolume/Propagation/APVDynamicGICommon.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinGIUtilities.hlsl"
#include "Packages/com.unity.render-pipelines.core/Runtime/Lighting/ProbeVolume/ProbeVolume.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightEvaluation.hlsl"

//#pragma enable_d3d11_debug_symbols

#define GROUP_SIZE 64

// AXIS_COUNT uint3 per probe. Must then be accessed as probeIndex * AXIS_COUNT + [0...AXIS_COUNT-1]
StructuredBuffer<uint3>  _PackedProbeExtraData;
// Can be made relative to cell origin and probe distance and stored in a more compact fashion.
StructuredBuffer<float3> _ProbeWorldLocations;

RWStructuredBuffer<float3> _IrradianceCache;
StructuredBuffer<float3> _PrevIrradianceCache;

TEXTURE3D(_PrevAPVResL0_L1Rx);
TEXTURE3D(_PrevAPVResL1G_L1Ry);
TEXTURE3D(_PrevAPVResL1B_L1Rz);

#if OUTPUT_TYPE == SHL2
TEXTURE3D(_PrevAPVResL2_0);
TEXTURE3D(_PrevAPVResL2_1);
TEXTURE3D(_PrevAPVResL2_2);
TEXTURE3D(_PrevAPVResL2_3);
#endif

float4 _DynamicGIParams2;
#define _PrimaryDecay  _DynamicGIParams2.x
#define _LeakMultiplier  _DynamicGIParams2.y
#define _ArtificialScale _DynamicGIParams2.z
#define _DeringingFactor _DynamicGIParams2.w

float4 _DynamicGIParams3;
#define _HitCount  _DynamicGIParams3.x
#define _MissCount _DynamicGIParams3.y
#define _DistanceBetweenProbes _DynamicGIParams3.z
#define _PropagationDecay _DynamicGIParams3.w

float4 _DynamicGIParams4;
#define _UpdateDistBehindCamera  _DynamicGIParams4.x
#define _UpdateDistInFrontOfCamera  _DynamicGIParams4.y


float3 GetPreviousIrradianceCacheValue(uint probeIndex, int axis)
{
    uint index = probeIndex * AXIS_COUNT + axis;
    return _PrevIrradianceCache[index];
}

// -------------------------------------------------------------
// Lighting Utils
// -------------------------------------------------------------

LightLoopContext GetEmptyLightLoopContext()
{
    LightLoopContext context;
    context.shadowContext = InitShadowContext();
    context.shadowValue = 1.0;
    context.sampleReflection = false;
    context.contactShadow = 0;
    context.contactShadowFade = 0;

    return context;
}


// Ideally we want the list pre-computed. This is easier for prototyping, but inefficient with a lot of lights.
// The procomputation of the list can be really trivial and done either CPU or GPU side
bool GetNextValidPunctualLightData(inout int currentIndex, out LightData lightData)
{
   //currentIndex = ScalarizeElementIndex(currentIndex, false);
    for (; currentIndex < (int)_PunctualLightCount; ++currentIndex)
    {
        lightData = _LightDatas[currentIndex];
       // if (lightData.affectDynamicGI > 0)
        {
            currentIndex++;
            return true;
        }
    }

    return false;
}

// Ideally we want the list pre-computed. This is easier for prototyping, but inefficient with a lot of lights.
// The procomputation of the list can be really trivial and done either CPU or GPU side
bool GetNextValidAreaLightData(inout int currentIndex, out LightData lightData)
{
    const int lastAreaLightIndex = _PunctualLightCount + _AreaLightCount;
    //currentIndex = ScalarizeElementIndex(currentIndex, false);
    for (; currentIndex < (int)lastAreaLightIndex; ++currentIndex)
    {
        lightData = _LightDatas[currentIndex];
        if (lightData.affectDynamicGI > 0)
        {
            currentIndex++;
            return true;
        }
    }

    return false;
}

float3 GetShadowPunctual(LightData light, float3 positionRWS, float4 distances, float3 L, LightLoopContext context)
{
    PositionInputs posInput;
    posInput.positionWS = positionRWS;

    BuiltinData unused;

    SHADOW_TYPE shadow = EvaluateShadow_Punctual(context, posInput, light, unused, 0, L, distances);
    return ComputeShadowColor(shadow, light.shadowTint, light.penumbraTint);

}

float3 GetShadowDirectional(DirectionalLightData light, float3 positionRWS, LightLoopContext context)
{
    PositionInputs posInput;
    posInput.positionWS = positionRWS;

    light.contactShadowMask = 0;
    float3 L = -light.forward;
    context.shadowValue = GetDirectionalShadowAttenuation(context.shadowContext,
        0, posInput.positionWS, 0,
        light.shadowIndex, L);

    BuiltinData unused;

    SHADOW_TYPE shadow = EvaluateShadow_Directional(context, posInput, light, unused, 0);
    return ComputeShadowColor(shadow, light.shadowTint, light.penumbraTint);

}

float3 EvaluatePunctualLight(LightData light, float3 positionWS, out float3 L)
{
    float4 distances; // {d, d^2, 1/d, d_proj}
    float3 positionRWS = GetCameraRelativePositionWS(positionWS);

    GetPunctualLightVectors(positionRWS, light, L, distances);
    L = normalize(L);

    LightLoopContext context = GetEmptyLightLoopContext();

    PositionInputs posInput;
    posInput.positionWS = positionRWS;

    float4 lightColor = EvaluateLight_Punctual(context, posInput, light, L, distances);
    lightColor.rgb *= lightColor.a;

    float3 shadows = GetShadowPunctual(light, positionRWS, distances, L, context);

    return shadows * lightColor.rgb;
}

float3 EvaluateAreaLight(LightData light, float3 positionWS, float3 N)
{
    LightLoopContext context = GetEmptyLightLoopContext();

    PositionInputs posInput;
    float3 positionRWS = GetCameraRelativePositionWS(positionWS);
    posInput.positionWS = positionRWS;

    BuiltinData unused;
    return EvaluateLight_RectArea_LambertDiffuseOnly(context, N, posInput, light, unused);
}

float3 EvaluateDirectionalLight(DirectionalLightData light, float3 positionWS, out float3 L)
{
    float3 positionRWS = GetCameraRelativePositionWS(positionWS);

    LightLoopContext context = GetEmptyLightLoopContext();

    PositionInputs posInput;
    posInput.positionWS = positionRWS;

    float4 lightColor = EvaluateLight_Directional(context, posInput, light);
    lightColor.rgb *= lightColor.a;

    float3 shadows = GetShadowDirectional(light, positionRWS, context);

    L = -light.forward;
    // TODO: WHY? But it matches more...
    float scale =  2.0f / PI;
    return shadows * lightColor.rgb * scale;
}

float3 GetLightingForAxisPunctual(LightData light, uint probeIndex, float3 probeWorldPosition, HitData hit)
{
    float3 outputLighting = 0;

    float3 L;
    outputLighting = EvaluatePunctualLight(light, hit.position, L);
    outputLighting *= hit.albedo;
    float NdotL = saturate(dot(hit.normal, L));

    float scalarMultiplier = NdotL * INV_PI * _ArtificialScale;
    outputLighting *= scalarMultiplier;

    return outputLighting;
}

float3 GetLightingForAxisDirectional(DirectionalLightData light, uint probeIndex, float3 probeWorldPosition, HitData hit)
{
    float3 outputLighting = 0;

    float3 L;
    outputLighting = EvaluateDirectionalLight(light, hit.position, L);
    outputLighting *= hit.albedo;
    float NdotL = saturate(dot(hit.normal, L));

    float scalarMultiplier = NdotL * INV_PI * _ArtificialScale;
    outputLighting *= scalarMultiplier;

    return outputLighting;
}

float3 GetLightingForAxisArea(LightData light, uint probeIndex, float3 probeWorldPosition, HitData hit)
{
    float3 outputLighting = 0;

    outputLighting = EvaluateAreaLight(light, hit.position, hit.normal);
    outputLighting *= hit.albedo;

    float scalarMultiplier = _ArtificialScale;
    outputLighting *= scalarMultiplier;

    return outputLighting;
}


// -------------------------------------------------------------
// Actual Light Loop
// -------------------------------------------------------------

// Returns true if light has been computed for this
bool AccumulateLighting(float3 probeWorldPosition, uint probeIndex, uint2 extraData, float4 axisDirection, inout float4 lighting)
{
    int lightIndex = 0;
    LightData light;
    lighting = 0;

    float scale = 0.25;
    float primaryDecay = _PrimaryDecay;

    HitData hit = UnpackInfoAlongAxis(extraData, probeWorldPosition, axisDirection.xyz);

    {
        // Punctual
        while (GetNextValidPunctualLightData(lightIndex, light))
        {
            // TODO: -> If needed, reintroduce here the push off of the light position if it matches probeWorldPosition too much.
            lighting.xyz += GetLightingForAxisPunctual(light, probeIndex, probeWorldPosition, hit) * scale;
        }

#if SUPPORTS_AREA_LIGHTS
        // Area light
        // Fast forward to start of area lights.
        lightIndex = _PunctualLightCount;
        while (GetNextValidAreaLightData(lightIndex, light))
        {
            lighting.xyz += GetLightingForAxisArea(light, probeIndex, probeWorldPosition, hit) * scale;
        }
#endif

        // Directional
        for (uint dirLightIdx = 0; dirLightIdx < _DirectionalLightCount; ++dirLightIdx)
        {
            DirectionalLightData dirData = _DirectionalLightDatas[dirLightIdx];
            // Only support the shadow casting one otherwise result is completely off.
            if (dirData.affectsDynamicGI > 0.0f && _DirectionalShadowIndex == (int)dirLightIdx)
            {
                lighting.xyz += GetLightingForAxisDirectional(dirData, probeIndex, probeWorldPosition, hit) * scale;
            }
        }

		lighting.w += primaryDecay;

        return true;
    }

    return false;
}


// -------------------------------------------------------------
// Gather previous result.
// -------------------------------------------------------------

OutputRepresentation SamplePreviousAPV(in float3 posWS, in float3 normalWS)
{
    OutputRepresentation output;
    ZERO_INITIALIZE(OutputRepresentation, output);

#if OUTPUT_IS_SH
    float3 pool_uvw;
    APVResources apvRes = FillAPVResources();
    if (TryToGetPoolUVW(apvRes, posWS, 0, 0,  pool_uvw))
    {
        float4 L0_L1Rx = SAMPLE_TEXTURE3D_LOD(_PrevAPVResL0_L1Rx, s_linear_clamp_sampler, pool_uvw, 0).rgba;
        float4 L1G_L1Ry = SAMPLE_TEXTURE3D_LOD(_PrevAPVResL1G_L1Ry, s_linear_clamp_sampler, pool_uvw, 0).rgba;
        float4 L1B_L1Rz = SAMPLE_TEXTURE3D_LOD(_PrevAPVResL1B_L1Rz, s_linear_clamp_sampler, pool_uvw, 0).rgba;

#if OUTPUT_TYPE == SHL2
        float4 L2_R = SAMPLE_TEXTURE3D_LOD(_PrevAPVResL2_0, s_linear_clamp_sampler, pool_uvw, 0).rgba;
        float4 L2_G = SAMPLE_TEXTURE3D_LOD(_PrevAPVResL2_1, s_linear_clamp_sampler, pool_uvw, 0).rgba;
        float4 L2_B = SAMPLE_TEXTURE3D_LOD(_PrevAPVResL2_2, s_linear_clamp_sampler, pool_uvw, 0).rgba;
        float4 L2_C = SAMPLE_TEXTURE3D_LOD(_PrevAPVResL2_3, s_linear_clamp_sampler, pool_uvw, 0).rgba;
#endif

        SamplesToRepresentation(output, L0_L1Rx, L1G_L1Ry, L1B_L1Rz,
#if OUTPUT_TYPE == SHL2
            L2_R, L2_G, L2_B, L2_C,
#endif
            true);
    }
#endif

    return output;
}

void AccumulateSecondBounce(float3 centralProbeLocation, int probeIndex, float4 axisDirection, inout float4 lighting)
{
    float3 direction = axisDirection.xyz;

    OutputRepresentation value;
    ZERO_INITIALIZE(OutputRepresentation, value);

    float3 irradiance = 0;
    // sample APV around neighbours.
    float3 dist = direction * _DistanceBetweenProbes * axisDirection.w;
    float3 neighbourPos = centralProbeLocation + dist;

    value = SamplePreviousAPV(neighbourPos, direction);
    irradiance = value.Evaluate(direction);

    float3 neighbContribution = irradiance * INV_PI;
    lighting.xyz += any(neighbContribution < 0) ? 0 : neighbContribution;

    lighting.w += _PropagationDecay;
}

// -------------------------------------------------------------
// Actual Light Loop
// -------------------------------------------------------------

#ifdef HIT
[numthreads(GROUP_SIZE, 1, 1)]
void GatherFirstBounceHit(uint3 id : SV_DispatchThreadID)
#else
[numthreads(GROUP_SIZE, 1, 1)]
void GatherFirstBounceMiss(uint3 id : SV_DispatchThreadID)
#endif
{
    uint elementIndex = id.x;

#ifdef INDIRECT

	int count =
#ifdef HIT
		_Counts[0];
#else
		_Counts[1];
#endif

	if (elementIndex < count)
	{
#ifdef HIT
		uint3 data = _Hits[elementIndex];
#else
		uint3 data = _Misses[elementIndex];
#endif 

#else 

#ifdef HIT
    if (elementIndex < _HitCount)
    {
        uint dataIndex = elementIndex;
#else // MISS
    if (elementIndex < _MissCount)
    {
        uint dataIndex = elementIndex + _HitCount;
#endif

		uint3 data = _PackedProbeExtraData[dataIndex];
#endif

        uint probeIndex, axisIndex;
        float probeValidity;
        UnpackIndicesAndValidity(data.z, probeIndex, axisIndex, probeValidity);

        float3 probeWorldPosition = _ProbeWorldLocations[probeIndex];

        // Early out at far distances
        // NOTE: Proper culling outside of this would be significantly faster, but the culling might be too expensive to perform each frame.
		// TODO: EZ WITH BURST.
        float3 V = (probeWorldPosition - _WorldSpaceCameraPos.xyz);
        float distAlongV = dot(GetViewForwardDir(), V);
        if (!(distAlongV < _UpdateDistInFrontOfCamera && distAlongV > -_UpdateDistBehindCamera)) return;

        float4 axisDirection = UnpackAxis(data.y);
		axisDirection = _RayAxis[axisIndex];

        float4 lightingAndWeight = 0;
        float3 prevValue = GetPreviousIrradianceCacheValue(probeIndex, axisIndex);
        lightingAndWeight = float4(prevValue, _PrimaryDecay);

#ifdef HIT
        AccumulateLighting(probeWorldPosition, probeIndex, data.xy, axisDirection, lightingAndWeight);
#else
        AccumulateSecondBounce(probeWorldPosition, probeIndex, axisDirection, lightingAndWeight);
#endif

        float invalidScale = (1.0f - lerp(0.0f, _LeakMultiplier, probeValidity));
        lightingAndWeight.xyz *= invalidScale;


        lightingAndWeight.xyz /= lightingAndWeight.w;

        _IrradianceCache[probeIndex * AXIS_COUNT + axisIndex] = lightingAndWeight.xyz;
    }
}
