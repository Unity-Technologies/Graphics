#include "Packages/com.unity.render-pipelines.high-definition-config/Runtime/ShaderConfig.cs.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/EntityLighting.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonLighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ProbeVolume/ProbeVolumeRotate.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ProbeVolume/DynamicGI/ProbePropagationGlobals.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ProbeVolume/DynamicGI/ProbeVolumeSphericalHarmonicsLighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ProbeVolume/DynamicGI/ProbePropagationBasis.hlsl"

#pragma kernel CombinePropagationAxis

#pragma multi_compile BASIS_SPHERICAL_GAUSSIAN BASIS_SPHERICAL_GAUSSIAN_WINDOWED BASIS_AMBIENT_DICE_SHARP BASIS_AMBIENT_DICE_SOFTER BASIS_AMBIENT_DICE_SUPER_SOFT BASIS_AMBIENT_DICE_ULTRA_SOFT
#pragma multi_compile BASIS_PROPAGATION_OVERRIDE_NONE BASIS_PROPAGATION_OVERRIDE_SPHERICAL_GAUSSIAN BASIS_PROPAGATION_OVERRIDE_AMBIENT_DICE_WRAPPED_SOFTER BASIS_PROPAGATION_OVERRIDE_AMBIENT_DICE_WRAPPED_SUPER_SOFT BASIS_PROPAGATION_OVERRIDE_AMBIENT_DICE_WRAPPED_ULTRA_SOFT

#define GROUP_SIZE 64
//#pragma enable_d3d11_debug_symbols


StructuredBuffer<float> _ProbeVolumeAtlasReadSHL01Buffer;
StructuredBuffer<float> _ProbeVolumeAtlasReadSHL2Buffer;
StructuredBuffer<float> _ProbeVolumeAtlasReadValidityBuffer;
RWTexture3D<float4> _ProbeVolumeAtlasWriteTextureSH;

uint _ProbeVolumeAtlasReadBufferCount;
float3 _ProbeVolumeResolution;
float3 _ProbeVolumeAtlasBias;
float4 _ProbeVolumeAtlasResolutionAndSliceCount;
float3 _ProbeVolumeAtlasSHRotateRight;
float3 _ProbeVolumeAtlasSHRotateUp;
float3 _ProbeVolumeAtlasSHRotateForward;

float3 _ProbeVolumeDGIBoundsRight;
float3 _ProbeVolumeDGIBoundsUp;

StructuredBuffer<float3> _RadianceCacheAxis;
int _RadianceCacheAxisCount;
float _BakedLightingContribution;
float _DynamicPropagationContribution;
float4 _RayAxis[NEIGHBOR_AXIS_COUNT];

float _Sharpness;


uint3 ComputeWriteIndexFromReadIndex(uint readIndex, float3 resolution)
{
    // _ProbeVolumeAtlasReadBuffer[z * resolutionY * resolutionX + y * resolutionX + x]
    // TODO: Could implement as floating point operations, which is likely faster.
    // Would need to verify precision.
    uint x = readIndex % (uint)resolution.x;
    uint y = (readIndex / (uint)resolution.x) % (uint)resolution.y;
    uint z = readIndex / ((uint)resolution.y * (uint)resolution.x);

    uint3 writeIndex = uint3(x, y, z);
    writeIndex += (uint3)floor(_ProbeVolumeAtlasBias * _ProbeVolumeAtlasResolutionAndSliceCount.xyz);

    return writeIndex;
}

float ReadValidity(uint readIndex)
{
    const float occlusion = _ProbeVolumeAtlasReadValidityBuffer[readIndex];
    return pow(1.0 - occlusion, 8.0);
}

SHOutgoingRadiosityWithProjectedConstantsPacked ReadBakedSH(uint readIndex)
{
    SHOutgoingRadiosityWithProjectedConstantsPacked outgoingRadiosity;

    const uint SH_STRIDE_L01 = 4 * 3;
    const uint SH_STRIDE_L2 = (9 * 3) - SH_STRIDE_L01;

    outgoingRadiosity.data[0] = float4(
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 0], // shAr.w
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 1], // shAg.w
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 2], // shAb.w
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 3]  // shAr.x
    );
    outgoingRadiosity.data[1] = float4(
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 4], // shAr.y
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 5], // shAr.z
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 6], // shAg.x
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 7]  // shAg.y
    );
    outgoingRadiosity.data[2] = float4(
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 8], // shAg.z
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 9], // shAb.x
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 10], // shAb.y
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 11]  // shAb.z
    );
    outgoingRadiosity.data[3] = float4(
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 0], // shBr.x
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 1], // shBr.y
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 2], // shBr.z
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 3]  // shBr.w
    );
    outgoingRadiosity.data[4] = float4(
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 4], // shBg.x
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 5], // shBg.y
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 6], // shBg.z
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 7]  // shBg.w
    );
    outgoingRadiosity.data[5] = float4(
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 8], // shBb.x
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 9], // shBb.y
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 10], // shBb.z
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 11]  // shBb.w
    );
    outgoingRadiosity.data[6] = float4(
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 12], // shCr.x
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 13], // shCr.y
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 14], // shCr.z
        0.0
    );

    return outgoingRadiosity;
}

void WriteFinalSHOutgoingRadiosityWithProjectedConstantsPacked(uint3 writeIndex, SHOutgoingRadiosityWithProjectedConstantsPacked outgoingRadiosityProjectedConstantsPacked, float validity)
{
    _ProbeVolumeAtlasWriteTextureSH[uint3(writeIndex.x, writeIndex.y, writeIndex.z + _ProbeVolumeAtlasResolutionAndSliceCount.z * 0)] = outgoingRadiosityProjectedConstantsPacked.data[0];
    _ProbeVolumeAtlasWriteTextureSH[uint3(writeIndex.x, writeIndex.y, writeIndex.z + _ProbeVolumeAtlasResolutionAndSliceCount.z * 1)] = outgoingRadiosityProjectedConstantsPacked.data[1];
    _ProbeVolumeAtlasWriteTextureSH[uint3(writeIndex.x, writeIndex.y, writeIndex.z + _ProbeVolumeAtlasResolutionAndSliceCount.z * 2)] = outgoingRadiosityProjectedConstantsPacked.data[2];
    _ProbeVolumeAtlasWriteTextureSH[uint3(writeIndex.x, writeIndex.y, writeIndex.z + _ProbeVolumeAtlasResolutionAndSliceCount.z * 3)] = outgoingRadiosityProjectedConstantsPacked.data[3];
    _ProbeVolumeAtlasWriteTextureSH[uint3(writeIndex.x, writeIndex.y, writeIndex.z + _ProbeVolumeAtlasResolutionAndSliceCount.z * 4)] = outgoingRadiosityProjectedConstantsPacked.data[4];
    _ProbeVolumeAtlasWriteTextureSH[uint3(writeIndex.x, writeIndex.y, writeIndex.z + _ProbeVolumeAtlasResolutionAndSliceCount.z * 5)] = outgoingRadiosityProjectedConstantsPacked.data[5];
    _ProbeVolumeAtlasWriteTextureSH[uint3(writeIndex.x, writeIndex.y, writeIndex.z + _ProbeVolumeAtlasResolutionAndSliceCount.z * 6)] = float4(outgoingRadiosityProjectedConstantsPacked.data[6].xyz, validity);
}

SHIncomingIrradiance SHIncomingIrradianceComputeFromBasisAxisHit(BasisAxisHit basisAxisHit, float3 radiance)
{
    ZHWindow zhWindow = ComputeZHWindowFromBasisAxisHit(basisAxisHit);
    SHWindow shWindow = SHWindowComputeFromZHWindow(zhWindow, basisAxisHit.mean);
    SHIncomingIrradiance irradiance = SHIncomingIrradianceComputeFromSHWindowAndRadiance(shWindow, radiance);

    return irradiance;
}

SHIncomingIrradiance ProjectPropagationAxisFromFit(uint probeIndex)
{
    SHIncomingIrradiance incomingIrradiance;
    ZERO_INITIALIZE(SHIncomingIrradiance, incomingIrradiance);

    uint localIndex = probeIndex;
    for (int axis = 0; axis < NEIGHBOR_AXIS_COUNT; ++axis)
    {
        float3 radiance = _RadianceCacheAxis[localIndex].xyz;
        float3 directionOS = _RayAxis[axis].xyz;
        const float3x3 probeVolumeLtw = float3x3(_ProbeVolumeDGIBoundsRight, _ProbeVolumeDGIBoundsUp, cross(_ProbeVolumeDGIBoundsRight, _ProbeVolumeDGIBoundsUp));
        float3 directionWS = mul(directionOS, probeVolumeLtw);

        BasisAxisHit basisAxisHit = ComputeBasisAxisHit(directionOS, _Sharpness);
        basisAxisHit.mean = directionWS; // Rotate the basis to world space after constructing it (because the construction can be dependant on the object space direction (i.e: diagonals with less energy)).

        SHIncomingIrradiance incomingIrradianceCurrentLobe = SHIncomingIrradianceComputeFromBasisAxisHit(basisAxisHit, radiance);

        SHIncomingIrradianceAccumulateFromSHIncomingIrradiance(incomingIrradiance, incomingIrradianceCurrentLobe);

        localIndex += _ProbeVolumeAtlasReadBufferCount;
    }

    return incomingIrradiance;
}

SHIncomingIrradiance ProjectPropagationAxis(uint probeIndex)
{
    return ProjectPropagationAxisFromFit(probeIndex);
}


[numthreads(GROUP_SIZE, 1, 1)]
void CombinePropagationAxis(uint3 id : SV_DispatchThreadID)
{
    const uint readIndex = id.x;
    if (readIndex < _ProbeVolumeAtlasReadBufferCount)
    {
        uint3 writeIndex = ComputeWriteIndexFromReadIndex(readIndex, _ProbeVolumeResolution);
        const float validity = ReadValidity(readIndex);

        SHOutgoingRadiosityWithProjectedConstantsPacked bakedOutgoingRadiosityProjectedConstantsPacked = ReadBakedSH(readIndex);
        SHIncomingIrradiance dynamicIncomingIrradiance = ProjectPropagationAxis(readIndex);

        SHOutgoingRadiosity dynamicOutgoingRadiosity = SHOutgoingRadiosityComputeFromIncomingIrradiance(dynamicIncomingIrradiance);
        SHOutgoingRadiosityWithProjectedConstants bakedOutgoingRadiosityProjectedConstants = SHOutgoingRadiosityWithProjectedConstantsCompute(bakedOutgoingRadiosityProjectedConstantsPacked);
        SHOutgoingRadiosity bakedOutgoingRadiosity = SHOutgoingRadiosityCompute(bakedOutgoingRadiosityProjectedConstants);

        const float3x3 probeVolumeAtlasSHRotate = float3x3(_ProbeVolumeAtlasSHRotateRight, _ProbeVolumeAtlasSHRotateUp, _ProbeVolumeAtlasSHRotateForward);
        SHOutgoingRadiosityRotate(probeVolumeAtlasSHRotate, bakedOutgoingRadiosity); // rotate baked SH Data into absolute world space before it is combined with dynamic SH data in absolute world space
        SHOutgoingRadiosityBlend(bakedOutgoingRadiosity, _BakedLightingContribution, dynamicOutgoingRadiosity, _DynamicPropagationContribution);

        #if DERING_LUMINANCE_ONLY
            //SHOutgoingRadiosityDeringLuminance(bakedOutgoingRadiosity);
        #else
            //SHOutgoingRadiosityDering(bakedOutgoingRadiosity);
        #endif

        bakedOutgoingRadiosityProjectedConstants = SHOutgoingRadiosityWithProjectedConstantsCompute(bakedOutgoingRadiosity);
        bakedOutgoingRadiosityProjectedConstantsPacked = SHOutgoingRadiosityWithProjectedConstantsPackedCompute(bakedOutgoingRadiosityProjectedConstants);
        WriteFinalSHOutgoingRadiosityWithProjectedConstantsPacked(writeIndex, bakedOutgoingRadiosityProjectedConstantsPacked, validity);
    }
}
