#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ScreenSpaceLighting/GTAOCommon.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"

#pragma kernel GTAODenoise_Spatial_To_Temporal          SPATIAL_DENOISE_KERNEL_NAME=GTAODenoise_Spatial_To_Temporal TO_TEMPORAL SPATIAL
#pragma kernel GTAODenoise_Spatial                      SPATIAL_DENOISE_KERNEL_NAME=GTAODenoise_Spatial SPATIAL
#pragma kernel GTAODenoise_Temporal                     TEMPORAL_DENOISE_KERNEL_NAME=GTAODenoise_Temporal         TEMPORAL  HALF_RES
#pragma kernel GTAODenoise_Temporal_FullRes             TEMPORAL_DENOISE_KERNEL_NAME=GTAODenoise_Temporal_FullRes TEMPORAL  FULL_RES

#pragma kernel GTAODenoise_CopyHistory HISTORY_COPY

#ifdef SPATIAL

TEXTURE2D_X(_AOPackedData);

#ifdef TO_TEMPORAL
RW_TEXTURE2D_X(float, _AOPackedBlurred);
#else
RW_TEXTURE2D_X(float, _OcclusionTexture);
#endif

#define DEBUG_VISUALIZE_BILATERAL_WEIGHTS 0

#define DEPTH_SCALE 1
#define BILATERAL_EPSILON 0.01

// TODO: This pass really could really use some quality improvement.

float BilateralWeight(float sampleDepth, float linearCentralDepth)
{
    float linearSample = LinearEyeDepth(sampleDepth, _ZBufferParams);
    float delta = abs(linearSample - linearCentralDepth);
    float w = saturate(1.0f - (DEPTH_SCALE * delta + BILATERAL_EPSILON));

    return w;
}

float Blur(float2 centralPos, out float centralDepth, out float centralAO)
{
    float4 UnpackedAOs, UnpackedDepths;

    float2 UV = ClampAndScaleUVForBilinear((centralPos + float2(0.0, 0.0)) * _AOBufferSize.zw, _AOBufferSize.zw);
    GatherAOData(_AOPackedData, UV, UnpackedAOs, UnpackedDepths);

    centralDepth = UnpackedDepths.y;
    float linearCentralDepth = LinearEyeDepth(centralDepth, _ZBufferParams);
    centralAO = UnpackedAOs.y;
    float total = UnpackedAOs.y;
    float totalWeight = 1;

    // This manual unrolling is horrible looking, but I found it hard to please the PS4 compiler otherwise. TODO: Make this nicer.

    // First set of gathered data.
    float weight = BilateralWeight(UnpackedDepths.x, linearCentralDepth);
    total += weight * UnpackedAOs.x;
    totalWeight += weight;

    weight = BilateralWeight(UnpackedDepths.z, linearCentralDepth);
    total += weight * UnpackedAOs.z;
    totalWeight += weight;

    weight = BilateralWeight(UnpackedDepths.w, linearCentralDepth);
    total += weight * UnpackedAOs.w;
    totalWeight += weight;

    // Second set of gathered data.
    UV = ClampAndScaleUVForBilinear((centralPos + float2(2.0, 0.0)) * _AOBufferSize.zw, _AOBufferSize.zw);
    GatherAOData(_AOPackedData, UV, UnpackedAOs, UnpackedDepths);

    weight = BilateralWeight(UnpackedDepths.x, linearCentralDepth);
    total += weight * UnpackedAOs.x;
    totalWeight += weight;

    weight = BilateralWeight(UnpackedDepths.y, linearCentralDepth);
    total += weight * UnpackedAOs.y;
    totalWeight += weight;

    weight = BilateralWeight(UnpackedDepths.z, linearCentralDepth);
    total += weight * UnpackedAOs.z;
    totalWeight += weight;

    weight = BilateralWeight(UnpackedDepths.w, linearCentralDepth);
    total += weight * UnpackedAOs.w;
    totalWeight += weight;


    // Third set of gathered data.
    UV = ClampAndScaleUVForBilinear((centralPos + float2(0.0, 2.0)) * _AOBufferSize.zw, _AOBufferSize.zw);
    GatherAOData(_AOPackedData, UV, UnpackedAOs, UnpackedDepths);

    weight = BilateralWeight(UnpackedDepths.x, linearCentralDepth);
    total += weight * UnpackedAOs.x;
    totalWeight += weight;

    weight = BilateralWeight(UnpackedDepths.y, linearCentralDepth);
    total += weight * UnpackedAOs.y;
    totalWeight += weight;

    weight = BilateralWeight(UnpackedDepths.z, linearCentralDepth);
    total += weight * UnpackedAOs.z;
    totalWeight += weight;

    weight = BilateralWeight(UnpackedDepths.w, linearCentralDepth);
    total += weight * UnpackedAOs.w;
    totalWeight += weight;

    // Fourth set of gathered data.
    UV = ClampAndScaleUVForBilinear((centralPos + float2(2.0, 2.0)) * _AOBufferSize.zw, _AOBufferSize.zw);
    GatherAOData(_AOPackedData, UV, UnpackedAOs, UnpackedDepths);

    weight = BilateralWeight(UnpackedDepths.x, linearCentralDepth);
    total += weight * UnpackedAOs.x;
    totalWeight += weight;

    weight = BilateralWeight(UnpackedDepths.y, linearCentralDepth);
    total += weight * UnpackedAOs.y;
    totalWeight += weight;

    weight = BilateralWeight(UnpackedDepths.z, linearCentralDepth);
    total += weight * UnpackedAOs.z;
    totalWeight += weight;

    weight = BilateralWeight(UnpackedDepths.w, linearCentralDepth);
    total += weight * UnpackedAOs.w;
    totalWeight += weight;


    total /= totalWeight;

#if DEBUG_VISUALIZE_BILATERAL_WEIGHTS
    return totalWeight / 16.0f;
#endif
    return total;
}

[numthreads(8, 8, 1)]
void SPATIAL_DENOISE_KERNEL_NAME(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);

    float centralDepth, centralAO;
    float final = Blur(dispatchThreadId.xy, centralDepth, centralAO);

#if TO_TEMPORAL
    _AOPackedBlurred[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = PackAOOutput(final, centralDepth);
#else
    _OcclusionTexture[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = OutputFinalAO(final);
#endif
}
#endif


#ifdef TEMPORAL

uint PackHistoryData(float AO, float depth, float mvLen)
{
    uint packedVal = 0;
    packedVal = BitFieldInsert(0x000000ff, UnpackInt(AO, 8), packedVal);
    packedVal = BitFieldInsert(0x0000ff00, UnpackInt(mvLen, 8) << 8, packedVal);
    packedVal = BitFieldInsert(0xffff0000, UnpackInt(depth, 16) << 16, packedVal);
    return packedVal;
}

void UnpackHistoryData(uint historyData, out float AO, out float depth, out float mvLen)
{
    AO = UnpackUIntToFloat(historyData, 0, 8);
    mvLen = UnpackUIntToFloat(historyData, 8, 8);
    depth = UnpackUIntToFloat(historyData, 16, 16);
}

RW_TEXTURE2D_X(uint, _AOOutputHistory);

TEXTURE2D_X(_AOPackedBlurred);
TEXTURE2D_X_UINT(_AOPackedHistory);

#if HALF_RES
RW_TEXTURE2D_X(float, _OcclusionTexture);
#else
RW_TEXTURE2D_X(float, _OcclusionTexture);
#endif

float3 FindMinMaxAvgAO(float2 centralPos)
{
    float minAO = 2.0f;
    float maxAO = -2.0f;
    float avg = 0;
    for (int i = -1; i <= 1; ++i)
    {
        for (int j = -1; j <= 1; ++j)
        {
            float data = LOAD_TEXTURE2D_X(_AOPackedBlurred, (uint2)centralPos + uint2(i, j)).x;
            float currAO, ignored;
            UnpackData(data, currAO, ignored);
            avg += currAO;
            minAO = min(minAO, currAO);
            maxAO = max(maxAO, currAO);
        }
    }

    return float3(minAO, maxAO, avg/9);
}

[numthreads(8, 8, 1)]
void TEMPORAL_DENOISE_KERNEL_NAME(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);

    float currFrameData = _AOPackedBlurred[COORD_TEXTURE2D_X(dispatchThreadId.xy)].x;
    float currDepth, currAO;
    UnpackData(currFrameData, currAO, currDepth);

    PositionInputs posInputs = GetPositionInput(float2(dispatchThreadId.xy), _ScreenSize.zw, uint2(8, 8));

#if HALF_RES
    float2 closest = posInputs.positionSS * 2;
#else
    float2 closest = posInputs.positionSS;
#endif
    float2 motionVector;
    DecodeMotionVector(LOAD_TEXTURE2D_X(_CameraMotionVectorsTexture, closest), motionVector);
    float motionVecLength = length(motionVector);

    float2 uv = (dispatchThreadId.xy + 0.5) * _AOBufferSize.zw;
    float2 prevFrameNDC = uv - motionVector;

    uint prevData = asuint(_AOPackedHistory[COORD_TEXTURE2D_X((prevFrameNDC) * _AOHistorySize.xy)].x);
    float prevMotionVecLen, prevAO, prevDepth;
    UnpackHistoryData(prevData, prevAO, prevDepth, prevMotionVecLen);

    float motionVecWeighting = saturate(motionVecLength * 100.0);
    float velWeight = 1.0f - saturate((abs(prevMotionVecLen - motionVecWeighting)) * 3.0f);

    float3 minMax = FindMinMaxAvgAO(float2(dispatchThreadId.xy));
    float minAO = minMax.x;
    float maxAO = minMax.y;
    float avg = minMax.z;
    float nudge = lerp(_AOTemporalUpperNudgeLimit, _AOTemporalLowerNudgeLimit, motionVecWeighting) * abs(avg - currAO);
    minAO -= nudge;
    maxAO += nudge;

    float diff = abs(currAO - prevAO) / Max3(prevAO, currAO, 0.1f);
    float weight = 1.0 - diff;
    float feedback = lerp(0.85, 0.95, weight * weight);

    prevAO = clamp(prevAO, minAO, maxAO);

    float depth_similarity = saturate(pow(prevDepth / currDepth, 1) + 0.01);

    float newAO = (lerp(currAO, prevAO, feedback * depth_similarity * velWeight));

    _AOOutputHistory[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = PackHistoryData(newAO, currDepth, motionVecWeighting);

#ifdef HALF_RES
    // The conversion and the pow happens in upsample phase.
    _OcclusionTexture[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = PackAOOutput(newAO, currDepth);
#else
    _OcclusionTexture[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = OutputFinalAO(newAO);
#endif

}
#endif


#ifdef HISTORY_COPY
RW_TEXTURE2D_X(uint, _OutputTexture);
TEXTURE2D_X(_InputTexture);

[numthreads(8, 8, 1)]
void GTAODenoise_CopyHistory(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);
    _OutputTexture[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = _InputTexture[COORD_TEXTURE2D_X(dispatchThreadId.xy)].x;
}
#endif
