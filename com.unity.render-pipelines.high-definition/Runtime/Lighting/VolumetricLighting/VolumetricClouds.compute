#pragma kernel DownscaleDepth
#pragma kernel RenderClouds
#pragma kernel ReprojectClouds
#pragma kernel UpscaleAndCombineClouds
#pragma kernel ComputeVolumetricCloudsShadow

#pragma multi_compile _ PHYSICALLY_BASED_SUN

// #pragma enable_d3d11_debug_symbols

// The vertical distortion as upper strat-clouds move faster than lower strats
#define MOTION_DISTORTION 0.05
// The number of octaves for the multi-scattering
#define NUM_MULTI_SCATTERING_OCTAVES 2
// Bias in the light sample distribution to exagerate the darkening effect of the clouds
#define WEIGHTED_LIGHT_SAMPLE_DISTRIBUTION_FACTOR 1.5f
// The number of times the low frequency noise is repeated
#define CLOUD_SCALE_FACTOR 5.0
// The number of times the high frequency noise is repeated
#define EROSION_SCALE_FACTOR 75.0
// Global offset to the high frequency noise
#define CLOUD_DETAIL_MIP_OFFSET 1.0
// Global offset for reaching the LUT/AO
#define CLOUD_LUT_MIP_OFFSET 1.0
// Density blow wich we consider the density is zero (optimization reasons)
#define CLOUD_DENSITY_TRESHOLD 0.001f
// Number of steps before we start the large steps
#define EMPTY_STEPS_BEFORE_LARGE_STEPS 4
// Forward eccentricity
#define FORWARD_ECCENTRICITY 0.8
// Forward eccentricity
#define BACKWARD_ECCENTRICITY 0.5
// Minimal distance before which clouds are dislayed
#define MIN_CLOUD_DISTANCE 10.0
// Distance until which the erosion texture i used
#define MIN_EROSION_DISTANCE 3000.0
#define MAX_EROSION_DISTANCE 100000.0
// Value that is used to normalize the noise textures
#define NOISE_TEXTURE_NORMALIZATION_FACTOR 100000.0f

// HDRP generic includes
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/EntityLighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/PhysicallyBasedSky/ShaderVariablesPhysicallyBasedSky.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/PhysicallyBasedSky/PhysicallyBasedSkyCommon.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/VolumetricLighting/VolumetricCloudsDef.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingSampling.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Builtin/BuiltinData.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ScreenSpaceLighting/BilateralUpsample.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RayTracingCommon.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/AtmosphericScattering/AtmosphericScattering.hlsl"

#define REAL_TIME_VOLUMETRIC_CLOUDS
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/VolumetricLighting/VolumetricCloudsUtilities.hlsl"

// Input textures
TEXTURE2D_X(_HalfResDepthBuffer);
TEXTURE2D_X(_DepthTexture);
Texture2D<float4> _CloudMapTexture;
Texture2D<float3> _CloudLutTexture;

// Noise textures for adding details
Texture3D<float> _Worley128RGBA;
Texture3D<float> _Worley32RGB;

// Texture that has just been traced
TEXTURE2D_X(_CloudsLightingTexture);
TEXTURE2D_X(_CloudsDepthTexture);

// History buffers
TEXTURE2D_X(_HistoryVolumetricClouds0Texture);
TEXTURE2D_X(_HistoryVolumetricClouds1Texture);

// Output texture
RW_TEXTURE2D_X(float, _HalfResDepthBufferRW);
RW_TEXTURE2D_X(float4, _CloudsLightingTextureRW);
RW_TEXTURE2D_X(float, _CloudsDepthTextureRW);
RW_TEXTURE2D_X(float3, _CloudsAdditionalTextureRW);

[numthreads(8, 8, 1)]
void DownscaleDepth(uint3 intermediateCoord : SV_DispatchThreadID, uint2 groupThreadId : SV_GroupThreadID, uint2 groupId : SV_GroupID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(intermediateCoord.z);

    // If this is bigger than the trace size, we are done
    if (any(intermediateCoord.xy > uint2(_IntermediateScreenSize.xy)))
        return;

    // TODO USE LDS for this
    float depth0 = LOAD_TEXTURE2D_X(_DepthTexture, intermediateCoord.xy * 2.0).x;
    float depth1 = LOAD_TEXTURE2D_X(_DepthTexture, intermediateCoord.xy * 2.0 + int2(0, 1)).x;
    float depth2 = LOAD_TEXTURE2D_X(_DepthTexture, intermediateCoord.xy * 2.0 + int2(1, 1)).x;
    float depth3 = LOAD_TEXTURE2D_X(_DepthTexture, intermediateCoord.xy * 2.0 + int2(1, 0)).x;

    // Combine it with the current shift to define which half res depth should be used
    _HalfResDepthBufferRW[COORD_TEXTURE2D_X(intermediateCoord.xy)] = min(min(depth0, depth1), min(depth2, depth3));
}

// Structure that holds all the lighting data required to light the cloud particles
struct EnvironmentLighting
{
    // Light direction (point to sun)
    float3 sunDirection;
    // Light intensity/color of the sun, this already takes into account the atmospheric scattering
    float3 sunColor;
    // Ambient term from the ambient probe
    float3 ambientTerm;
};

// Structure that holds all the data required for the cloud ray marching
struct CloudRay
{
    // Depth value of the pixel
    float depthValue;
    // Origin of the ray in absolute world space
    float3 origin;
    // Direction of the ray in world space
    float3 direction;
    // Maximal ray length before hitting the far plane or an occluder
    float maxRayLength;
    // Flag to track if we are inside the cloud layers
    float insideClouds;
    // Distance to earth center
    float toEarthCenter;
    // Environement lighting
    EnvironmentLighting envLighting;
};

CloudRay BuildRay(uint2 halfResCoord)
{
    CloudRay ray;
    ZERO_INITIALIZE(CloudRay, ray);

    // Grab the depth value of the pixel (at half resolution)
    ray.depthValue = LOAD_TEXTURE2D_X(_HalfResDepthBuffer, halfResCoord.xy).x;

    // Flag is this sky pixel occluded by an object?
    float isOccluded = ray.depthValue != UNITY_RAW_FAR_CLIP_VALUE ? 1.0 : 0.0;

    // Compute the world space position of the pixel (or at a virtual position is it the sky)
    float3 pos = ComputeWorldSpacePosition((halfResCoord + 0.5) * _IntermediateScreenSize.zw, lerp(0.5, ray.depthValue, isOccluded), UNITY_MATRIX_I_VP);

    // normalize to get the direction
    ray.direction = normalize(pos);

    // Compute the max cloud ray length
    ray.maxRayLength = lerp(_ProjectionParams.z, length(pos), isOccluded);

    // Compute the absolute position of the pixel from which the ray will start
    ray.origin = float3(_WorldSpaceCameraPos.x, _WorldSpaceCameraPos.y + _EarthRadius, _WorldSpaceCameraPos.z);

    // Compute the distance to the center of the earth
    ray.toEarthCenter = length(ray.origin);

    // Evaluate where the point is
    // -2.0 means under the surface of the earth
    // -1.0 means between the surface of the earth and the lower cloud bound
    // 0.0 means inside the cloud domain
    // 1.0 means above the cloud domain
    if (ray.toEarthCenter < _EarthRadius)
        ray.insideClouds = -2.0;
    else if (ray.toEarthCenter < (_LowestCloudAltitude + _EarthRadius))
        ray.insideClouds = -1.0;
    else if (ray.toEarthCenter > (_HighestCloudAltitude + _EarthRadius))
        ray.insideClouds = 1.0f;
    else
        ray.insideClouds = 0.0;
    return ray;
}

bool PointInsideCloudVolume(float3 positionWS)
{
    float toEarthCenter2 = dot(positionWS, positionWS);
    return toEarthCenter2 < _CloudRangeSquared.y && toEarthCenter2 > _CloudRangeSquared.x;
}

bool GetCloudVolumeIntersection_Light(float3 org, float3 dir, out float totalDistance)
{
    // Given that this is a light ray, it will always start from inside the volume and is guaranteed to exit
    float2 intersection, intersectionEarth;
    RaySphereIntersection(org, dir, _HighestCloudAltitude + _EarthRadius, intersection);
    bool intersectEarth = RaySphereIntersection(org, dir, _EarthRadius);
    totalDistance = intersection.x;
    // If the ray intersects the earth, then the sun is occlued by the earth
    return !intersectEarth;
}

// Structure that describes the ray marching ranges that we should be iterating on
struct RayMarchRange
{
    // The start of the range
    float start;
    // The length of the range
    float distance;
};

bool GetCloudVolumeIntersection(float3 org, float3 dir, float insideClouds, float toEarthCenter, out RayMarchRange rayMarchRange)
{
    ZERO_INITIALIZE(RayMarchRange, rayMarchRange);

    // intersect with all three spheres
    float2 intersectionInter, intersectionOuter;
    int numInterInner = RaySphereIntersection(org, dir, _LowestCloudAltitude + _EarthRadius, intersectionInter);
    int numInterOuter = RaySphereIntersection(org, dir, _HighestCloudAltitude + _EarthRadius, intersectionOuter);
    bool intersectEarth = RaySphereIntersection(org, dir, insideClouds < -1.5 ? toEarthCenter : _EarthRadius);

    // Did we achieve any intersection ?
    bool intersect = numInterInner > 0 || numInterOuter > 0;

    // If we are inside the lower cloud bound
    if (insideClouds < -0.5)
    {
        // The ray starts at the first intersection with the lower bound and goes up to the first intersection with the outer bound
        rayMarchRange.start = intersectionInter.x;
        rayMarchRange.distance = intersectionOuter.x - intersectionInter.x;
    }
    else if (insideClouds == 0.0)
    {
        // If we are inside, the ray always starts at 0
        rayMarchRange.start = 0;

        // if we intersect the earth, this means the ray has only one range
        if (intersectEarth)
            rayMarchRange.distance = intersectionInter.x;
        // if we do not untersect the earth and the lower bound. This means the ray exits to outer space
        else if(numInterInner == 0)
            rayMarchRange.distance = intersectionOuter.x;
        // If we do not intersect the earth, but we do intersect the lower bound, we have two ranges.
        else
            rayMarchRange.distance = intersectionInter.x;
    }
    // We are in outer space
    else
    {
        // We always start from our intersection with the outer bound
        rayMarchRange.start = intersectionOuter.x;

        // If we intersect the earth, ony one range
        if(intersectEarth)
            rayMarchRange.distance = intersectionInter.x - intersectionOuter.x;
        else
        {
            // If we do not intersection the lower bound, the ray exits from the upper bound
            if(numInterInner == 0)
                rayMarchRange.distance = intersectionOuter.y - intersectionOuter.x;
            else
                rayMarchRange.distance = intersectionInter.x - intersectionOuter.x;
        }
    }

    // We are not allowed to render clouds under a certain distance
    if (MIN_CLOUD_DISTANCE > rayMarchRange.start)
    {
        rayMarchRange.start = MIN_CLOUD_DISTANCE;
        rayMarchRange.distance -= MIN_CLOUD_DISTANCE - rayMarchRange.start;
    }

    // Mke sure we cannot go beyond what the number of samples
    rayMarchRange.distance = clamp(0, rayMarchRange.distance, _MaxRayMarchingDistance);

    // Return if we have an intersection
    return intersect;
}

// Structure that holds all the data used to define the cloud density of a point in space
struct CloudCoverageData
{
    // From a top down view, in what proportions this pixel has clouds
    float2 coverage;
    // From a top down view, in what proportions this pixel has clouds
    float rainClouds;
    // Value that allows us to request the cloudtype using the density
    float cloudType;
    // Maximal cloud height
    float maxCloudHeight;
};

float3 AnimateCloudMapPosition(float3 positionWS)
{
    return positionWS + float3(_WindVector.x, 0.0, _WindVector.y) * _LargeWindSpeed;
}

float3 AnimateBaseNoisePosition(float3 positionWS)
{
    return positionWS + float3(_WindVector.x, 0.0, _WindVector.y) * _MediumWindSpeed;
}

float3 AnimateFineNoisePosition(float3 positionWS)
{
    return positionWS + float3(_WindVector.x, 0.0, _WindVector.y) * _SmallWindSpeed;
}

void GetCloudCoverageData(float3 positionWS, out CloudCoverageData data)
{
    // Convert the position into dome space
    float2 normalizedPosition = AnimateCloudMapPosition(positionWS).xz / _NormalizationFactor * _CloudMapTiling.xy + _CloudMapTiling.zw;
    // Read the data from the texture
    float4 cloudMapData =  SAMPLE_TEXTURE2D_LOD(_CloudMapTexture, s_linear_repeat_sampler, float2(normalizedPosition), 0);
    data.coverage = float2(cloudMapData.x, cloudMapData.x * cloudMapData.x);
    data.rainClouds = cloudMapData.y;
    data.cloudType = cloudMapData.z;
    data.maxCloudHeight = cloudMapData.w;
}

EnvironmentLighting EvaluateEnvironmentLighting(CloudRay ray)
{
    // Sun parameters
    EnvironmentLighting environmentLight;
    environmentLight.sunDirection = _SunDirection.xyz;
    environmentLight.sunColor = _SunLightColor.xyz * (_ExposureSunColor ? GetCurrentExposureMultiplier() : 1.0);
    environmentLight.ambientTerm = SampleSH9(_AmbientProbeCoeffs, ray.direction) * GetCurrentExposureMultiplier();

#ifdef PHYSICALLY_BASED_SUN
    if(_PhysicallyBasedSun == 1)
    // TODO: move this into a shared function
    {
        float3 X = float3(0.0, 0.0, 0.0);
        float3 C = _PlanetCenterPosition.xyz;

        float r        = distance(X, C);
        float cosHoriz = ComputeCosineOfHorizonAngle(r);
        float cosTheta = dot(X - C, environmentLight.sunDirection) * rcp(r); // Normalize

        if (cosTheta >= cosHoriz) // Above horizon
        {
            float3 oDepth = ComputeAtmosphericOpticalDepth(r, cosTheta, true);
            // Cannot do this once for both the sky and the fog because the sky may be desaturated. :-(
            float3 transm  = TransmittanceFromOpticalDepth(oDepth);
            float3 opacity = 1 - transm;
            environmentLight.sunColor.rgb *= 1 - (Desaturate(opacity, _AlphaSaturation) * _AlphaMultiplier);
        }
        else
        {
            // return 0; // Kill the light. This generates a warning, so can't early out. :-(
           environmentLight.sunColor = 0;
        }
    }
#endif
    return environmentLight;
}

struct CloudProperties
{
    // Normalized float that tells the "amount" of clouds that is at a given location
    float density;
    // Ambient occlusion for the ambient probe
    float ambientOcclusion;
    // Normalized value that tells us the height within the cloud volume (vertically)
    float height;
    // Transmittance of the cloud
    float sigmaT;
};

float EvaluateNormalizedCloudHeight(float3 positionWS)
{
    return (length(positionWS) - (_LowestCloudAltitude + _EarthRadius)) / ((_HighestCloudAltitude + _EarthRadius) - (_LowestCloudAltitude + _EarthRadius));
}

void EvaluateCloudProperties(float3 positionWS, float noiseMipOffset, float erosionMipOffset, bool cheapVersion, bool lightSampling, out CloudProperties properties)
{
    // Initliaze all the values to 0 in case
    ZERO_INITIALIZE(CloudProperties, properties);

    // By default the ambient occlusion is 1.0
    properties.ambientOcclusion = 1.0;

    // If the next sampling point is not inside the coud volume the density
    if (!PointInsideCloudVolume(positionWS) || positionWS.y < 0.0f)
        return;

    // Compute the normalized position for the three channels
    float3 normalizedPos = positionWS / _NormalizationFactor;

    // Evaluate the normalized height of the position within the cloud volume
    properties.height = EvaluateNormalizedCloudHeight(positionWS);

    // Evaluate the generic sampling coordinates
    float3 baseNoiseSamplingCoordinates = float3(AnimateBaseNoisePosition(positionWS).xzy / NOISE_TEXTURE_NORMALIZATION_FACTOR) * CLOUD_SCALE_FACTOR * _ShapeScale;

    // Evaluate the coordinates at which the noise will be sampled and apply wind displacement
    baseNoiseSamplingCoordinates += properties.height * float3(_WindDirection.x, 0.0f, _WindDirection.y) * MOTION_DISTORTION;

    // Read the low frequency Perlin-Worley and Worley noises
    float lowFrequencyNoise = SAMPLE_TEXTURE3D_LOD(_Worley128RGBA, s_trilinear_repeat_sampler, baseNoiseSamplingCoordinates.xyz, noiseMipOffset);

    // Initiliaze the erosion and shape factors (that will be overriden)
    float shapeFactor = lerp(0.1, 1.0, _ShapeFactor);
    float erosionFactor = _ErosionFactor;

    // Evaluate the cloud coverage data for this position
    CloudCoverageData cloudCoverageData;
    GetCloudCoverageData(positionWS, cloudCoverageData);

    // If this region of space has no cloud coverage, exit right away
    if (cloudCoverageData.coverage.x <= CLOUD_DENSITY_TRESHOLD || cloudCoverageData.maxCloudHeight < properties.height)
        return;

    // Read from the LUT
    float3 densityErosionAO = SAMPLE_TEXTURE2D_LOD(_CloudLutTexture, s_linear_clamp_sampler, float2(cloudCoverageData.cloudType, properties.height), CLOUD_LUT_MIP_OFFSET);

    // Adjust the shape and erosion factor based on the LUT and the coverage
    shapeFactor = lerp(0, shapeFactor * densityErosionAO.y, cloudCoverageData.coverage.x);
    erosionFactor = lerp(0, erosionFactor * densityErosionAO.y, cloudCoverageData.coverage.x);

    // Combine with the low frequency noise, we want less shaping for large clouds
    lowFrequencyNoise = lerp(1.0, lowFrequencyNoise, shapeFactor);
    float base_cloud = 1.0 - densityErosionAO.x * cloudCoverageData.coverage.x * (1.0 - shapeFactor);
    base_cloud = saturate(remap(lowFrequencyNoise, base_cloud, 1.0, 0.0, 1.0)) * cloudCoverageData.coverage.y;

    // Weight the ambient occlusion's contribution
    properties.ambientOcclusion = densityErosionAO.z;

    // Change the sigma based on the rain cloud data
    properties.sigmaT = lerp(0.04, 0.12, cloudCoverageData.rainClouds);

    // The ambient occlusion value that is baked is less relevant if there is shaping or erosion, small hack to compensate that
    float ambientOcclusionBlend = saturate(1.0 - max(erosionFactor, shapeFactor) * 0.5);
    properties.ambientOcclusion = lerp(1.0, properties.ambientOcclusion, ambientOcclusionBlend);

    // Apply the erosion for nifer details
    if (!cheapVersion)
    {
        float3 fineNoiseSamplingCoordinates = AnimateFineNoisePosition(positionWS) / NOISE_TEXTURE_NORMALIZATION_FACTOR * EROSION_SCALE_FACTOR * _ErosionScale;
        float highFrequencyNoise = SAMPLE_TEXTURE3D_LOD(_Worley32RGB, s_linear_repeat_sampler, fineNoiseSamplingCoordinates, CLOUD_DETAIL_MIP_OFFSET + erosionMipOffset).x;

        // Compute the weight of the low frequency noise
        highFrequencyNoise = lerp(0.0, highFrequencyNoise, erosionFactor * 0.75f * cloudCoverageData.coverage.x);
        base_cloud = remap(base_cloud, highFrequencyNoise, 1.0, 0.0, 1.0);
    }

    // Given that we are not sampling the erosion texture, we compensate by substracting an erosion value
    if (lightSampling)
        base_cloud -= erosionFactor * 0.25;

    // Make sure we do not send any negative values
    base_cloud = max(0, base_cloud);

    // Attenuate everything by the density multiplier
    properties.density = base_cloud * _DensityMultiplier;
}

float3 EvaluateSunLuminance(float3 position, in EnvironmentLighting envLighting, float density, float powderEffect, float phaseFunction[NUM_MULTI_SCATTERING_OCTAVES])
{
    // Compute the Ray to the limits of the cloud volume in the direction of the light
    float totalLightDistance = 0.0f;

    // If we early out, this means we've hit the earth itself
    if(!GetCloudVolumeIntersection_Light(position, envLighting.sunDirection, totalLightDistance))
        return 0.0;

    // Initially the transmittance is one for all octaves
    float3 sunLightTransmittance[NUM_MULTI_SCATTERING_OCTAVES];
    int o;
    for(o = 0; o < NUM_MULTI_SCATTERING_OCTAVES; ++o)
        sunLightTransmittance[o] = 1.0;

    // Collect total density along light ray.
    float lastDist = 0;
    for (int j = 1; j <= _NumLightSteps; j++)
    {
        // The samples are not linearly distributed along the point-light direction due to their low number. We sample they in a logarithmic way.
        float dist = totalLightDistance * PositivePow(j / (float)_NumLightSteps, WEIGHTED_LIGHT_SAMPLE_DISTRIBUTION_FACTOR);

        // Compute the size of the current step
        float stepSize = (dist - lastDist);

        // Evaluate the current sample point
        float3 currentSamplePoint = position + envLighting.sunDirection * dist;
        // Get the cloud properties at the sample point
        CloudProperties lightRayCloudProperties;
        EvaluateCloudProperties(currentSamplePoint, 7.0f * j / _NumLightSteps, 0.0, true, true, lightRayCloudProperties);

        // Compute the extinction
        const float3 mediaExtinction = max(_ScatteringTint.xyz * lightRayCloudProperties.density * lightRayCloudProperties.sigmaT, float3(1e-6, 1e-6, 1e-6));

        // Update the transmittance for every octave
        for(o = 0; o < NUM_MULTI_SCATTERING_OCTAVES; ++o)
            sunLightTransmittance[o] *= exp(- stepSize * mediaExtinction * PositivePow(_MultiScattering, o));

        lastDist = dist;
    }

    // Compute the luminance for each octave
    float3 luminance = 0.0;
    for(o = 0; o < NUM_MULTI_SCATTERING_OCTAVES; ++o)
        luminance += sunLightTransmittance[o] * envLighting.sunColor * powderEffect * phaseFunction[o] * PositivePow(_MultiScattering, o);

    // return the combined luminance
    return luminance;
}

// Structure that holds the result of our volumetric ray
struct VolumetricRayResult
{
    float3 inScattering;
    float transmittance;
    float meanDistance;
    float numRealSteps;
    bool invalidRay;
};


void EvaluateCloud(CloudProperties cloudProperties, CloudRay cloudRay,  float phaseFunction[NUM_MULTI_SCATTERING_OCTAVES],
                float3 currentPosition, float stepSize, float cosAngle,
                inout VolumetricRayResult volumetricRay)
{
    // Apply the extinction
    const float3 mediaExtinction = _ScatteringTint.xyz * cloudProperties.density * cloudProperties.sigmaT;
    const float currentStepExtinction = exp(-cloudProperties.density * cloudProperties.sigmaT * stepSize);

    // Compute the powder effect
    float powder_effect = PowderEffect(cloudProperties.density, cosAngle, _PowderEffectIntensity);

    // Evaluate the luminance at this sample
    const float3 luminance = (EvaluateSunLuminance(currentPosition, cloudRay.envLighting, cloudProperties.density, powder_effect, phaseFunction)
                                + cloudRay.envLighting.ambientTerm * cloudProperties.ambientOcclusion) * mediaExtinction;

    // Improved analytical scattering
    const float3 integScatt = (luminance - luminance * currentStepExtinction) / mediaExtinction;
    volumetricRay.inScattering += integScatt * volumetricRay.transmittance;
    volumetricRay.transmittance *= currentStepExtinction;
}

VolumetricRayResult TraceVolumetricRay(CloudRay cloudRay, float offset)
{
    // Initiliaze the volumetric ray
    VolumetricRayResult volumetricRay;
    ZERO_INITIALIZE(VolumetricRayResult, volumetricRay);
    volumetricRay.inScattering = 0.0;
    volumetricRay.transmittance = 1.0;
    volumetricRay.meanDistance = _MaxCloudDistance;
    volumetricRay.numRealSteps = 0;
    volumetricRay.invalidRay = true;

    // Determine if ray intersects bounding volume, if the ray does not intersect the cloud volume AABB, skip right away
    RayMarchRange rayMarchRange;
    if (!GetCloudVolumeIntersection(cloudRay.origin, cloudRay.direction, cloudRay.insideClouds, cloudRay.toEarthCenter, rayMarchRange))
        return volumetricRay;

    // Total distance that the ray must travel including empty spaces
    float totalDistance = rayMarchRange.distance;

    if (cloudRay.maxRayLength < rayMarchRange.start)
        return volumetricRay;

    volumetricRay.invalidRay = false;

    // Initialize the depth for accumulation
    volumetricRay.meanDistance = 0.0;

    // Clamp the travel distance to whatever is closer
    // - Sky Occluder
    // - Volume end
    // - Far plane
    totalDistance = min(totalDistance, cloudRay.maxRayLength - rayMarchRange.start);

    // Evaluate our integration step
    float stepS = totalDistance / (float)_NumPrimarySteps;

    // Offset the starting point using our dithering pattern.
    rayMarchRange.start += stepS * offset;
    rayMarchRange.distance -= stepS * offset;

    // Evaluate cos of the theta angle between the view and light vectors
    float cosAngle = dot(cloudRay.direction, cloudRay.envLighting.sunDirection);

    // Evaluate the phase function for our ray direction
    float phaseFunction[NUM_MULTI_SCATTERING_OCTAVES];
    for(int o = 0; o < NUM_MULTI_SCATTERING_OCTAVES; ++o)
    {
        const float forwardP = HenyeyGreenstein(cosAngle,  FORWARD_ECCENTRICITY * PositivePow(_MultiScattering, o));
        const float backwardsP = HenyeyGreenstein(cosAngle, -BACKWARD_ECCENTRICITY * PositivePow(_MultiScattering, o));
        phaseFunction[o] = lerp(backwardsP, forwardP, _ScatteringDirection);
    }

    // Initialize the cloud properties structure
    CloudProperties cloudProperties;
    ZERO_INITIALIZE(CloudProperties, cloudProperties);

    // Tracking the number of steps that have been made
    int currentIndex = 0;

    // Normalization value of the depth
    float meanDistanceDivider = 0.0f;

    // Current position for the evaluation
    float3 currentPosition = cloudRay.origin + (rayMarchRange.start + stepS) * cloudRay.direction;

    // Current Distance that has been marched
    float currentDistance = stepS;

    // Initialize the values for the optimized ray marching
    bool activeSampling = false;
    int sequentialEmptySamples = 0;

    // Do the ray march for every step that we can.
    while (currentIndex < _NumPrimarySteps && currentDistance < totalDistance)
    {
        // Should we be evaluating the clouds or just doing the large ray marching
        if (activeSampling)
        {
            // Compute the mip offset for the erosion texture
            float erosionMipOffset = lerp(0.0, 2.0, saturate((currentDistance - MIN_EROSION_DISTANCE) / (MAX_EROSION_DISTANCE - MIN_EROSION_DISTANCE)));

            // If the density is null, we can skip as there will be no contribution
            EvaluateCloudProperties(currentPosition, 0.0f, erosionMipOffset, false, false, cloudProperties);
            if (cloudProperties.density > CLOUD_DENSITY_TRESHOLD)
            {
                // Contribute to the average depth (must be done first in case we end up inside a cloud at the next step)
                float transmitanceXdensity = volumetricRay.transmittance * cloudProperties.density;
                volumetricRay.meanDistance += (rayMarchRange.start + currentDistance) * transmitanceXdensity;
                meanDistanceDivider += transmitanceXdensity;

                // Evaluate the cloud at the position
                EvaluateCloud(cloudProperties, cloudRay, phaseFunction, currentPosition, stepS, cosAngle, volumetricRay);

                // if most of the energy is absorbed, just leave.
                if (volumetricRay.transmittance < 0.003)
                {
                    volumetricRay.transmittance = 0.0;
                    break;
                }

                // Reset the empty sample counter
                sequentialEmptySamples = 0;
            }
            else
                sequentialEmptySamples++;

            // If it has been more than EMPTY_STEPS_BEFORE_LARGE_STEPS, disable active sampling and start large steps
            if (sequentialEmptySamples == EMPTY_STEPS_BEFORE_LARGE_STEPS)
                activeSampling = false;
            // Do the next step
            currentPosition += cloudRay.direction * stepS;
            currentDistance += stepS;
        }
        else
        {
            // Sample the cheap version of the clouds
            CloudProperties cloudProperties;
            EvaluateCloudProperties(currentPosition, 1.0f, 0.0, true, false, cloudProperties);

            // If the density is lower than our tolerance,
            if (cloudProperties.density < CLOUD_DENSITY_TRESHOLD)
            {
                currentPosition += cloudRay.direction * stepS * 2.0f;
                currentDistance += stepS * 2.0f;
            }
            else
            {
                // Somewhere between this step and the previous clouds started
                // We reset all the counters and enable active sampling
                currentPosition -= cloudRay.direction * stepS;
                currentDistance -= stepS;
                activeSampling = true;
                sequentialEmptySamples = 0;
            }
        }
        currentIndex++;
    }

    // Compute the effective number of steps that have been marched
    volumetricRay.numRealSteps = (float)currentIndex / _NumPrimarySteps;

    // Normalized the depth we computed
    if (volumetricRay.meanDistance == 0.0)
        volumetricRay.invalidRay = true;
    else
        volumetricRay.meanDistance /= meanDistanceDivider;

    // return the final ray result
    return volumetricRay;
}

[numthreads(8, 8, 1)]
void RenderClouds(uint3 traceCoord : SV_DispatchThreadID, uint2 groupThreadId : SV_GroupThreadID, uint2 groupId : SV_GroupID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(traceCoord.z);

    // If this is bigger than the trace size, we are done
    if (any(traceCoord.xy > uint2(_TraceScreenSize.xy)))
        return;

    // Compute the half res coordinate that matches this thread (as we virtually do the computation in half res space)
    int checkerBoardIndex = ComputeCheckerBoardIndex(traceCoord.xy, _SubPixelIndex);
    uint2 halfResCoord = traceCoord.xy * 2 + HalfResIndexToCoordinateShift[checkerBoardIndex];

    // Build the ray we will use of the ray marching.
    CloudRay ray = BuildRay(halfResCoord);

    // Compute the environment lighting that is going to be used for the cloud evaluation
    ray.envLighting = EvaluateEnvironmentLighting(ray);

    // We use the Heitz blue noise method for dithering to get the most visually pleasing noise.
    float offset = GetBNDSequenceSample(halfResCoord, _AccumulationFrameIndex, 0);

    // Evaluate the cloud transmittance
    VolumetricRayResult result = TraceVolumetricRay(ray, offset);

    // Compute the cloud depths
    float cloudMinDistance = clamp(_ProjectionParams.y, min(result.meanDistance, ray.maxRayLength), _ProjectionParams.z);
    float cloudMinDepth = result.invalidRay ? ray.depthValue : ConvertCloudDepth(ray.direction * cloudMinDistance);

    // Apply a fast tonemap
    result.inScattering *= rcp(result.inScattering + 1.0);

    // output the result
    _CloudsLightingTextureRW[COORD_TEXTURE2D_X(traceCoord.xy)] = float4(result.inScattering, result.transmittance);
    _CloudsDepthTextureRW[COORD_TEXTURE2D_X(traceCoord.xy)] = cloudMinDepth;
}

void FillCloudReprojectionLDS(uint groupIndex, uint2 groupOrigin)
{
    // Define which value we will be acessing with this worker thread
    int acessCoordX = groupIndex % 6;
    int acessCoordY = groupIndex / 6;

    // Everything we are accessing is in trace res (quarter rez).
    uint2 traceGroupOrigin = groupOrigin / 2;

    // The initial position of the access
    int2 originXY = traceGroupOrigin - int2(1, 1);

    // Compute the sample position
    int2 sampleCoord = int2(clamp(originXY.x + acessCoordX, 0, _TraceScreenSize.x - 1), clamp(originXY.y + acessCoordY, 0, _TraceScreenSize.y - 1));

    // Read the sample value
    int checkerBoardIndex = ComputeCheckerBoardIndex(sampleCoord, _SubPixelIndex);
    float4 sampleVal = LOAD_TEXTURE2D_X(_CloudsLightingTexture, sampleCoord);
    float sampleDP = LOAD_TEXTURE2D_X(_HalfResDepthBuffer, sampleCoord * 2 + HalfResIndexToCoordinateShift[checkerBoardIndex]).x;
    float sampleDC = LOAD_TEXTURE2D_X(_CloudsDepthTexture, sampleCoord).x;

    // Store into the LDS
    gs_cacheR[groupIndex] = sampleVal.r;
    gs_cacheG[groupIndex] = sampleVal.g;
    gs_cacheB[groupIndex] = sampleVal.b;
    gs_cacheA[groupIndex] = sampleVal.a;
    gs_cacheDP[groupIndex] = sampleDP;
    gs_cacheDC[groupIndex] = sampleDC;
}

[numthreads(8, 8, 1)]
void ReprojectClouds(uint3 dispatchThreadId : SV_DispatchThreadID,
                    int groupIndex : SV_GroupIndex,
                    uint2 groupThreadId : SV_GroupThreadID,
                    uint2 groupId : SV_GroupID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);

    // Compute the set of coordinates we need
    uint2 intermediateCoord = dispatchThreadId.xy;
    uint2 fullResCoord = intermediateCoord * 2;
    uint2 traceCoord = intermediateCoord / 2;

    // Only 36 workers of the 64 do the pre-fetching
    if (groupIndex < 36)
    {
        // Load 1 value per thread
        FillCloudReprojectionLDS(groupIndex, groupId * 8);
    }

    // Make sure all values are loaded in LDS by now.
    GroupMemoryBarrierWithGroupSync();

    // Average the depth of the cloud
    float currentCloudDepth = GetCloudDepth_LDS(groupThreadId, int2(0, 0));

    // Compute the motionVector of the clouds
    float2 motionVector = EvaluateCloudMotionVectors(fullResCoord, currentCloudDepth, 1.0);

    // Compute the history pixel coordinate to tap from
    float2 historyCoord = (intermediateCoord.xy + 0.5) - motionVector * _IntermediateScreenSize.xy;
    float2 clampedHistoryUV = clamp(historyCoord, 0.0, _IntermediateScreenSize.xy - 0.5f) / _IntermediateScreenSize.xy;

    // Read the volumetric cloud value from the previous frame
    float2 ratioScale = _HistoryViewportSize / _HistoryBufferSize;
    float2 historySampleCoords = clampedHistoryUV * ratioScale;

    // Grab the history values
    float4 previousResult = SAMPLE_TEXTURE2D_X_LOD(_HistoryVolumetricClouds0Texture, s_linear_clamp_sampler, historySampleCoords, 0);
    float3 previousResult1 = SAMPLE_TEXTURE2D_X_LOD(_HistoryVolumetricClouds1Texture, s_linear_clamp_sampler, historySampleCoords, 0).xyz;

    // Inverse the exposure of the previous frame and apply the current one (need to be done in linear space)
    previousResult.xyz *= rcp(1.0 - previousResult.xyz);
    previousResult.xyz *= GetInversePreviousExposureMultiplier() * GetCurrentExposureMultiplier();
    previousResult.xyz *= rcp(1.0 + previousResult.xyz);

    // Unpack the second buffer
    float previousSampleCount = previousResult1.x;
    float previousDepth = previousResult1.y;
    float previousCloudDepth = previousResult1.z;

    // This tracks if the history is considered valid
    bool validHistory = previousSampleCount >= 0.5f;

    // The history is invalid if we are requesting a value outside the frame
    if(historyCoord.x < 0.0 || historyCoord.x >= _IntermediateScreenSize.x || historyCoord.y < 0.0 || historyCoord.y >= _IntermediateScreenSize.y)
        validHistory = false;

    // Read the resolution of the current pixel
    float currentDepth = LOAD_TEXTURE2D_X(_HalfResDepthBuffer, intermediateCoord).x;

    // Compare the depth of the current pixel to the one of its history, if they are too different, we cannot consider this history valid
    float linearPrevDepth = Linear01Depth(previousDepth, _ZBufferParams);
    float linearCurrentDepth = Linear01Depth(currentDepth, _ZBufferParams);

    // We only need to check if the pixel depth coherence if the clouds can be behind and in front of the pixel
    if (abs(linearPrevDepth - linearCurrentDepth) > linearCurrentDepth * 0.01)
        validHistory = false;

    // Compute the local index that tells us the index of this pixel, the strategy for reprojection is a bit different in both cases
    int localIndex = (intermediateCoord.x & 1) + (intermediateCoord.y & 1) * 2;
    int currentIndex = ComputeCheckerBoardIndex(intermediateCoord / 2, _SubPixelIndex);
    if (localIndex == currentIndex)
    {
        // We need to validate that within the 3x3 trace region, at least one of the pixels is not a background pixel (incluing the clouds)
        float cloudNeighborhood = 0.0f;
        for (int y = -1; y <= 1; ++y)
        {
            for (int x = -1; x <= 1; ++x)
            {
                if (GetCloudDepth_LDS(groupThreadId, int2(x, y)) != 0.0f)
                    cloudNeighborhood += 1.0f;
            }
        }

        // If the target coordinate is out of the screen, we cannot use the history
        float accumulationFactor = 0.0;
        float sampleCount = 1.0;
        if (validHistory && cloudNeighborhood != 0.0f)
        {
            // Define our accumation value
            accumulationFactor = previousSampleCount >= 16.0 ? 0.94117647058 : (previousSampleCount / (previousSampleCount + 1.0));
            accumulationFactor *= _TemporalAccumulationFactor;
            sampleCount = min(previousSampleCount + 1.0, 16.0);
        }

        // Accumulate the result with the previous frame
        previousResult = accumulationFactor * previousResult + (1.0 - accumulationFactor) * GetCloudLighting_LDS(groupThreadId, int2(0, 0));
        previousSampleCount = sampleCount;
        previousDepth = currentDepth;
        previousCloudDepth = currentCloudDepth;
    }
    else
    {
        // Reduce the history validity a bit
        previousSampleCount *= _TemporalAccumulationFactor;

        // If the target coordinate is out of the screen or the depth that was used to generate it
        // is too different from the one of the current pixel, we cannot use the history
        if (!validHistory)
        {
            // Structure that will hold everything
            NeighborhoodUpsampleData3x3 upsampleData;
            FillCloudReprojectionNeighborhoodData(groupThreadId, upsampleData);

            // Make sure that at least one of the pixels in the neighborhood can be used
            float rejectNeighborhood = 0.0f;
            int closestNeighbor = 4;
            OverrideMaskValues(currentDepth, upsampleData, rejectNeighborhood, closestNeighbor);

            // 1.0  if we were able to produce a value 0.0 if we failed to
            previousSampleCount = 1.0f - rejectNeighborhood;

            if (rejectNeighborhood == 1.0f)
            {
                // We don't have any valid history and there is no neighbor that is usable
                previousResult = 0.0f;
                previousSampleCount = 0.0f;
            }
            else
            {
                // We don't have any history for this pixel, but there is at least one neighbor that can be used in the current frame tracing
                previousSampleCount = 1.0f;
                previousResult = BilUpColor3x3(currentDepth, upsampleData);
            }
            previousCloudDepth = GetCloudDepth_LDS(groupThreadId, IndexToLocalOffsetCoords[closestNeighbor]);
        }
        previousDepth = currentDepth;
    }

    // Make sure this doesn't go outside of the [0, 1] interval
    previousResult.w = saturate(previousResult.w);

    // Accumulate the result with the previous frame
    _CloudsLightingTextureRW[COORD_TEXTURE2D_X(intermediateCoord)] = previousResult;
    _CloudsAdditionalTextureRW[COORD_TEXTURE2D_X(intermediateCoord)] = float3(previousSampleCount, previousDepth, previousCloudDepth);
}

// Constant buffer where all variables should land
CBUFFER_START(VolumetricCloudsUpscaleConstantBuffer)
    float2 _UpperScreenSize;
CBUFFER_END

// Half resolution volumetric cloud texture
TEXTURE2D_X(_VolumetricCloudsTexture);
TEXTURE2D_X(_DepthStatusTexture);

// Input output camera color buffer
RW_TEXTURE2D_X(float4, _CameraColorTextureRW);

void FillLDSUpscale(uint groupIndex, uint2 groupOrigin)
{
    // Define which value we will be acessing with this worker thread
    int acessCoordX = groupIndex % 6;
    int acessCoordY = groupIndex / 6;

    // Everything we are accessing is in intermediate res (half rez).
    uint2 traceGroupOrigin = groupOrigin / 2;

    // The initial position of the access
    int2 originXY = traceGroupOrigin - int2(1, 1);

    // Compute the sample position
    int2 sampleCoord = int2(clamp(originXY.x + acessCoordX, 0, _IntermediateScreenSize.x - 1), clamp(originXY.y + acessCoordY, 0, _IntermediateScreenSize.y - 1));

    // Read the sample value
    float4 sampleVal = LOAD_TEXTURE2D_X(_VolumetricCloudsTexture, sampleCoord);
    float3 depthStatusValue = LOAD_TEXTURE2D_X(_DepthStatusTexture, sampleCoord).xyz;

    // Store into the LDS
    gs_cacheR[groupIndex] = sampleVal.r;
    gs_cacheG[groupIndex] = sampleVal.g;
    gs_cacheB[groupIndex] = sampleVal.b;
    gs_cacheA[groupIndex] = sampleVal.a;
    gs_cacheDP[groupIndex] = depthStatusValue.y;
    gs_cachePS[groupIndex] = saturate(depthStatusValue.x);
    gs_cacheDC[groupIndex] = depthStatusValue.z;
}

[numthreads(8, 8, 1)]
void UpscaleAndCombineClouds(uint3 finalCoord : SV_DispatchThreadID,
                            int groupIndex : SV_GroupIndex,
                            uint2 groupThreadId : SV_GroupThreadID,
                            uint2 groupId : SV_GroupID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(finalCoord.z);

    // Only 36 workers of the 64 do the pre-fetching
    if (groupIndex < 36)
    {
        // Load 1 value per thread
        FillLDSUpscale(groupIndex, groupId * 8);
    }

    // Make sure all values are loaded in LDS by now.
    GroupMemoryBarrierWithGroupSync();

    // If out of bounds, leave right away
    if (any(finalCoord.xy > uint2(_ScreenSize.xy)))
        return;

    // Structure that will hold everything
    NeighborhoodUpsampleData3x3 upsampleData;

    // Grab the depth value of the pixel
    float highDepth = LOAD_TEXTURE2D_X(_DepthTexture, finalCoord.xy).x;

    // Read the color buffer
    float4 currentColor = _CameraColorTextureRW[COORD_TEXTURE2D_X(finalCoord.xy)];

    // Fill the sample data
    FillCloudUpscaleNeighborhoodData(groupThreadId.xy, upsampleData);

    // Flag that tells us which pixel holds valid information
    float rejectedNeighborhood = 0.0;
    int closestNeighbor = 4;
    OverrideMaskValues(highDepth, upsampleData, rejectedNeighborhood, closestNeighbor);

    // Do the bilateral upscale
    float4 currentClouds = BilUpColor3x3(highDepth, upsampleData);

    // Read the fallback value and use it if we defined that it was impossible for us to do something about it
    if (rejectedNeighborhood == 1.0f)
        currentClouds = float4(0.0, 0.0, 0.0, 1.0);

    // De-tonemap the inscattering value
    currentClouds.xyz *= rcp(1.0 - currentClouds.xyz);
    currentClouds.w = saturate(currentClouds.w);

    // Compute the pos input of the cloud position
    PositionInputs cloudPosInput = GetPositionInput(finalCoord.xy, _FinalScreenSize.zw, GetCloudDepth_LDS(groupThreadId, IndexToLocalOffsetCoords[closestNeighbor]), UNITY_MATRIX_I_VP, GetWorldToViewMatrix(), 0);

    // Compute the view direction
    float3 viewDir = -normalize(cloudPosInput.positionWS);

    // Compute the fog attenuation of the clouds
    float3 fogColor;
    float3 fogOpacity;
    EvaluateAtmosphericScattering(cloudPosInput, viewDir, fogColor, fogOpacity);
    currentClouds.xyz = currentClouds.xyz * (1 - fogOpacity) + fogColor * (1.0 - currentClouds.a);

    // If this is a background pixel, we want the cloud value, otherwise we do not.
    _CameraColorTextureRW[COORD_TEXTURE2D_X(finalCoord.xy)] = float4(currentColor.xyz * currentClouds.a + currentClouds.xyz, currentColor.a);
}

RW_TEXTURE2D(float3, _VolumetricCloudsShadowRW);

[numthreads(8, 8, 1)]
void ComputeVolumetricCloudsShadow(uint3 currentCoords : SV_DispatchThreadID, uint2 groupThreadId : SV_GroupThreadID, uint2 groupId : SV_GroupID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(currentCoords.z);

    if (currentCoords.x == 0 || currentCoords.y == 0 || ((int)currentCoords.x) == (_ShadowCookieResolution - 1) || ((int)currentCoords.y) == (_ShadowCookieResolution - 1))
    {
        _VolumetricCloudsShadowRW[currentCoords.xy] = _ShadowFallbackValue;
        return;
    }

    // First we compute the location of the shadow plane in the planet coordinate system
    float3 shadowPlaneOrigin = _SunDirection.xyz * (_HighestCloudAltitude + _EarthRadius);
    float3 shadowPlaneNormal = -_SunDirection.xyz;

    // Here the plane is guaranteed to intersect, we don't need to test the result
    float t;
    IntersectPlane(float3(0, _EarthRadius, 0), _SunDirection.xyz, shadowPlaneOrigin, shadowPlaneNormal, t);

    // Compute the position of the shadow plane
    float3 shadowCookieCenter = float3(_WorldSpaceCameraPos.x, _EarthRadius + _ShadowPlaneOffset, _WorldSpaceCameraPos.z) + t * _SunDirection.xyz;

    // Compute the normalized coordinate on the shadow plane
    float2 normalizedCoord = (currentCoords.xy - _ShadowCookieResolution * 0.5f) / (_ShadowCookieResolution * 0.5f);

    // Compute the origin of the ray properties  in the planet space
    float3 rayOrigin = (normalizedCoord.x * _SunRight.xyz * _ShadowRegionSize.x + normalizedCoord.y * _SunUp.xyz * _ShadowRegionSize.y) + shadowCookieCenter;
    float3 rayDirection = -_SunDirection.xyz;

    // Compute the attenuation
    float transmittance = 1.0f;

    // Intersect the outer sphere
    float2 intersectionO, intersectionI;
    int numIntersectionO = RaySphereIntersection(rayOrigin, rayDirection, _HighestCloudAltitude + _EarthRadius, intersectionO);
    int numIntersectionI = RaySphereIntersection(rayOrigin, rayDirection, _LowestCloudAltitude + _EarthRadius, intersectionI);
    if (numIntersectionO != 0 && numIntersectionI != 0)
    {
        // Compute the integration range
        float startDistance = intersectionO.x;
        float totalDistance = intersectionI.x - intersectionO.x;

        float stepSize = totalDistance / 10;

        for (int i = 1; i <= 8; ++i)
        {
            // Compute the sphere intersection position
            float3 positionWS = rayOrigin + rayDirection * (intersectionO.x + stepSize * i);

            // Get the coverage at intersection point
            CloudCoverageData cloudCoverageData;
            GetCloudCoverageData(positionWS, cloudCoverageData);

            // Compute the cloud density
            CloudProperties cloudProperties;
            EvaluateCloudProperties(positionWS, 0.0, 0.0, true, true, cloudProperties);
            if (cloudProperties.density > CLOUD_DENSITY_TRESHOLD)
            {
                // Apply the extinction
                const float3 currentStepExtinction = exp(- _ScatteringTint.xyz * cloudProperties.density * cloudProperties.sigmaT * stepSize);
                transmittance *= Luminance(currentStepExtinction);
            }
        }
    }

    _VolumetricCloudsShadowRW[currentCoords.xy] = lerp(1.0 - _ShadowIntensity, 1.0, transmittance);
}
