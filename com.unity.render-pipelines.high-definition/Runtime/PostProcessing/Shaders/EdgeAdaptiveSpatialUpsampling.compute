#pragma kernel KMain
#pragma kernel KInitialize

#pragma multi_compile _ GAMMA2_INPUT
#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#define A_GPU 1
#define A_HLSL 1
#define FSR_EASU_F 1

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/ffx_a.hlsl"

// 4 elements:
// [0] = const0
// [1] = const1
// [0] = const2
// [1] = const3
// ComputeBuffer is allocated with stride sizeof(int)*4, 4 elements
RWStructuredBuffer<uint4> EASUParameters;

float4 _EASUViewportSize;
float4 _EASUInputImageSize;
float4 _EASUOutputSize;

TEXTURE2D_X(_InputTexture);
RW_TEXTURE2D_X(float4, _OutputTexture);

AF4 FsrEasuRF(AF2 p){ return GATHER_RED_TEXTURE2D_X  (_InputTexture, s_linear_clamp_sampler, p); }
AF4 FsrEasuGF(AF2 p){ return GATHER_GREEN_TEXTURE2D_X(_InputTexture, s_linear_clamp_sampler, p); }
AF4 FsrEasuBF(AF2 p){ return GATHER_BLUE_TEXTURE2D_X (_InputTexture, s_linear_clamp_sampler, p); }


#include "Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/ffx_fsr1.hlsl"

[numthreads(64, 1, 1)]
void KMain(uint3 LocalThreadId : SV_GroupThreadID, uint3 WorkGroupId : SV_GroupID, uint3 dispatchThreadId : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);

    // Do remapping of local xy in workgroup for a more PS-like swizzle pattern.
    AU2 gxy = ARmp8x8(LocalThreadId.x) + AU2(WorkGroupId.x<<3u, WorkGroupId.y<<3u);
    AU4 con0 = EASUParameters[0];
    AU4 con1 = EASUParameters[1];
    AU4 con2 = EASUParameters[2];
    AU4 con3 = EASUParameters[3];
    AF4 c;
    FsrEasuF(c.rgb, gxy, con0, con1, con2, con3);

#ifdef GAMMA2_INPUT
    c.rgb *= c.rgb;
#endif

    _OutputTexture[COORD_TEXTURE2D_X(gxy)] = float4(c.rgb,1.0);
}


/*
Doing this on the GPU despite the fact that CAS provides a CPU version
of FsrRcasCon(). This is done to prevent us from having to rewrite a C#
version every time CAS changes. This is not called from KMain to reduce overhead
during main render.
*/
[numthreads(1,1,1)]
void KInitialize()
{
    AU4 con0 = (AU4)0;
    AU4 con1 = (AU4)0;
    AU4 con2 = (AU4)0;
    AU4 con3 = (AU4)0;
    FsrEasuCon(con0,con1,con2,con3,
        _EASUViewportSize.x,  _EASUViewportSize.y,
        _EASUInputImageSize.x,_EASUInputImageSize.y,
        _EASUOutputSize.x,    _EASUOutputSize.y);

    EASUParameters[0] = con0;
    EASUParameters[1] = con1;
    EASUParameters[2] = con2;
    EASUParameters[3] = con3;
}
