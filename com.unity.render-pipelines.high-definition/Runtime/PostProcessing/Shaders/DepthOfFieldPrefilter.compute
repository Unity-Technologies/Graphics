#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"

#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch


#pragma multi_compile _ NEAR
#pragma multi_compile _ FAR
#pragma multi_compile LOW_QUALITY HIGH_QUALITY FULL_RES
#pragma multi_compile _ ENABLE_ALPHA

#pragma kernel KMain

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/PostProcessDefines.hlsl"

TEXTURE2D_X(_InputTexture);
TEXTURE2D_X(_InputCoCTexture);

RW_TEXTURE2D_X(CTYPE, _OutputNearTexture);
RW_TEXTURE2D_X(float, _OutputNearCoCTexture);

RW_TEXTURE2D_X(CTYPE, _OutputFarTexture);
RW_TEXTURE2D_X(float, _OutputFarCoCTexture);

SAMPLER(sampler_LinearClamp);

CBUFFER_START(cb0)
    float4 _TargetScale;
    float4 _CoCTargetScale;
CBUFFER_END

#define GROUP_SIZE 8

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void KMain(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);

    float2 texelSize = _PostProcessScreenSize.zw * _TargetScale.x;
    PositionInputs posInputs = GetPositionInput(float2(dispatchThreadId.xy), texelSize, uint2(GROUP_SIZE, GROUP_SIZE));
    float2 uv = posInputs.positionNDC;

#if FULL_RES

    CTYPE tapColor = LOAD_TEXTURE2D_X(_InputTexture, posInputs.positionSS).CTYPE_SWIZZLE;
    float tapCoC = LOAD_TEXTURE2D_X(_InputCoCTexture, posInputs.positionSS).x;

    float nearCoC = saturate(abs(min(tapCoC, 0.0)));
    CTYPE nearColorAcc = tapColor;
    float nearCoCAcc = nearCoC;

    // Pre-multiply CoC to reduce bleeding of background blur on focused areas
    float farCoC = saturate(tapCoC);
    CTYPE farColorAcc = tapColor * farCoC;
    float farCoCAcc = farCoC;

#else

#if LOW_QUALITY
    const uint kTapCount = 1;
#else
    // Use a rotated grid to minimize artifacts coming from horizontal and vertical boundaries
    // "High Quality Antialiasing" [Lorach07]
    const uint kTapCount = 5;
#endif
    const float2 kTaps[] = {
        float2( 0.0,  0.0),
        float2( 0.9, -0.4),
        float2(-0.9,  0.4),
        float2( 0.4,  0.9),
        float2(-0.4, -0.9)
    };

    CTYPE nearColorAcc = 0.0;
    CTYPE farColorAcc = 0.0;

    float farCoCAcc = 0.0;
    float nearCoCAcc = 0.0;

    // Avoid bleeding with the RTHandle autosize system
    float2 maxCoordCoC = (1.0f - 0.5f*texelSize) * _CoCTargetScale.xy;

    UNITY_UNROLL
    for (uint i = 0; i < kTapCount; i++)
    {
        float2 tapCoord = texelSize * kTaps[i] + uv;

        CTYPE tapColor = SAMPLE_TEXTURE2D_X_LOD(_InputTexture, sampler_LinearClamp, ClampAndScaleUVForBilinearPostProcessTexture(tapCoord, texelSize), 0.0).CTYPE_SWIZZLE;
        float tapCoC = SAMPLE_TEXTURE2D_X_LOD(_InputCoCTexture, sampler_LinearClamp, min(tapCoord * _CoCTargetScale.xy, maxCoordCoC), 0.0).x;

        float nearCoC = saturate(abs(min(tapCoC, 0.0)));
        nearColorAcc += tapColor;
        nearCoCAcc += nearCoC;

        // Pre-multiply CoC to reduce bleeding of background blur on focused areas
        float farCoC = saturate(tapCoC);
        farColorAcc += tapColor * farCoC;
        farCoCAcc += farCoC;
    }

    float div = rcp(float(kTapCount));

    nearCoCAcc *= div;
    nearColorAcc *= div;

    farCoCAcc *= div;
    farColorAcc *= div;

#endif

    // Note: the shader compiler will discard any unused ALU/TEX
#if NEAR
    _OutputNearTexture[COORD_TEXTURE2D_X(posInputs.positionSS)] = nearColorAcc;
    _OutputNearCoCTexture[COORD_TEXTURE2D_X(posInputs.positionSS)] = nearCoCAcc;
#endif

#if FAR
    _OutputFarTexture[COORD_TEXTURE2D_X(posInputs.positionSS)] = farColorAcc;
    _OutputFarCoCTexture[COORD_TEXTURE2D_X(posInputs.positionSS)] = farCoCAcc;
#endif
}
