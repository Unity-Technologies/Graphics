#pragma kernel CSVFXIndirectArgs

#include "HLSLSupport.cginc"

CBUFFER_START(Uniform)
	uint maxNb;
CBUFFER_END
 
#define NB_THREADS_PER_GROUP 64
#define NB_INDICES_PER_INSTANCE 2048

struct OutputData
{
	uint type;
	uint indexCount;
};

ByteAddressBuffer nbElements; // Filled by GPU
StructuredBuffer<OutputData> outputData; // Filled by CPU

RWBuffer<uint> output;

// Points
[numthreads(NB_THREADS_PER_GROUP,1,1)]
void CSVFXIndirectArgs(uint3 id : SV_DispatchThreadID)
{
	if (id.x < maxNb) 
	{
		uint indexCount = 0;
		uint instanceCount = 0;

		uint elementCount = nbElements.Load(id.x << 2);

		OutputData data = outputData[id.x];
		switch(data.type)
		{
			case 0: // point
			{
				indexCount = elementCount;
				instanceCount = 1;
				break;
			}
			
			case 1: // quads
			{
				if (elementCount > 16384) // Due to 16bits indices (4 vertices per element)
				{
					indexCount = NB_INDICES_PER_INSTANCE * 6;
					instanceCount = (elementCount + (NB_INDICES_PER_INSTANCE - 1)) / NB_INDICES_PER_INSTANCE;
				}
				else
				{
					indexCount = elementCount * 6;
					instanceCount = 1;
				}
				break;
			}

			case 2: // meshes
			{
				indexCount = data.indexCount;
				instanceCount = elementCount;
				break;
			}

			case 3: // hexahedron
			{
				// Version with hexahedron batched in index buffer
				if (elementCount > 8192) // Due to 16bits indices (8 vertices per element)
				{
					indexCount = NB_INDICES_PER_INSTANCE * 36;
					instanceCount = (elementCount + (NB_INDICES_PER_INSTANCE - 1)) / NB_INDICES_PER_INSTANCE;
				}
				else
				{
					indexCount = elementCount * 36;
					instanceCount = 1;
				}
				break;
			}
		}
		
		uint index = id.x * 5;
		output[index + 0] = indexCount;
		output[index + 1] = instanceCount;
		// 3 next uint (startIndex, BaseVertex and StartInstance) set to 0 at initialization
	}
}
