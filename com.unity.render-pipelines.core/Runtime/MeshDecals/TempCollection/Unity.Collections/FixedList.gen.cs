
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     TextTransform Samples/Packages/com.unity.collections/Unity.Collections/FixedList.tt
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Collections.Generic;
using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Mathematics;
using UnityEngine.Internal;
using UnityEngine;
#if UNITY_PROPERTIES_EXISTS
using Unity.Properties;
#endif

namespace Unity.Collections
{
    [BurstCompatible]
    struct FixedList
    {
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int) })]
        internal static int PaddingBytes<T>() where T : struct
        {
            return math.max(0, math.min(6, (1 << math.tzcnt(UnsafeUtility.SizeOf<T>())) - 2));
        }

        [BurstCompatible(GenericTypeArguments = new [] { typeof(int), typeof(int) })]
        internal static int StorageBytes<BUFFER,T>() where BUFFER : struct where T : struct
        {
            return UnsafeUtility.SizeOf<BUFFER>() - PaddingBytes<T>();
        }

        [BurstCompatible(GenericTypeArguments = new [] { typeof(int), typeof(int) })]
        internal static int Capacity<BUFFER,T>() where BUFFER : struct where T : struct
        {
            return StorageBytes<BUFFER,T>() / UnsafeUtility.SizeOf<T>();
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        internal static void CheckElementAccess(int index, int Length)
        {
            if (index < 0 || index >= Length)
                throw new IndexOutOfRangeException($"Index {index} is out of range of '{Length}' Length.");
        }

        [BurstCompatible(GenericTypeArguments = new [] { typeof(int), typeof(int) })]
        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        internal static void CheckResize<BUFFER,T>(int newLength) where BUFFER : struct where T : struct
        {
            var Capacity = Capacity<BUFFER,T>();
            if (newLength < 0 || newLength > Capacity)
                throw new IndexOutOfRangeException($"NewLength {newLength} is out of range of '{Capacity}' Capacity.");
        }
    }

    /// <summary>
    /// An unmanaged, resizable list that does not allocate memory.
    /// It is 32 bytes in size, and contains all the memory it needs.
    /// </summary>
    /// <typeparam name="T">The type of the elements in the container.</typeparam>
    [Serializable]
    [DebuggerTypeProxy(typeof(FixedList32DebugView<>))]
    [BurstCompatible(GenericTypeArguments = new [] { typeof(int) })]
    public struct FixedList32<T>
    : INativeList<T>
    , IEnumerable<T> // Used by collection initializers.
    , IEquatable<FixedList32<T>>
    , IComparable<FixedList32<T>>
    , IEquatable<FixedList64<T>>
    , IComparable<FixedList64<T>>
    , IEquatable<FixedList128<T>>
    , IComparable<FixedList128<T>>
    , IEquatable<FixedList512<T>>
    , IComparable<FixedList512<T>>
    , IEquatable<FixedList4096<T>>
    , IComparable<FixedList4096<T>>
    where T : unmanaged
    {
        [SerializeField] internal ushort length;
        [SerializeField] internal FixedBytes30 buffer;

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        [CreateProperty]
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize<FixedBytes30,T>(value);
                length = (ushort)value;
            }
        }

        /// <summary>
        /// A property in order to display items in the Entity Inspector.
        /// </summary>
        [CreateProperty] IEnumerable<T> Elements => this.ToArray();

        /// <summary>
        /// Reports whether container is empty.
        /// </summary>
        /// <value>True if this container empty.</value>
        public bool IsEmpty => Length == 0;

        internal int LengthInBytes => Length * UnsafeUtility.SizeOf<T>();

        unsafe internal byte* Buffer
        {
            get
            {
                fixed(byte* b = &buffer.offset0000.byte0000)
                    return b + FixedList.PaddingBytes<T>();
            }
        }

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity
        {
          get
          {
              return FixedList.Capacity<FixedBytes30,T>();
          }
          set
          {
              CheckCapacityInRange(value);
          }
        }

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public T this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    return UnsafeUtility.ReadArrayElement<T>(Buffer, CollectionHelper.AssumePositive(index));
                }
            }
            set
            {
                unsafe
                {
                    UnsafeUtility.WriteArrayElement<T>(Buffer, CollectionHelper.AssumePositive(index), value);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public ref T ElementAt(int index)
        {
            FixedList.CheckElementAccess(index, length);
            unsafe
            {
                return ref UnsafeUtility.ArrayElementAsRef<T>(Buffer, index);
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedList32&lt;T&gt;.
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                return (int)CollectionHelper.Hash(Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The T to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void Add(in T item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRange(void* ptr, int length)
        {
            T* data = (T*)ptr;
            for (var i = 0; i < length; ++i)
            {
                this[Length++] = data[i];
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The T to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void AddNoResize(in T item) => Add(item);

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRangeNoResize(void* ptr, int length) => AddRange(ptr, length);

        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }

        /// <summary>
        /// Inserts a number of items into a FixedList32&lt;T&gt; at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="end">The zero-based index just after where the elements should be removed.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void InsertRangeWithBeginEnd(int begin, int end)
        {
            int items = end - begin;
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * UnsafeUtility.SizeOf<T>();
            unsafe
            {
                byte *b = Buffer;
                byte *dest = b + end * UnsafeUtility.SizeOf<T>();
                byte *src = b + begin * UnsafeUtility.SizeOf<T>();
                UnsafeUtility.MemMove(dest, src, bytesToCopy);
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedList32&lt;T&gt; at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>
        public void Insert(int index, in T item)
        {
            InsertRangeWithBeginEnd(index, index+1);
            this[index] = item;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index with the last item in the list. The list
        /// is shortened by one.
        /// </summary>
        /// <param name="index">The index of the item to delete.</param>
        public void RemoveAtSwapBack(int index)
        {
            RemoveRangeSwapBackWithBeginEnd(index, index + 1);
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index range with the items from the end the list. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeSwapBackWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                int copyFrom = math.max(Length - itemsToRemove, end);

                unsafe
                {
                    var sizeOf = UnsafeUtility.SizeOf<T>();
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                }

                Length -= itemsToRemove;
            }
        }

        /// <summary>
        /// Truncates the list by removing the item at the specified index, and shifting all remaining items to replace removed item. The list
        /// is shortened by one.
        /// </summary>
        /// <param name="index">The index of the item to delete.</param>
        /// <remarks>
        /// This method of removing item is useful only in case when list is ordered and user wants to preserve order
        /// in list after removal In majority of cases is not important and user should use more performant `RemoveAtSwapBack`.
        /// </remarks>
        public void RemoveAt(int index)
        {
            RemoveRangeWithBeginEnd(index, index + 1);
        }

        /// <summary>
        /// Truncates the list by removing the items at the specified index range, and shifting all remaining items to replace removed items. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <remarks>
        /// This method of removing item(s) is useful only in case when list is ordered and user wants to preserve order
        /// in list after removal In majority of cases is not important and user should use more performant `RemoveRangeSwapBackWithBeginEnd`.
        /// </remarks>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                unsafe
                {
                    var sizeOf = UnsafeUtility.SizeOf<T>();
                    int copyFrom = math.min(begin + itemsToRemove, Length);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                    Length -= itemsToRemove;
                }
            }
        }

        /// <summary>
        /// Creates a managed Array of T that is a copy of this FixedList32&lt;T&gt;.
        /// </summary>
        /// <returns></returns>
        [NotBurstCompatible]
        public T[] ToArray()
        {
            var result = new T[Length];
            unsafe
            {
                byte* s = Buffer;
                fixed(T* d = result)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArray&lt;T&gt; that is a copy of this FixedList32&lt;T&gt;.
        /// </summary>
        /// <param name="allocator">A member of the
        /// [Unity.Collections.Allocator](https://docs.unity3d.com/ScriptReference/Unity.Collections.Allocator.html) enumeration.</param>
        /// <returns></returns>
        public NativeArray<T> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                var copy = new NativeArray<T>(Length, allocator, NativeArrayOptions.UninitializedMemory);
                UnsafeUtility.MemCpy(copy.GetUnsafePtr(), Buffer, LengthInBytes);
                return copy;
            }
        }


        /// <summary>
        /// Determines whether a FixedList32&lt;T&gt; and FixedList32&lt;T&gt; have the same value.
        /// </summary>
        /// <param name="a">The FixedList32&lt;T&gt; to compare for equality</param>
        /// <param name="b">The FixedList32&lt;T&gt; to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedList32<T> a, in FixedList32<T> b)
        {
            unsafe
            {
                if(a.length != b.length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedList32&lt;T&gt; and FixedList32&lt;T&gt; have different values.
        /// </summary>
        /// <param name="a">The FixedList32&lt;T&gt; to compare for inequality</param>
        /// <param name="b">The FixedList32&lt;T&gt; to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedList32<T> a, in FixedList32<T> b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedList32&lt;T&gt; and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedList32&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList32&lt;T&gt; to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedList32<T> other)
        {
            unsafe
            {
                fixed(byte* a = &buffer.offset0000.byte0000)
                {
                    byte* b = &other.buffer.offset0000.byte0000;
                    var aa = a + FixedList.PaddingBytes<T>();
                    var bb = b + FixedList.PaddingBytes<T>();
                    var mini = math.min(Length, other.Length);
                    for(var i = 0; i < mini; ++i)
                    {
                        var j = UnsafeUtility.MemCmp(aa + sizeof(T) * i, bb + sizeof(T) * i, sizeof(T));
                        if(j != 0)
                            return j;
                    }
                    return Length.CompareTo(other.Length);
                }
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedList32&lt;T&gt; and indicates whether this instance
        /// is equal to the specified FixedList32&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList32&lt;T&gt; to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedList32<T> other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Determines whether a FixedList32&lt;T&gt; and FixedList64&lt;T&gt; have the same value.
        /// </summary>
        /// <param name="a">The FixedList32&lt;T&gt; to compare for equality</param>
        /// <param name="b">The FixedList64&lt;T&gt; to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedList32<T> a, in FixedList64<T> b)
        {
            unsafe
            {
                if(a.length != b.length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedList32&lt;T&gt; and FixedList64&lt;T&gt; have different values.
        /// </summary>
        /// <param name="a">The FixedList32&lt;T&gt; to compare for inequality</param>
        /// <param name="b">The FixedList64&lt;T&gt; to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedList32<T> a, in FixedList64<T> b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedList64&lt;T&gt; and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedList64&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList64&lt;T&gt; to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedList64<T> other)
        {
            unsafe
            {
                fixed(byte* a = &buffer.offset0000.byte0000)
                {
                    byte* b = &other.buffer.offset0000.byte0000;
                    var aa = a + FixedList.PaddingBytes<T>();
                    var bb = b + FixedList.PaddingBytes<T>();
                    var mini = math.min(Length, other.Length);
                    for(var i = 0; i < mini; ++i)
                    {
                        var j = UnsafeUtility.MemCmp(aa + sizeof(T) * i, bb + sizeof(T) * i, sizeof(T));
                        if(j != 0)
                            return j;
                    }
                    return Length.CompareTo(other.Length);
                }
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedList64&lt;T&gt; and indicates whether this instance
        /// is equal to the specified FixedList64&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList64&lt;T&gt; to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedList64<T> other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedList32&lt;T&gt; that is a copy of a FixedList64&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList64&lt;T&gt; to copy</param>
        public FixedList32(in FixedList64<T> other)
        {
            FixedList.CheckResize<FixedBytes30,T>(other.length);
            length = other.length;
            buffer = new FixedBytes30();
            unsafe
            {
                UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Implicitly converts a FixedList64&lt;T&gt; to a FixedList32&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList64&lt;T&gt; to copy</param>
        /// <returns></returns>
        public static implicit operator FixedList32<T>(in FixedList64<T> other)
        {
            return new FixedList32<T>(other);
        }

        /// <summary>
        /// Determines whether a FixedList32&lt;T&gt; and FixedList128&lt;T&gt; have the same value.
        /// </summary>
        /// <param name="a">The FixedList32&lt;T&gt; to compare for equality</param>
        /// <param name="b">The FixedList128&lt;T&gt; to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedList32<T> a, in FixedList128<T> b)
        {
            unsafe
            {
                if(a.length != b.length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedList32&lt;T&gt; and FixedList128&lt;T&gt; have different values.
        /// </summary>
        /// <param name="a">The FixedList32&lt;T&gt; to compare for inequality</param>
        /// <param name="b">The FixedList128&lt;T&gt; to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedList32<T> a, in FixedList128<T> b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedList128&lt;T&gt; and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedList128&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList128&lt;T&gt; to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedList128<T> other)
        {
            unsafe
            {
                fixed(byte* a = &buffer.offset0000.byte0000)
                {
                    byte* b = &other.buffer.offset0000.byte0000;
                    var aa = a + FixedList.PaddingBytes<T>();
                    var bb = b + FixedList.PaddingBytes<T>();
                    var mini = math.min(Length, other.Length);
                    for(var i = 0; i < mini; ++i)
                    {
                        var j = UnsafeUtility.MemCmp(aa + sizeof(T) * i, bb + sizeof(T) * i, sizeof(T));
                        if(j != 0)
                            return j;
                    }
                    return Length.CompareTo(other.Length);
                }
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedList128&lt;T&gt; and indicates whether this instance
        /// is equal to the specified FixedList128&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList128&lt;T&gt; to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedList128<T> other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedList32&lt;T&gt; that is a copy of a FixedList128&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList128&lt;T&gt; to copy</param>
        public FixedList32(in FixedList128<T> other)
        {
            FixedList.CheckResize<FixedBytes30,T>(other.length);
            length = other.length;
            buffer = new FixedBytes30();
            unsafe
            {
                UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Implicitly converts a FixedList128&lt;T&gt; to a FixedList32&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList128&lt;T&gt; to copy</param>
        /// <returns></returns>
        public static implicit operator FixedList32<T>(in FixedList128<T> other)
        {
            return new FixedList32<T>(other);
        }

        /// <summary>
        /// Determines whether a FixedList32&lt;T&gt; and FixedList512&lt;T&gt; have the same value.
        /// </summary>
        /// <param name="a">The FixedList32&lt;T&gt; to compare for equality</param>
        /// <param name="b">The FixedList512&lt;T&gt; to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedList32<T> a, in FixedList512<T> b)
        {
            unsafe
            {
                if(a.length != b.length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedList32&lt;T&gt; and FixedList512&lt;T&gt; have different values.
        /// </summary>
        /// <param name="a">The FixedList32&lt;T&gt; to compare for inequality</param>
        /// <param name="b">The FixedList512&lt;T&gt; to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedList32<T> a, in FixedList512<T> b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedList512&lt;T&gt; and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedList512&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList512&lt;T&gt; to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedList512<T> other)
        {
            unsafe
            {
                fixed(byte* a = &buffer.offset0000.byte0000)
                {
                    byte* b = &other.buffer.offset0000.byte0000;
                    var aa = a + FixedList.PaddingBytes<T>();
                    var bb = b + FixedList.PaddingBytes<T>();
                    var mini = math.min(Length, other.Length);
                    for(var i = 0; i < mini; ++i)
                    {
                        var j = UnsafeUtility.MemCmp(aa + sizeof(T) * i, bb + sizeof(T) * i, sizeof(T));
                        if(j != 0)
                            return j;
                    }
                    return Length.CompareTo(other.Length);
                }
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedList512&lt;T&gt; and indicates whether this instance
        /// is equal to the specified FixedList512&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList512&lt;T&gt; to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedList512<T> other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedList32&lt;T&gt; that is a copy of a FixedList512&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList512&lt;T&gt; to copy</param>
        public FixedList32(in FixedList512<T> other)
        {
            FixedList.CheckResize<FixedBytes30,T>(other.length);
            length = other.length;
            buffer = new FixedBytes30();
            unsafe
            {
                UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Implicitly converts a FixedList512&lt;T&gt; to a FixedList32&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList512&lt;T&gt; to copy</param>
        /// <returns></returns>
        public static implicit operator FixedList32<T>(in FixedList512<T> other)
        {
            return new FixedList32<T>(other);
        }

        /// <summary>
        /// Determines whether a FixedList32&lt;T&gt; and FixedList4096&lt;T&gt; have the same value.
        /// </summary>
        /// <param name="a">The FixedList32&lt;T&gt; to compare for equality</param>
        /// <param name="b">The FixedList4096&lt;T&gt; to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedList32<T> a, in FixedList4096<T> b)
        {
            unsafe
            {
                if(a.length != b.length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedList32&lt;T&gt; and FixedList4096&lt;T&gt; have different values.
        /// </summary>
        /// <param name="a">The FixedList32&lt;T&gt; to compare for inequality</param>
        /// <param name="b">The FixedList4096&lt;T&gt; to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedList32<T> a, in FixedList4096<T> b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedList4096&lt;T&gt; and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedList4096&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList4096&lt;T&gt; to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedList4096<T> other)
        {
            unsafe
            {
                fixed(byte* a = &buffer.offset0000.byte0000)
                {
                    byte* b = &other.buffer.offset0000.byte0000;
                    var aa = a + FixedList.PaddingBytes<T>();
                    var bb = b + FixedList.PaddingBytes<T>();
                    var mini = math.min(Length, other.Length);
                    for(var i = 0; i < mini; ++i)
                    {
                        var j = UnsafeUtility.MemCmp(aa + sizeof(T) * i, bb + sizeof(T) * i, sizeof(T));
                        if(j != 0)
                            return j;
                    }
                    return Length.CompareTo(other.Length);
                }
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedList4096&lt;T&gt; and indicates whether this instance
        /// is equal to the specified FixedList4096&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList4096&lt;T&gt; to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedList4096<T> other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedList32&lt;T&gt; that is a copy of a FixedList4096&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList4096&lt;T&gt; to copy</param>
        public FixedList32(in FixedList4096<T> other)
        {
            FixedList.CheckResize<FixedBytes30,T>(other.length);
            length = other.length;
            buffer = new FixedBytes30();
            unsafe
            {
                UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Implicitly converts a FixedList4096&lt;T&gt; to a FixedList32&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList4096&lt;T&gt; to copy</param>
        /// <returns></returns>
        public static implicit operator FixedList32<T>(in FixedList4096<T> other)
        {
            return new FixedList32<T>(other);
        }

        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        /// <returns></returns>
        [NotBurstCompatible]
        public override bool Equals(object obj)
        {
            if(obj is FixedList32<T> aFixedList32) return Equals(aFixedList32);
            if(obj is FixedList64<T> aFixedList64) return Equals(aFixedList64);
            if(obj is FixedList128<T> aFixedList128) return Equals(aFixedList128);
            if(obj is FixedList512<T> aFixedList512) return Equals(aFixedList512);
            if(obj is FixedList4096<T> aFixedList4096) return Equals(aFixedList4096);
            return false;
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        public struct Enumerator : IEnumerator<T>
        {
            FixedList32<T> m_List;
            int m_Index;

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <param name="list"><undoc /></param>
            public Enumerator(ref FixedList32<T> list)
            {
                m_List = list;
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Dispose()
            {
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <returns><undoc /></returns>
            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Reset()
            {
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public T Current => m_List[m_Index]; // Let FixedList32<T> indexer check for out of range.

            object IEnumerator.Current => Current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator IEnumerable.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator<T> IEnumerable<T>.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckCapacityInRange(int capacity)
        {
            if(capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }
    }

    public unsafe static class FixedList32Extensions
    {
        /// <summary>
        /// Searches for the specified element in FixedList32&lt;T&gt;.
        /// </summary>
        /// <typeparam name="T">The type of values in the list.</typeparam>
        /// <typeparam name="U">The value type.</typeparam>
        /// <param name="list">List to perform search.</param>
        /// <param name="value">The value to locate.</param>
        /// <returns>The zero-based index of the first occurrence element if found, otherwise returns -1.</returns>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int), typeof(int) })]
        public static int IndexOf<T, U>(this ref FixedList32<T> list, U value) where T : unmanaged, IEquatable<U>
        {
            return NativeArrayExtensions.IndexOf<T, U>(list.Buffer, list.Length, value);
        }

        /// <summary>
        /// Determines whether an element is in the FixedList32&lt;T&gt;.
        /// </summary>
        /// <typeparam name="T">The type of values in the list.</typeparam>
        /// <typeparam name="U">The value type.</typeparam>
        /// <param name="list">List to perform search.</param>
        /// <param name="value">The value to locate.</param>
        /// <returns>True, if element is found.</returns>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int), typeof(int) })]
        public static bool Contains<T, U>(this ref FixedList32<T> list, U value) where T : unmanaged, IEquatable<U>
        {
            return list.IndexOf(value) != -1;
        }

        /// <summary>
        /// Searches for the specified item from the begining of the FixedList32 forward, removes it if possible,
        /// and returns true if the item was successfully removed.
        /// </summary>
        /// <param name="item">The item to locate in the FixedList32</param>
        /// <returns>True, if element is removed.</returns>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int), typeof(int) })]
        public static bool Remove<T, U>(this ref FixedList32<T> list, U value) where T : unmanaged, IEquatable<U>
        {
            int index = list.IndexOf(value);
            if (index < 0)
            {
                return false;
            }

            list.RemoveAt(index);

            return true;
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedList32&lt;T&gt; and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedList32&lt;T&gt;.</param>
        /// <returns>Returns true if item is removed.</returns>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int), typeof(int) })]
        public static bool RemoveSwapBack<T, U>(this ref FixedList32<T> list, U value) where T : unmanaged, IEquatable<U>
        {
            var index = list.IndexOf(value);
            if (index == -1)
            {
                return false;
            }

            list.RemoveAtSwapBack(index);

            return true;
        }
    }

    sealed class FixedList32DebugView<T> where T : unmanaged
    {
        FixedList32<T> m_List;
        public FixedList32DebugView(FixedList32<T> list)
        {
            m_List = list;
        }
        public T[] Items => m_List.ToArray();
    }
    /// <summary>
    /// An unmanaged, resizable list that does not allocate memory.
    /// It is 64 bytes in size, and contains all the memory it needs.
    /// </summary>
    /// <typeparam name="T">The type of the elements in the container.</typeparam>
    [Serializable]
    [DebuggerTypeProxy(typeof(FixedList64DebugView<>))]
    [BurstCompatible(GenericTypeArguments = new [] { typeof(int) })]
    public struct FixedList64<T>
    : INativeList<T>
    , IEnumerable<T> // Used by collection initializers.
    , IEquatable<FixedList32<T>>
    , IComparable<FixedList32<T>>
    , IEquatable<FixedList64<T>>
    , IComparable<FixedList64<T>>
    , IEquatable<FixedList128<T>>
    , IComparable<FixedList128<T>>
    , IEquatable<FixedList512<T>>
    , IComparable<FixedList512<T>>
    , IEquatable<FixedList4096<T>>
    , IComparable<FixedList4096<T>>
    where T : unmanaged
    {
        [SerializeField] internal ushort length;
        [SerializeField] internal FixedBytes62 buffer;

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        [CreateProperty]
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize<FixedBytes62,T>(value);
                length = (ushort)value;
            }
        }

        /// <summary>
        /// A property in order to display items in the Entity Inspector.
        /// </summary>
        [CreateProperty] IEnumerable<T> Elements => this.ToArray();

        /// <summary>
        /// Reports whether container is empty.
        /// </summary>
        /// <value>True if this container empty.</value>
        public bool IsEmpty => Length == 0;

        internal int LengthInBytes => Length * UnsafeUtility.SizeOf<T>();

        unsafe internal byte* Buffer
        {
            get
            {
                fixed(byte* b = &buffer.offset0000.byte0000)
                    return b + FixedList.PaddingBytes<T>();
            }
        }

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity
        {
          get
          {
              return FixedList.Capacity<FixedBytes62,T>();
          }
          set
          {
              CheckCapacityInRange(value);
          }
        }

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public T this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    return UnsafeUtility.ReadArrayElement<T>(Buffer, CollectionHelper.AssumePositive(index));
                }
            }
            set
            {
                unsafe
                {
                    UnsafeUtility.WriteArrayElement<T>(Buffer, CollectionHelper.AssumePositive(index), value);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public ref T ElementAt(int index)
        {
            FixedList.CheckElementAccess(index, length);
            unsafe
            {
                return ref UnsafeUtility.ArrayElementAsRef<T>(Buffer, index);
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedList64&lt;T&gt;.
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                return (int)CollectionHelper.Hash(Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The T to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void Add(in T item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRange(void* ptr, int length)
        {
            T* data = (T*)ptr;
            for (var i = 0; i < length; ++i)
            {
                this[Length++] = data[i];
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The T to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void AddNoResize(in T item) => Add(item);

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRangeNoResize(void* ptr, int length) => AddRange(ptr, length);

        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }

        /// <summary>
        /// Inserts a number of items into a FixedList64&lt;T&gt; at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="end">The zero-based index just after where the elements should be removed.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void InsertRangeWithBeginEnd(int begin, int end)
        {
            int items = end - begin;
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * UnsafeUtility.SizeOf<T>();
            unsafe
            {
                byte *b = Buffer;
                byte *dest = b + end * UnsafeUtility.SizeOf<T>();
                byte *src = b + begin * UnsafeUtility.SizeOf<T>();
                UnsafeUtility.MemMove(dest, src, bytesToCopy);
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedList64&lt;T&gt; at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>
        public void Insert(int index, in T item)
        {
            InsertRangeWithBeginEnd(index, index+1);
            this[index] = item;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index with the last item in the list. The list
        /// is shortened by one.
        /// </summary>
        /// <param name="index">The index of the item to delete.</param>
        public void RemoveAtSwapBack(int index)
        {
            RemoveRangeSwapBackWithBeginEnd(index, index + 1);
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index range with the items from the end the list. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeSwapBackWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                int copyFrom = math.max(Length - itemsToRemove, end);

                unsafe
                {
                    var sizeOf = UnsafeUtility.SizeOf<T>();
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                }

                Length -= itemsToRemove;
            }
        }

        /// <summary>
        /// Truncates the list by removing the item at the specified index, and shifting all remaining items to replace removed item. The list
        /// is shortened by one.
        /// </summary>
        /// <param name="index">The index of the item to delete.</param>
        /// <remarks>
        /// This method of removing item is useful only in case when list is ordered and user wants to preserve order
        /// in list after removal In majority of cases is not important and user should use more performant `RemoveAtSwapBack`.
        /// </remarks>
        public void RemoveAt(int index)
        {
            RemoveRangeWithBeginEnd(index, index + 1);
        }

        /// <summary>
        /// Truncates the list by removing the items at the specified index range, and shifting all remaining items to replace removed items. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <remarks>
        /// This method of removing item(s) is useful only in case when list is ordered and user wants to preserve order
        /// in list after removal In majority of cases is not important and user should use more performant `RemoveRangeSwapBackWithBeginEnd`.
        /// </remarks>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                unsafe
                {
                    var sizeOf = UnsafeUtility.SizeOf<T>();
                    int copyFrom = math.min(begin + itemsToRemove, Length);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                    Length -= itemsToRemove;
                }
            }
        }

        /// <summary>
        /// Creates a managed Array of T that is a copy of this FixedList64&lt;T&gt;.
        /// </summary>
        /// <returns></returns>
        [NotBurstCompatible]
        public T[] ToArray()
        {
            var result = new T[Length];
            unsafe
            {
                byte* s = Buffer;
                fixed(T* d = result)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArray&lt;T&gt; that is a copy of this FixedList64&lt;T&gt;.
        /// </summary>
        /// <param name="allocator">A member of the
        /// [Unity.Collections.Allocator](https://docs.unity3d.com/ScriptReference/Unity.Collections.Allocator.html) enumeration.</param>
        /// <returns></returns>
        public NativeArray<T> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                var copy = new NativeArray<T>(Length, allocator, NativeArrayOptions.UninitializedMemory);
                UnsafeUtility.MemCpy(copy.GetUnsafePtr(), Buffer, LengthInBytes);
                return copy;
            }
        }


        /// <summary>
        /// Determines whether a FixedList64&lt;T&gt; and FixedList32&lt;T&gt; have the same value.
        /// </summary>
        /// <param name="a">The FixedList64&lt;T&gt; to compare for equality</param>
        /// <param name="b">The FixedList32&lt;T&gt; to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedList64<T> a, in FixedList32<T> b)
        {
            unsafe
            {
                if(a.length != b.length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedList64&lt;T&gt; and FixedList32&lt;T&gt; have different values.
        /// </summary>
        /// <param name="a">The FixedList64&lt;T&gt; to compare for inequality</param>
        /// <param name="b">The FixedList32&lt;T&gt; to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedList64<T> a, in FixedList32<T> b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedList32&lt;T&gt; and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedList32&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList32&lt;T&gt; to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedList32<T> other)
        {
            unsafe
            {
                fixed(byte* a = &buffer.offset0000.byte0000)
                {
                    byte* b = &other.buffer.offset0000.byte0000;
                    var aa = a + FixedList.PaddingBytes<T>();
                    var bb = b + FixedList.PaddingBytes<T>();
                    var mini = math.min(Length, other.Length);
                    for(var i = 0; i < mini; ++i)
                    {
                        var j = UnsafeUtility.MemCmp(aa + sizeof(T) * i, bb + sizeof(T) * i, sizeof(T));
                        if(j != 0)
                            return j;
                    }
                    return Length.CompareTo(other.Length);
                }
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedList32&lt;T&gt; and indicates whether this instance
        /// is equal to the specified FixedList32&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList32&lt;T&gt; to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedList32<T> other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedList64&lt;T&gt; that is a copy of a FixedList32&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList32&lt;T&gt; to copy</param>
        public FixedList64(in FixedList32<T> other)
        {
            FixedList.CheckResize<FixedBytes62,T>(other.length);
            length = other.length;
            buffer = new FixedBytes62();
            unsafe
            {
                UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Implicitly converts a FixedList32&lt;T&gt; to a FixedList64&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList32&lt;T&gt; to copy</param>
        /// <returns></returns>
        public static implicit operator FixedList64<T>(in FixedList32<T> other)
        {
            return new FixedList64<T>(other);
        }

        /// <summary>
        /// Determines whether a FixedList64&lt;T&gt; and FixedList64&lt;T&gt; have the same value.
        /// </summary>
        /// <param name="a">The FixedList64&lt;T&gt; to compare for equality</param>
        /// <param name="b">The FixedList64&lt;T&gt; to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedList64<T> a, in FixedList64<T> b)
        {
            unsafe
            {
                if(a.length != b.length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedList64&lt;T&gt; and FixedList64&lt;T&gt; have different values.
        /// </summary>
        /// <param name="a">The FixedList64&lt;T&gt; to compare for inequality</param>
        /// <param name="b">The FixedList64&lt;T&gt; to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedList64<T> a, in FixedList64<T> b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedList64&lt;T&gt; and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedList64&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList64&lt;T&gt; to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedList64<T> other)
        {
            unsafe
            {
                fixed(byte* a = &buffer.offset0000.byte0000)
                {
                    byte* b = &other.buffer.offset0000.byte0000;
                    var aa = a + FixedList.PaddingBytes<T>();
                    var bb = b + FixedList.PaddingBytes<T>();
                    var mini = math.min(Length, other.Length);
                    for(var i = 0; i < mini; ++i)
                    {
                        var j = UnsafeUtility.MemCmp(aa + sizeof(T) * i, bb + sizeof(T) * i, sizeof(T));
                        if(j != 0)
                            return j;
                    }
                    return Length.CompareTo(other.Length);
                }
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedList64&lt;T&gt; and indicates whether this instance
        /// is equal to the specified FixedList64&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList64&lt;T&gt; to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedList64<T> other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Determines whether a FixedList64&lt;T&gt; and FixedList128&lt;T&gt; have the same value.
        /// </summary>
        /// <param name="a">The FixedList64&lt;T&gt; to compare for equality</param>
        /// <param name="b">The FixedList128&lt;T&gt; to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedList64<T> a, in FixedList128<T> b)
        {
            unsafe
            {
                if(a.length != b.length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedList64&lt;T&gt; and FixedList128&lt;T&gt; have different values.
        /// </summary>
        /// <param name="a">The FixedList64&lt;T&gt; to compare for inequality</param>
        /// <param name="b">The FixedList128&lt;T&gt; to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedList64<T> a, in FixedList128<T> b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedList128&lt;T&gt; and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedList128&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList128&lt;T&gt; to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedList128<T> other)
        {
            unsafe
            {
                fixed(byte* a = &buffer.offset0000.byte0000)
                {
                    byte* b = &other.buffer.offset0000.byte0000;
                    var aa = a + FixedList.PaddingBytes<T>();
                    var bb = b + FixedList.PaddingBytes<T>();
                    var mini = math.min(Length, other.Length);
                    for(var i = 0; i < mini; ++i)
                    {
                        var j = UnsafeUtility.MemCmp(aa + sizeof(T) * i, bb + sizeof(T) * i, sizeof(T));
                        if(j != 0)
                            return j;
                    }
                    return Length.CompareTo(other.Length);
                }
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedList128&lt;T&gt; and indicates whether this instance
        /// is equal to the specified FixedList128&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList128&lt;T&gt; to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedList128<T> other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedList64&lt;T&gt; that is a copy of a FixedList128&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList128&lt;T&gt; to copy</param>
        public FixedList64(in FixedList128<T> other)
        {
            FixedList.CheckResize<FixedBytes62,T>(other.length);
            length = other.length;
            buffer = new FixedBytes62();
            unsafe
            {
                UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Implicitly converts a FixedList128&lt;T&gt; to a FixedList64&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList128&lt;T&gt; to copy</param>
        /// <returns></returns>
        public static implicit operator FixedList64<T>(in FixedList128<T> other)
        {
            return new FixedList64<T>(other);
        }

        /// <summary>
        /// Determines whether a FixedList64&lt;T&gt; and FixedList512&lt;T&gt; have the same value.
        /// </summary>
        /// <param name="a">The FixedList64&lt;T&gt; to compare for equality</param>
        /// <param name="b">The FixedList512&lt;T&gt; to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedList64<T> a, in FixedList512<T> b)
        {
            unsafe
            {
                if(a.length != b.length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedList64&lt;T&gt; and FixedList512&lt;T&gt; have different values.
        /// </summary>
        /// <param name="a">The FixedList64&lt;T&gt; to compare for inequality</param>
        /// <param name="b">The FixedList512&lt;T&gt; to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedList64<T> a, in FixedList512<T> b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedList512&lt;T&gt; and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedList512&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList512&lt;T&gt; to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedList512<T> other)
        {
            unsafe
            {
                fixed(byte* a = &buffer.offset0000.byte0000)
                {
                    byte* b = &other.buffer.offset0000.byte0000;
                    var aa = a + FixedList.PaddingBytes<T>();
                    var bb = b + FixedList.PaddingBytes<T>();
                    var mini = math.min(Length, other.Length);
                    for(var i = 0; i < mini; ++i)
                    {
                        var j = UnsafeUtility.MemCmp(aa + sizeof(T) * i, bb + sizeof(T) * i, sizeof(T));
                        if(j != 0)
                            return j;
                    }
                    return Length.CompareTo(other.Length);
                }
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedList512&lt;T&gt; and indicates whether this instance
        /// is equal to the specified FixedList512&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList512&lt;T&gt; to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedList512<T> other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedList64&lt;T&gt; that is a copy of a FixedList512&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList512&lt;T&gt; to copy</param>
        public FixedList64(in FixedList512<T> other)
        {
            FixedList.CheckResize<FixedBytes62,T>(other.length);
            length = other.length;
            buffer = new FixedBytes62();
            unsafe
            {
                UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Implicitly converts a FixedList512&lt;T&gt; to a FixedList64&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList512&lt;T&gt; to copy</param>
        /// <returns></returns>
        public static implicit operator FixedList64<T>(in FixedList512<T> other)
        {
            return new FixedList64<T>(other);
        }

        /// <summary>
        /// Determines whether a FixedList64&lt;T&gt; and FixedList4096&lt;T&gt; have the same value.
        /// </summary>
        /// <param name="a">The FixedList64&lt;T&gt; to compare for equality</param>
        /// <param name="b">The FixedList4096&lt;T&gt; to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedList64<T> a, in FixedList4096<T> b)
        {
            unsafe
            {
                if(a.length != b.length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedList64&lt;T&gt; and FixedList4096&lt;T&gt; have different values.
        /// </summary>
        /// <param name="a">The FixedList64&lt;T&gt; to compare for inequality</param>
        /// <param name="b">The FixedList4096&lt;T&gt; to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedList64<T> a, in FixedList4096<T> b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedList4096&lt;T&gt; and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedList4096&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList4096&lt;T&gt; to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedList4096<T> other)
        {
            unsafe
            {
                fixed(byte* a = &buffer.offset0000.byte0000)
                {
                    byte* b = &other.buffer.offset0000.byte0000;
                    var aa = a + FixedList.PaddingBytes<T>();
                    var bb = b + FixedList.PaddingBytes<T>();
                    var mini = math.min(Length, other.Length);
                    for(var i = 0; i < mini; ++i)
                    {
                        var j = UnsafeUtility.MemCmp(aa + sizeof(T) * i, bb + sizeof(T) * i, sizeof(T));
                        if(j != 0)
                            return j;
                    }
                    return Length.CompareTo(other.Length);
                }
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedList4096&lt;T&gt; and indicates whether this instance
        /// is equal to the specified FixedList4096&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList4096&lt;T&gt; to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedList4096<T> other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedList64&lt;T&gt; that is a copy of a FixedList4096&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList4096&lt;T&gt; to copy</param>
        public FixedList64(in FixedList4096<T> other)
        {
            FixedList.CheckResize<FixedBytes62,T>(other.length);
            length = other.length;
            buffer = new FixedBytes62();
            unsafe
            {
                UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Implicitly converts a FixedList4096&lt;T&gt; to a FixedList64&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList4096&lt;T&gt; to copy</param>
        /// <returns></returns>
        public static implicit operator FixedList64<T>(in FixedList4096<T> other)
        {
            return new FixedList64<T>(other);
        }

        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        /// <returns></returns>
        [NotBurstCompatible]
        public override bool Equals(object obj)
        {
            if(obj is FixedList32<T> aFixedList32) return Equals(aFixedList32);
            if(obj is FixedList64<T> aFixedList64) return Equals(aFixedList64);
            if(obj is FixedList128<T> aFixedList128) return Equals(aFixedList128);
            if(obj is FixedList512<T> aFixedList512) return Equals(aFixedList512);
            if(obj is FixedList4096<T> aFixedList4096) return Equals(aFixedList4096);
            return false;
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        public struct Enumerator : IEnumerator<T>
        {
            FixedList64<T> m_List;
            int m_Index;

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <param name="list"><undoc /></param>
            public Enumerator(ref FixedList64<T> list)
            {
                m_List = list;
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Dispose()
            {
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <returns><undoc /></returns>
            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Reset()
            {
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public T Current => m_List[m_Index]; // Let FixedList64<T> indexer check for out of range.

            object IEnumerator.Current => Current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator IEnumerable.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator<T> IEnumerable<T>.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckCapacityInRange(int capacity)
        {
            if(capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }
    }

    public unsafe static class FixedList64Extensions
    {
        /// <summary>
        /// Searches for the specified element in FixedList64&lt;T&gt;.
        /// </summary>
        /// <typeparam name="T">The type of values in the list.</typeparam>
        /// <typeparam name="U">The value type.</typeparam>
        /// <param name="list">List to perform search.</param>
        /// <param name="value">The value to locate.</param>
        /// <returns>The zero-based index of the first occurrence element if found, otherwise returns -1.</returns>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int), typeof(int) })]
        public static int IndexOf<T, U>(this ref FixedList64<T> list, U value) where T : unmanaged, IEquatable<U>
        {
            return NativeArrayExtensions.IndexOf<T, U>(list.Buffer, list.Length, value);
        }

        /// <summary>
        /// Determines whether an element is in the FixedList64&lt;T&gt;.
        /// </summary>
        /// <typeparam name="T">The type of values in the list.</typeparam>
        /// <typeparam name="U">The value type.</typeparam>
        /// <param name="list">List to perform search.</param>
        /// <param name="value">The value to locate.</param>
        /// <returns>True, if element is found.</returns>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int), typeof(int) })]
        public static bool Contains<T, U>(this ref FixedList64<T> list, U value) where T : unmanaged, IEquatable<U>
        {
            return list.IndexOf(value) != -1;
        }

        /// <summary>
        /// Searches for the specified item from the begining of the FixedList64 forward, removes it if possible,
        /// and returns true if the item was successfully removed.
        /// </summary>
        /// <param name="item">The item to locate in the FixedList64</param>
        /// <returns>True, if element is removed.</returns>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int), typeof(int) })]
        public static bool Remove<T, U>(this ref FixedList64<T> list, U value) where T : unmanaged, IEquatable<U>
        {
            int index = list.IndexOf(value);
            if (index < 0)
            {
                return false;
            }

            list.RemoveAt(index);

            return true;
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedList64&lt;T&gt; and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedList64&lt;T&gt;.</param>
        /// <returns>Returns true if item is removed.</returns>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int), typeof(int) })]
        public static bool RemoveSwapBack<T, U>(this ref FixedList64<T> list, U value) where T : unmanaged, IEquatable<U>
        {
            var index = list.IndexOf(value);
            if (index == -1)
            {
                return false;
            }

            list.RemoveAtSwapBack(index);

            return true;
        }
    }

    sealed class FixedList64DebugView<T> where T : unmanaged
    {
        FixedList64<T> m_List;
        public FixedList64DebugView(FixedList64<T> list)
        {
            m_List = list;
        }
        public T[] Items => m_List.ToArray();
    }
    /// <summary>
    /// An unmanaged, resizable list that does not allocate memory.
    /// It is 128 bytes in size, and contains all the memory it needs.
    /// </summary>
    /// <typeparam name="T">The type of the elements in the container.</typeparam>
    [Serializable]
    [DebuggerTypeProxy(typeof(FixedList128DebugView<>))]
    [BurstCompatible(GenericTypeArguments = new [] { typeof(int) })]
    public struct FixedList128<T>
    : INativeList<T>
    , IEnumerable<T> // Used by collection initializers.
    , IEquatable<FixedList32<T>>
    , IComparable<FixedList32<T>>
    , IEquatable<FixedList64<T>>
    , IComparable<FixedList64<T>>
    , IEquatable<FixedList128<T>>
    , IComparable<FixedList128<T>>
    , IEquatable<FixedList512<T>>
    , IComparable<FixedList512<T>>
    , IEquatable<FixedList4096<T>>
    , IComparable<FixedList4096<T>>
    where T : unmanaged
    {
        [SerializeField] internal ushort length;
        [SerializeField] internal FixedBytes126 buffer;

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        [CreateProperty]
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize<FixedBytes126,T>(value);
                length = (ushort)value;
            }
        }

        /// <summary>
        /// A property in order to display items in the Entity Inspector.
        /// </summary>
        [CreateProperty] IEnumerable<T> Elements => this.ToArray();

        /// <summary>
        /// Reports whether container is empty.
        /// </summary>
        /// <value>True if this container empty.</value>
        public bool IsEmpty => Length == 0;

        internal int LengthInBytes => Length * UnsafeUtility.SizeOf<T>();

        unsafe internal byte* Buffer
        {
            get
            {
                fixed(byte* b = &buffer.offset0000.byte0000)
                    return b + FixedList.PaddingBytes<T>();
            }
        }

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity
        {
          get
          {
              return FixedList.Capacity<FixedBytes126,T>();
          }
          set
          {
              CheckCapacityInRange(value);
          }
        }

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public T this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    return UnsafeUtility.ReadArrayElement<T>(Buffer, CollectionHelper.AssumePositive(index));
                }
            }
            set
            {
                unsafe
                {
                    UnsafeUtility.WriteArrayElement<T>(Buffer, CollectionHelper.AssumePositive(index), value);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public ref T ElementAt(int index)
        {
            FixedList.CheckElementAccess(index, length);
            unsafe
            {
                return ref UnsafeUtility.ArrayElementAsRef<T>(Buffer, index);
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedList128&lt;T&gt;.
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                return (int)CollectionHelper.Hash(Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The T to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void Add(in T item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRange(void* ptr, int length)
        {
            T* data = (T*)ptr;
            for (var i = 0; i < length; ++i)
            {
                this[Length++] = data[i];
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The T to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void AddNoResize(in T item) => Add(item);

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRangeNoResize(void* ptr, int length) => AddRange(ptr, length);

        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }

        /// <summary>
        /// Inserts a number of items into a FixedList128&lt;T&gt; at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="end">The zero-based index just after where the elements should be removed.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void InsertRangeWithBeginEnd(int begin, int end)
        {
            int items = end - begin;
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * UnsafeUtility.SizeOf<T>();
            unsafe
            {
                byte *b = Buffer;
                byte *dest = b + end * UnsafeUtility.SizeOf<T>();
                byte *src = b + begin * UnsafeUtility.SizeOf<T>();
                UnsafeUtility.MemMove(dest, src, bytesToCopy);
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedList128&lt;T&gt; at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>
        public void Insert(int index, in T item)
        {
            InsertRangeWithBeginEnd(index, index+1);
            this[index] = item;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index with the last item in the list. The list
        /// is shortened by one.
        /// </summary>
        /// <param name="index">The index of the item to delete.</param>
        public void RemoveAtSwapBack(int index)
        {
            RemoveRangeSwapBackWithBeginEnd(index, index + 1);
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index range with the items from the end the list. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeSwapBackWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                int copyFrom = math.max(Length - itemsToRemove, end);

                unsafe
                {
                    var sizeOf = UnsafeUtility.SizeOf<T>();
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                }

                Length -= itemsToRemove;
            }
        }

        /// <summary>
        /// Truncates the list by removing the item at the specified index, and shifting all remaining items to replace removed item. The list
        /// is shortened by one.
        /// </summary>
        /// <param name="index">The index of the item to delete.</param>
        /// <remarks>
        /// This method of removing item is useful only in case when list is ordered and user wants to preserve order
        /// in list after removal In majority of cases is not important and user should use more performant `RemoveAtSwapBack`.
        /// </remarks>
        public void RemoveAt(int index)
        {
            RemoveRangeWithBeginEnd(index, index + 1);
        }

        /// <summary>
        /// Truncates the list by removing the items at the specified index range, and shifting all remaining items to replace removed items. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <remarks>
        /// This method of removing item(s) is useful only in case when list is ordered and user wants to preserve order
        /// in list after removal In majority of cases is not important and user should use more performant `RemoveRangeSwapBackWithBeginEnd`.
        /// </remarks>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                unsafe
                {
                    var sizeOf = UnsafeUtility.SizeOf<T>();
                    int copyFrom = math.min(begin + itemsToRemove, Length);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                    Length -= itemsToRemove;
                }
            }
        }

        /// <summary>
        /// Creates a managed Array of T that is a copy of this FixedList128&lt;T&gt;.
        /// </summary>
        /// <returns></returns>
        [NotBurstCompatible]
        public T[] ToArray()
        {
            var result = new T[Length];
            unsafe
            {
                byte* s = Buffer;
                fixed(T* d = result)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArray&lt;T&gt; that is a copy of this FixedList128&lt;T&gt;.
        /// </summary>
        /// <param name="allocator">A member of the
        /// [Unity.Collections.Allocator](https://docs.unity3d.com/ScriptReference/Unity.Collections.Allocator.html) enumeration.</param>
        /// <returns></returns>
        public NativeArray<T> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                var copy = new NativeArray<T>(Length, allocator, NativeArrayOptions.UninitializedMemory);
                UnsafeUtility.MemCpy(copy.GetUnsafePtr(), Buffer, LengthInBytes);
                return copy;
            }
        }


        /// <summary>
        /// Determines whether a FixedList128&lt;T&gt; and FixedList32&lt;T&gt; have the same value.
        /// </summary>
        /// <param name="a">The FixedList128&lt;T&gt; to compare for equality</param>
        /// <param name="b">The FixedList32&lt;T&gt; to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedList128<T> a, in FixedList32<T> b)
        {
            unsafe
            {
                if(a.length != b.length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedList128&lt;T&gt; and FixedList32&lt;T&gt; have different values.
        /// </summary>
        /// <param name="a">The FixedList128&lt;T&gt; to compare for inequality</param>
        /// <param name="b">The FixedList32&lt;T&gt; to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedList128<T> a, in FixedList32<T> b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedList32&lt;T&gt; and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedList32&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList32&lt;T&gt; to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedList32<T> other)
        {
            unsafe
            {
                fixed(byte* a = &buffer.offset0000.byte0000)
                {
                    byte* b = &other.buffer.offset0000.byte0000;
                    var aa = a + FixedList.PaddingBytes<T>();
                    var bb = b + FixedList.PaddingBytes<T>();
                    var mini = math.min(Length, other.Length);
                    for(var i = 0; i < mini; ++i)
                    {
                        var j = UnsafeUtility.MemCmp(aa + sizeof(T) * i, bb + sizeof(T) * i, sizeof(T));
                        if(j != 0)
                            return j;
                    }
                    return Length.CompareTo(other.Length);
                }
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedList32&lt;T&gt; and indicates whether this instance
        /// is equal to the specified FixedList32&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList32&lt;T&gt; to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedList32<T> other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedList128&lt;T&gt; that is a copy of a FixedList32&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList32&lt;T&gt; to copy</param>
        public FixedList128(in FixedList32<T> other)
        {
            FixedList.CheckResize<FixedBytes126,T>(other.length);
            length = other.length;
            buffer = new FixedBytes126();
            unsafe
            {
                UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Implicitly converts a FixedList32&lt;T&gt; to a FixedList128&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList32&lt;T&gt; to copy</param>
        /// <returns></returns>
        public static implicit operator FixedList128<T>(in FixedList32<T> other)
        {
            return new FixedList128<T>(other);
        }

        /// <summary>
        /// Determines whether a FixedList128&lt;T&gt; and FixedList64&lt;T&gt; have the same value.
        /// </summary>
        /// <param name="a">The FixedList128&lt;T&gt; to compare for equality</param>
        /// <param name="b">The FixedList64&lt;T&gt; to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedList128<T> a, in FixedList64<T> b)
        {
            unsafe
            {
                if(a.length != b.length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedList128&lt;T&gt; and FixedList64&lt;T&gt; have different values.
        /// </summary>
        /// <param name="a">The FixedList128&lt;T&gt; to compare for inequality</param>
        /// <param name="b">The FixedList64&lt;T&gt; to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedList128<T> a, in FixedList64<T> b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedList64&lt;T&gt; and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedList64&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList64&lt;T&gt; to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedList64<T> other)
        {
            unsafe
            {
                fixed(byte* a = &buffer.offset0000.byte0000)
                {
                    byte* b = &other.buffer.offset0000.byte0000;
                    var aa = a + FixedList.PaddingBytes<T>();
                    var bb = b + FixedList.PaddingBytes<T>();
                    var mini = math.min(Length, other.Length);
                    for(var i = 0; i < mini; ++i)
                    {
                        var j = UnsafeUtility.MemCmp(aa + sizeof(T) * i, bb + sizeof(T) * i, sizeof(T));
                        if(j != 0)
                            return j;
                    }
                    return Length.CompareTo(other.Length);
                }
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedList64&lt;T&gt; and indicates whether this instance
        /// is equal to the specified FixedList64&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList64&lt;T&gt; to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedList64<T> other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedList128&lt;T&gt; that is a copy of a FixedList64&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList64&lt;T&gt; to copy</param>
        public FixedList128(in FixedList64<T> other)
        {
            FixedList.CheckResize<FixedBytes126,T>(other.length);
            length = other.length;
            buffer = new FixedBytes126();
            unsafe
            {
                UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Implicitly converts a FixedList64&lt;T&gt; to a FixedList128&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList64&lt;T&gt; to copy</param>
        /// <returns></returns>
        public static implicit operator FixedList128<T>(in FixedList64<T> other)
        {
            return new FixedList128<T>(other);
        }

        /// <summary>
        /// Determines whether a FixedList128&lt;T&gt; and FixedList128&lt;T&gt; have the same value.
        /// </summary>
        /// <param name="a">The FixedList128&lt;T&gt; to compare for equality</param>
        /// <param name="b">The FixedList128&lt;T&gt; to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedList128<T> a, in FixedList128<T> b)
        {
            unsafe
            {
                if(a.length != b.length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedList128&lt;T&gt; and FixedList128&lt;T&gt; have different values.
        /// </summary>
        /// <param name="a">The FixedList128&lt;T&gt; to compare for inequality</param>
        /// <param name="b">The FixedList128&lt;T&gt; to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedList128<T> a, in FixedList128<T> b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedList128&lt;T&gt; and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedList128&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList128&lt;T&gt; to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedList128<T> other)
        {
            unsafe
            {
                fixed(byte* a = &buffer.offset0000.byte0000)
                {
                    byte* b = &other.buffer.offset0000.byte0000;
                    var aa = a + FixedList.PaddingBytes<T>();
                    var bb = b + FixedList.PaddingBytes<T>();
                    var mini = math.min(Length, other.Length);
                    for(var i = 0; i < mini; ++i)
                    {
                        var j = UnsafeUtility.MemCmp(aa + sizeof(T) * i, bb + sizeof(T) * i, sizeof(T));
                        if(j != 0)
                            return j;
                    }
                    return Length.CompareTo(other.Length);
                }
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedList128&lt;T&gt; and indicates whether this instance
        /// is equal to the specified FixedList128&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList128&lt;T&gt; to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedList128<T> other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Determines whether a FixedList128&lt;T&gt; and FixedList512&lt;T&gt; have the same value.
        /// </summary>
        /// <param name="a">The FixedList128&lt;T&gt; to compare for equality</param>
        /// <param name="b">The FixedList512&lt;T&gt; to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedList128<T> a, in FixedList512<T> b)
        {
            unsafe
            {
                if(a.length != b.length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedList128&lt;T&gt; and FixedList512&lt;T&gt; have different values.
        /// </summary>
        /// <param name="a">The FixedList128&lt;T&gt; to compare for inequality</param>
        /// <param name="b">The FixedList512&lt;T&gt; to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedList128<T> a, in FixedList512<T> b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedList512&lt;T&gt; and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedList512&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList512&lt;T&gt; to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedList512<T> other)
        {
            unsafe
            {
                fixed(byte* a = &buffer.offset0000.byte0000)
                {
                    byte* b = &other.buffer.offset0000.byte0000;
                    var aa = a + FixedList.PaddingBytes<T>();
                    var bb = b + FixedList.PaddingBytes<T>();
                    var mini = math.min(Length, other.Length);
                    for(var i = 0; i < mini; ++i)
                    {
                        var j = UnsafeUtility.MemCmp(aa + sizeof(T) * i, bb + sizeof(T) * i, sizeof(T));
                        if(j != 0)
                            return j;
                    }
                    return Length.CompareTo(other.Length);
                }
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedList512&lt;T&gt; and indicates whether this instance
        /// is equal to the specified FixedList512&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList512&lt;T&gt; to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedList512<T> other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedList128&lt;T&gt; that is a copy of a FixedList512&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList512&lt;T&gt; to copy</param>
        public FixedList128(in FixedList512<T> other)
        {
            FixedList.CheckResize<FixedBytes126,T>(other.length);
            length = other.length;
            buffer = new FixedBytes126();
            unsafe
            {
                UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Implicitly converts a FixedList512&lt;T&gt; to a FixedList128&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList512&lt;T&gt; to copy</param>
        /// <returns></returns>
        public static implicit operator FixedList128<T>(in FixedList512<T> other)
        {
            return new FixedList128<T>(other);
        }

        /// <summary>
        /// Determines whether a FixedList128&lt;T&gt; and FixedList4096&lt;T&gt; have the same value.
        /// </summary>
        /// <param name="a">The FixedList128&lt;T&gt; to compare for equality</param>
        /// <param name="b">The FixedList4096&lt;T&gt; to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedList128<T> a, in FixedList4096<T> b)
        {
            unsafe
            {
                if(a.length != b.length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedList128&lt;T&gt; and FixedList4096&lt;T&gt; have different values.
        /// </summary>
        /// <param name="a">The FixedList128&lt;T&gt; to compare for inequality</param>
        /// <param name="b">The FixedList4096&lt;T&gt; to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedList128<T> a, in FixedList4096<T> b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedList4096&lt;T&gt; and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedList4096&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList4096&lt;T&gt; to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedList4096<T> other)
        {
            unsafe
            {
                fixed(byte* a = &buffer.offset0000.byte0000)
                {
                    byte* b = &other.buffer.offset0000.byte0000;
                    var aa = a + FixedList.PaddingBytes<T>();
                    var bb = b + FixedList.PaddingBytes<T>();
                    var mini = math.min(Length, other.Length);
                    for(var i = 0; i < mini; ++i)
                    {
                        var j = UnsafeUtility.MemCmp(aa + sizeof(T) * i, bb + sizeof(T) * i, sizeof(T));
                        if(j != 0)
                            return j;
                    }
                    return Length.CompareTo(other.Length);
                }
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedList4096&lt;T&gt; and indicates whether this instance
        /// is equal to the specified FixedList4096&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList4096&lt;T&gt; to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedList4096<T> other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedList128&lt;T&gt; that is a copy of a FixedList4096&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList4096&lt;T&gt; to copy</param>
        public FixedList128(in FixedList4096<T> other)
        {
            FixedList.CheckResize<FixedBytes126,T>(other.length);
            length = other.length;
            buffer = new FixedBytes126();
            unsafe
            {
                UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Implicitly converts a FixedList4096&lt;T&gt; to a FixedList128&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList4096&lt;T&gt; to copy</param>
        /// <returns></returns>
        public static implicit operator FixedList128<T>(in FixedList4096<T> other)
        {
            return new FixedList128<T>(other);
        }

        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        /// <returns></returns>
        [NotBurstCompatible]
        public override bool Equals(object obj)
        {
            if(obj is FixedList32<T> aFixedList32) return Equals(aFixedList32);
            if(obj is FixedList64<T> aFixedList64) return Equals(aFixedList64);
            if(obj is FixedList128<T> aFixedList128) return Equals(aFixedList128);
            if(obj is FixedList512<T> aFixedList512) return Equals(aFixedList512);
            if(obj is FixedList4096<T> aFixedList4096) return Equals(aFixedList4096);
            return false;
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        public struct Enumerator : IEnumerator<T>
        {
            FixedList128<T> m_List;
            int m_Index;

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <param name="list"><undoc /></param>
            public Enumerator(ref FixedList128<T> list)
            {
                m_List = list;
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Dispose()
            {
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <returns><undoc /></returns>
            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Reset()
            {
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public T Current => m_List[m_Index]; // Let FixedList128<T> indexer check for out of range.

            object IEnumerator.Current => Current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator IEnumerable.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator<T> IEnumerable<T>.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckCapacityInRange(int capacity)
        {
            if(capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }
    }

    public unsafe static class FixedList128Extensions
    {
        /// <summary>
        /// Searches for the specified element in FixedList128&lt;T&gt;.
        /// </summary>
        /// <typeparam name="T">The type of values in the list.</typeparam>
        /// <typeparam name="U">The value type.</typeparam>
        /// <param name="list">List to perform search.</param>
        /// <param name="value">The value to locate.</param>
        /// <returns>The zero-based index of the first occurrence element if found, otherwise returns -1.</returns>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int), typeof(int) })]
        public static int IndexOf<T, U>(this ref FixedList128<T> list, U value) where T : unmanaged, IEquatable<U>
        {
            return NativeArrayExtensions.IndexOf<T, U>(list.Buffer, list.Length, value);
        }

        /// <summary>
        /// Determines whether an element is in the FixedList128&lt;T&gt;.
        /// </summary>
        /// <typeparam name="T">The type of values in the list.</typeparam>
        /// <typeparam name="U">The value type.</typeparam>
        /// <param name="list">List to perform search.</param>
        /// <param name="value">The value to locate.</param>
        /// <returns>True, if element is found.</returns>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int), typeof(int) })]
        public static bool Contains<T, U>(this ref FixedList128<T> list, U value) where T : unmanaged, IEquatable<U>
        {
            return list.IndexOf(value) != -1;
        }

        /// <summary>
        /// Searches for the specified item from the begining of the FixedList128 forward, removes it if possible,
        /// and returns true if the item was successfully removed.
        /// </summary>
        /// <param name="item">The item to locate in the FixedList128</param>
        /// <returns>True, if element is removed.</returns>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int), typeof(int) })]
        public static bool Remove<T, U>(this ref FixedList128<T> list, U value) where T : unmanaged, IEquatable<U>
        {
            int index = list.IndexOf(value);
            if (index < 0)
            {
                return false;
            }

            list.RemoveAt(index);

            return true;
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedList128&lt;T&gt; and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedList128&lt;T&gt;.</param>
        /// <returns>Returns true if item is removed.</returns>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int), typeof(int) })]
        public static bool RemoveSwapBack<T, U>(this ref FixedList128<T> list, U value) where T : unmanaged, IEquatable<U>
        {
            var index = list.IndexOf(value);
            if (index == -1)
            {
                return false;
            }

            list.RemoveAtSwapBack(index);

            return true;
        }
    }

    sealed class FixedList128DebugView<T> where T : unmanaged
    {
        FixedList128<T> m_List;
        public FixedList128DebugView(FixedList128<T> list)
        {
            m_List = list;
        }
        public T[] Items => m_List.ToArray();
    }
    /// <summary>
    /// An unmanaged, resizable list that does not allocate memory.
    /// It is 512 bytes in size, and contains all the memory it needs.
    /// </summary>
    /// <typeparam name="T">The type of the elements in the container.</typeparam>
    [Serializable]
    [DebuggerTypeProxy(typeof(FixedList512DebugView<>))]
    [BurstCompatible(GenericTypeArguments = new [] { typeof(int) })]
    public struct FixedList512<T>
    : INativeList<T>
    , IEnumerable<T> // Used by collection initializers.
    , IEquatable<FixedList32<T>>
    , IComparable<FixedList32<T>>
    , IEquatable<FixedList64<T>>
    , IComparable<FixedList64<T>>
    , IEquatable<FixedList128<T>>
    , IComparable<FixedList128<T>>
    , IEquatable<FixedList512<T>>
    , IComparable<FixedList512<T>>
    , IEquatable<FixedList4096<T>>
    , IComparable<FixedList4096<T>>
    where T : unmanaged
    {
        [SerializeField] internal ushort length;
        [SerializeField] internal FixedBytes510 buffer;

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        [CreateProperty]
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize<FixedBytes510,T>(value);
                length = (ushort)value;
            }
        }

        /// <summary>
        /// A property in order to display items in the Entity Inspector.
        /// </summary>
        [CreateProperty] IEnumerable<T> Elements => this.ToArray();

        /// <summary>
        /// Reports whether container is empty.
        /// </summary>
        /// <value>True if this container empty.</value>
        public bool IsEmpty => Length == 0;

        internal int LengthInBytes => Length * UnsafeUtility.SizeOf<T>();

        unsafe internal byte* Buffer
        {
            get
            {
                fixed(byte* b = &buffer.offset0000.byte0000)
                    return b + FixedList.PaddingBytes<T>();
            }
        }

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity
        {
          get
          {
              return FixedList.Capacity<FixedBytes510,T>();
          }
          set
          {
              CheckCapacityInRange(value);
          }
        }

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public T this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    return UnsafeUtility.ReadArrayElement<T>(Buffer, CollectionHelper.AssumePositive(index));
                }
            }
            set
            {
                unsafe
                {
                    UnsafeUtility.WriteArrayElement<T>(Buffer, CollectionHelper.AssumePositive(index), value);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public ref T ElementAt(int index)
        {
            FixedList.CheckElementAccess(index, length);
            unsafe
            {
                return ref UnsafeUtility.ArrayElementAsRef<T>(Buffer, index);
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedList512&lt;T&gt;.
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                return (int)CollectionHelper.Hash(Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The T to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void Add(in T item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRange(void* ptr, int length)
        {
            T* data = (T*)ptr;
            for (var i = 0; i < length; ++i)
            {
                this[Length++] = data[i];
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The T to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void AddNoResize(in T item) => Add(item);

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRangeNoResize(void* ptr, int length) => AddRange(ptr, length);

        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }

        /// <summary>
        /// Inserts a number of items into a FixedList512&lt;T&gt; at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="end">The zero-based index just after where the elements should be removed.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void InsertRangeWithBeginEnd(int begin, int end)
        {
            int items = end - begin;
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * UnsafeUtility.SizeOf<T>();
            unsafe
            {
                byte *b = Buffer;
                byte *dest = b + end * UnsafeUtility.SizeOf<T>();
                byte *src = b + begin * UnsafeUtility.SizeOf<T>();
                UnsafeUtility.MemMove(dest, src, bytesToCopy);
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedList512&lt;T&gt; at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>
        public void Insert(int index, in T item)
        {
            InsertRangeWithBeginEnd(index, index+1);
            this[index] = item;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index with the last item in the list. The list
        /// is shortened by one.
        /// </summary>
        /// <param name="index">The index of the item to delete.</param>
        public void RemoveAtSwapBack(int index)
        {
            RemoveRangeSwapBackWithBeginEnd(index, index + 1);
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index range with the items from the end the list. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeSwapBackWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                int copyFrom = math.max(Length - itemsToRemove, end);

                unsafe
                {
                    var sizeOf = UnsafeUtility.SizeOf<T>();
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                }

                Length -= itemsToRemove;
            }
        }

        /// <summary>
        /// Truncates the list by removing the item at the specified index, and shifting all remaining items to replace removed item. The list
        /// is shortened by one.
        /// </summary>
        /// <param name="index">The index of the item to delete.</param>
        /// <remarks>
        /// This method of removing item is useful only in case when list is ordered and user wants to preserve order
        /// in list after removal In majority of cases is not important and user should use more performant `RemoveAtSwapBack`.
        /// </remarks>
        public void RemoveAt(int index)
        {
            RemoveRangeWithBeginEnd(index, index + 1);
        }

        /// <summary>
        /// Truncates the list by removing the items at the specified index range, and shifting all remaining items to replace removed items. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <remarks>
        /// This method of removing item(s) is useful only in case when list is ordered and user wants to preserve order
        /// in list after removal In majority of cases is not important and user should use more performant `RemoveRangeSwapBackWithBeginEnd`.
        /// </remarks>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                unsafe
                {
                    var sizeOf = UnsafeUtility.SizeOf<T>();
                    int copyFrom = math.min(begin + itemsToRemove, Length);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                    Length -= itemsToRemove;
                }
            }
        }

        /// <summary>
        /// Creates a managed Array of T that is a copy of this FixedList512&lt;T&gt;.
        /// </summary>
        /// <returns></returns>
        [NotBurstCompatible]
        public T[] ToArray()
        {
            var result = new T[Length];
            unsafe
            {
                byte* s = Buffer;
                fixed(T* d = result)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArray&lt;T&gt; that is a copy of this FixedList512&lt;T&gt;.
        /// </summary>
        /// <param name="allocator">A member of the
        /// [Unity.Collections.Allocator](https://docs.unity3d.com/ScriptReference/Unity.Collections.Allocator.html) enumeration.</param>
        /// <returns></returns>
        public NativeArray<T> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                var copy = new NativeArray<T>(Length, allocator, NativeArrayOptions.UninitializedMemory);
                UnsafeUtility.MemCpy(copy.GetUnsafePtr(), Buffer, LengthInBytes);
                return copy;
            }
        }


        /// <summary>
        /// Determines whether a FixedList512&lt;T&gt; and FixedList32&lt;T&gt; have the same value.
        /// </summary>
        /// <param name="a">The FixedList512&lt;T&gt; to compare for equality</param>
        /// <param name="b">The FixedList32&lt;T&gt; to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedList512<T> a, in FixedList32<T> b)
        {
            unsafe
            {
                if(a.length != b.length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedList512&lt;T&gt; and FixedList32&lt;T&gt; have different values.
        /// </summary>
        /// <param name="a">The FixedList512&lt;T&gt; to compare for inequality</param>
        /// <param name="b">The FixedList32&lt;T&gt; to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedList512<T> a, in FixedList32<T> b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedList32&lt;T&gt; and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedList32&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList32&lt;T&gt; to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedList32<T> other)
        {
            unsafe
            {
                fixed(byte* a = &buffer.offset0000.byte0000)
                {
                    byte* b = &other.buffer.offset0000.byte0000;
                    var aa = a + FixedList.PaddingBytes<T>();
                    var bb = b + FixedList.PaddingBytes<T>();
                    var mini = math.min(Length, other.Length);
                    for(var i = 0; i < mini; ++i)
                    {
                        var j = UnsafeUtility.MemCmp(aa + sizeof(T) * i, bb + sizeof(T) * i, sizeof(T));
                        if(j != 0)
                            return j;
                    }
                    return Length.CompareTo(other.Length);
                }
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedList32&lt;T&gt; and indicates whether this instance
        /// is equal to the specified FixedList32&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList32&lt;T&gt; to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedList32<T> other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedList512&lt;T&gt; that is a copy of a FixedList32&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList32&lt;T&gt; to copy</param>
        public FixedList512(in FixedList32<T> other)
        {
            FixedList.CheckResize<FixedBytes510,T>(other.length);
            length = other.length;
            buffer = new FixedBytes510();
            unsafe
            {
                UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Implicitly converts a FixedList32&lt;T&gt; to a FixedList512&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList32&lt;T&gt; to copy</param>
        /// <returns></returns>
        public static implicit operator FixedList512<T>(in FixedList32<T> other)
        {
            return new FixedList512<T>(other);
        }

        /// <summary>
        /// Determines whether a FixedList512&lt;T&gt; and FixedList64&lt;T&gt; have the same value.
        /// </summary>
        /// <param name="a">The FixedList512&lt;T&gt; to compare for equality</param>
        /// <param name="b">The FixedList64&lt;T&gt; to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedList512<T> a, in FixedList64<T> b)
        {
            unsafe
            {
                if(a.length != b.length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedList512&lt;T&gt; and FixedList64&lt;T&gt; have different values.
        /// </summary>
        /// <param name="a">The FixedList512&lt;T&gt; to compare for inequality</param>
        /// <param name="b">The FixedList64&lt;T&gt; to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedList512<T> a, in FixedList64<T> b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedList64&lt;T&gt; and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedList64&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList64&lt;T&gt; to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedList64<T> other)
        {
            unsafe
            {
                fixed(byte* a = &buffer.offset0000.byte0000)
                {
                    byte* b = &other.buffer.offset0000.byte0000;
                    var aa = a + FixedList.PaddingBytes<T>();
                    var bb = b + FixedList.PaddingBytes<T>();
                    var mini = math.min(Length, other.Length);
                    for(var i = 0; i < mini; ++i)
                    {
                        var j = UnsafeUtility.MemCmp(aa + sizeof(T) * i, bb + sizeof(T) * i, sizeof(T));
                        if(j != 0)
                            return j;
                    }
                    return Length.CompareTo(other.Length);
                }
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedList64&lt;T&gt; and indicates whether this instance
        /// is equal to the specified FixedList64&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList64&lt;T&gt; to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedList64<T> other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedList512&lt;T&gt; that is a copy of a FixedList64&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList64&lt;T&gt; to copy</param>
        public FixedList512(in FixedList64<T> other)
        {
            FixedList.CheckResize<FixedBytes510,T>(other.length);
            length = other.length;
            buffer = new FixedBytes510();
            unsafe
            {
                UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Implicitly converts a FixedList64&lt;T&gt; to a FixedList512&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList64&lt;T&gt; to copy</param>
        /// <returns></returns>
        public static implicit operator FixedList512<T>(in FixedList64<T> other)
        {
            return new FixedList512<T>(other);
        }

        /// <summary>
        /// Determines whether a FixedList512&lt;T&gt; and FixedList128&lt;T&gt; have the same value.
        /// </summary>
        /// <param name="a">The FixedList512&lt;T&gt; to compare for equality</param>
        /// <param name="b">The FixedList128&lt;T&gt; to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedList512<T> a, in FixedList128<T> b)
        {
            unsafe
            {
                if(a.length != b.length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedList512&lt;T&gt; and FixedList128&lt;T&gt; have different values.
        /// </summary>
        /// <param name="a">The FixedList512&lt;T&gt; to compare for inequality</param>
        /// <param name="b">The FixedList128&lt;T&gt; to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedList512<T> a, in FixedList128<T> b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedList128&lt;T&gt; and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedList128&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList128&lt;T&gt; to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedList128<T> other)
        {
            unsafe
            {
                fixed(byte* a = &buffer.offset0000.byte0000)
                {
                    byte* b = &other.buffer.offset0000.byte0000;
                    var aa = a + FixedList.PaddingBytes<T>();
                    var bb = b + FixedList.PaddingBytes<T>();
                    var mini = math.min(Length, other.Length);
                    for(var i = 0; i < mini; ++i)
                    {
                        var j = UnsafeUtility.MemCmp(aa + sizeof(T) * i, bb + sizeof(T) * i, sizeof(T));
                        if(j != 0)
                            return j;
                    }
                    return Length.CompareTo(other.Length);
                }
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedList128&lt;T&gt; and indicates whether this instance
        /// is equal to the specified FixedList128&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList128&lt;T&gt; to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedList128<T> other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedList512&lt;T&gt; that is a copy of a FixedList128&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList128&lt;T&gt; to copy</param>
        public FixedList512(in FixedList128<T> other)
        {
            FixedList.CheckResize<FixedBytes510,T>(other.length);
            length = other.length;
            buffer = new FixedBytes510();
            unsafe
            {
                UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Implicitly converts a FixedList128&lt;T&gt; to a FixedList512&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList128&lt;T&gt; to copy</param>
        /// <returns></returns>
        public static implicit operator FixedList512<T>(in FixedList128<T> other)
        {
            return new FixedList512<T>(other);
        }

        /// <summary>
        /// Determines whether a FixedList512&lt;T&gt; and FixedList512&lt;T&gt; have the same value.
        /// </summary>
        /// <param name="a">The FixedList512&lt;T&gt; to compare for equality</param>
        /// <param name="b">The FixedList512&lt;T&gt; to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedList512<T> a, in FixedList512<T> b)
        {
            unsafe
            {
                if(a.length != b.length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedList512&lt;T&gt; and FixedList512&lt;T&gt; have different values.
        /// </summary>
        /// <param name="a">The FixedList512&lt;T&gt; to compare for inequality</param>
        /// <param name="b">The FixedList512&lt;T&gt; to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedList512<T> a, in FixedList512<T> b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedList512&lt;T&gt; and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedList512&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList512&lt;T&gt; to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedList512<T> other)
        {
            unsafe
            {
                fixed(byte* a = &buffer.offset0000.byte0000)
                {
                    byte* b = &other.buffer.offset0000.byte0000;
                    var aa = a + FixedList.PaddingBytes<T>();
                    var bb = b + FixedList.PaddingBytes<T>();
                    var mini = math.min(Length, other.Length);
                    for(var i = 0; i < mini; ++i)
                    {
                        var j = UnsafeUtility.MemCmp(aa + sizeof(T) * i, bb + sizeof(T) * i, sizeof(T));
                        if(j != 0)
                            return j;
                    }
                    return Length.CompareTo(other.Length);
                }
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedList512&lt;T&gt; and indicates whether this instance
        /// is equal to the specified FixedList512&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList512&lt;T&gt; to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedList512<T> other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Determines whether a FixedList512&lt;T&gt; and FixedList4096&lt;T&gt; have the same value.
        /// </summary>
        /// <param name="a">The FixedList512&lt;T&gt; to compare for equality</param>
        /// <param name="b">The FixedList4096&lt;T&gt; to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedList512<T> a, in FixedList4096<T> b)
        {
            unsafe
            {
                if(a.length != b.length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedList512&lt;T&gt; and FixedList4096&lt;T&gt; have different values.
        /// </summary>
        /// <param name="a">The FixedList512&lt;T&gt; to compare for inequality</param>
        /// <param name="b">The FixedList4096&lt;T&gt; to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedList512<T> a, in FixedList4096<T> b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedList4096&lt;T&gt; and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedList4096&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList4096&lt;T&gt; to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedList4096<T> other)
        {
            unsafe
            {
                fixed(byte* a = &buffer.offset0000.byte0000)
                {
                    byte* b = &other.buffer.offset0000.byte0000;
                    var aa = a + FixedList.PaddingBytes<T>();
                    var bb = b + FixedList.PaddingBytes<T>();
                    var mini = math.min(Length, other.Length);
                    for(var i = 0; i < mini; ++i)
                    {
                        var j = UnsafeUtility.MemCmp(aa + sizeof(T) * i, bb + sizeof(T) * i, sizeof(T));
                        if(j != 0)
                            return j;
                    }
                    return Length.CompareTo(other.Length);
                }
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedList4096&lt;T&gt; and indicates whether this instance
        /// is equal to the specified FixedList4096&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList4096&lt;T&gt; to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedList4096<T> other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedList512&lt;T&gt; that is a copy of a FixedList4096&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList4096&lt;T&gt; to copy</param>
        public FixedList512(in FixedList4096<T> other)
        {
            FixedList.CheckResize<FixedBytes510,T>(other.length);
            length = other.length;
            buffer = new FixedBytes510();
            unsafe
            {
                UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Implicitly converts a FixedList4096&lt;T&gt; to a FixedList512&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList4096&lt;T&gt; to copy</param>
        /// <returns></returns>
        public static implicit operator FixedList512<T>(in FixedList4096<T> other)
        {
            return new FixedList512<T>(other);
        }

        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        /// <returns></returns>
        [NotBurstCompatible]
        public override bool Equals(object obj)
        {
            if(obj is FixedList32<T> aFixedList32) return Equals(aFixedList32);
            if(obj is FixedList64<T> aFixedList64) return Equals(aFixedList64);
            if(obj is FixedList128<T> aFixedList128) return Equals(aFixedList128);
            if(obj is FixedList512<T> aFixedList512) return Equals(aFixedList512);
            if(obj is FixedList4096<T> aFixedList4096) return Equals(aFixedList4096);
            return false;
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        public struct Enumerator : IEnumerator<T>
        {
            FixedList512<T> m_List;
            int m_Index;

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <param name="list"><undoc /></param>
            public Enumerator(ref FixedList512<T> list)
            {
                m_List = list;
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Dispose()
            {
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <returns><undoc /></returns>
            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Reset()
            {
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public T Current => m_List[m_Index]; // Let FixedList512<T> indexer check for out of range.

            object IEnumerator.Current => Current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator IEnumerable.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator<T> IEnumerable<T>.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckCapacityInRange(int capacity)
        {
            if(capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }
    }

    public unsafe static class FixedList512Extensions
    {
        /// <summary>
        /// Searches for the specified element in FixedList512&lt;T&gt;.
        /// </summary>
        /// <typeparam name="T">The type of values in the list.</typeparam>
        /// <typeparam name="U">The value type.</typeparam>
        /// <param name="list">List to perform search.</param>
        /// <param name="value">The value to locate.</param>
        /// <returns>The zero-based index of the first occurrence element if found, otherwise returns -1.</returns>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int), typeof(int) })]
        public static int IndexOf<T, U>(this ref FixedList512<T> list, U value) where T : unmanaged, IEquatable<U>
        {
            return NativeArrayExtensions.IndexOf<T, U>(list.Buffer, list.Length, value);
        }

        /// <summary>
        /// Determines whether an element is in the FixedList512&lt;T&gt;.
        /// </summary>
        /// <typeparam name="T">The type of values in the list.</typeparam>
        /// <typeparam name="U">The value type.</typeparam>
        /// <param name="list">List to perform search.</param>
        /// <param name="value">The value to locate.</param>
        /// <returns>True, if element is found.</returns>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int), typeof(int) })]
        public static bool Contains<T, U>(this ref FixedList512<T> list, U value) where T : unmanaged, IEquatable<U>
        {
            return list.IndexOf(value) != -1;
        }

        /// <summary>
        /// Searches for the specified item from the begining of the FixedList512 forward, removes it if possible,
        /// and returns true if the item was successfully removed.
        /// </summary>
        /// <param name="item">The item to locate in the FixedList512</param>
        /// <returns>True, if element is removed.</returns>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int), typeof(int) })]
        public static bool Remove<T, U>(this ref FixedList512<T> list, U value) where T : unmanaged, IEquatable<U>
        {
            int index = list.IndexOf(value);
            if (index < 0)
            {
                return false;
            }

            list.RemoveAt(index);

            return true;
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedList512&lt;T&gt; and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedList512&lt;T&gt;.</param>
        /// <returns>Returns true if item is removed.</returns>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int), typeof(int) })]
        public static bool RemoveSwapBack<T, U>(this ref FixedList512<T> list, U value) where T : unmanaged, IEquatable<U>
        {
            var index = list.IndexOf(value);
            if (index == -1)
            {
                return false;
            }

            list.RemoveAtSwapBack(index);

            return true;
        }
    }

    sealed class FixedList512DebugView<T> where T : unmanaged
    {
        FixedList512<T> m_List;
        public FixedList512DebugView(FixedList512<T> list)
        {
            m_List = list;
        }
        public T[] Items => m_List.ToArray();
    }
    /// <summary>
    /// An unmanaged, resizable list that does not allocate memory.
    /// It is 4096 bytes in size, and contains all the memory it needs.
    /// </summary>
    /// <typeparam name="T">The type of the elements in the container.</typeparam>
    [Serializable]
    [DebuggerTypeProxy(typeof(FixedList4096DebugView<>))]
    [BurstCompatible(GenericTypeArguments = new [] { typeof(int) })]
    public struct FixedList4096<T>
    : INativeList<T>
    , IEnumerable<T> // Used by collection initializers.
    , IEquatable<FixedList32<T>>
    , IComparable<FixedList32<T>>
    , IEquatable<FixedList64<T>>
    , IComparable<FixedList64<T>>
    , IEquatable<FixedList128<T>>
    , IComparable<FixedList128<T>>
    , IEquatable<FixedList512<T>>
    , IComparable<FixedList512<T>>
    , IEquatable<FixedList4096<T>>
    , IComparable<FixedList4096<T>>
    where T : unmanaged
    {
        [SerializeField] internal ushort length;
        [SerializeField] internal FixedBytes4094 buffer;

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        [CreateProperty]
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize<FixedBytes4094,T>(value);
                length = (ushort)value;
            }
        }

        /// <summary>
        /// A property in order to display items in the Entity Inspector.
        /// </summary>
        [CreateProperty] IEnumerable<T> Elements => this.ToArray();

        /// <summary>
        /// Reports whether container is empty.
        /// </summary>
        /// <value>True if this container empty.</value>
        public bool IsEmpty => Length == 0;

        internal int LengthInBytes => Length * UnsafeUtility.SizeOf<T>();

        unsafe internal byte* Buffer
        {
            get
            {
                fixed(byte* b = &buffer.offset0000.byte0000)
                    return b + FixedList.PaddingBytes<T>();
            }
        }

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity
        {
          get
          {
              return FixedList.Capacity<FixedBytes4094,T>();
          }
          set
          {
              CheckCapacityInRange(value);
          }
        }

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public T this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    return UnsafeUtility.ReadArrayElement<T>(Buffer, CollectionHelper.AssumePositive(index));
                }
            }
            set
            {
                unsafe
                {
                    UnsafeUtility.WriteArrayElement<T>(Buffer, CollectionHelper.AssumePositive(index), value);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public ref T ElementAt(int index)
        {
            FixedList.CheckElementAccess(index, length);
            unsafe
            {
                return ref UnsafeUtility.ArrayElementAsRef<T>(Buffer, index);
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedList4096&lt;T&gt;.
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                return (int)CollectionHelper.Hash(Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The T to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void Add(in T item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRange(void* ptr, int length)
        {
            T* data = (T*)ptr;
            for (var i = 0; i < length; ++i)
            {
                this[Length++] = data[i];
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The T to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void AddNoResize(in T item) => Add(item);

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRangeNoResize(void* ptr, int length) => AddRange(ptr, length);

        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }

        /// <summary>
        /// Inserts a number of items into a FixedList4096&lt;T&gt; at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="end">The zero-based index just after where the elements should be removed.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void InsertRangeWithBeginEnd(int begin, int end)
        {
            int items = end - begin;
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * UnsafeUtility.SizeOf<T>();
            unsafe
            {
                byte *b = Buffer;
                byte *dest = b + end * UnsafeUtility.SizeOf<T>();
                byte *src = b + begin * UnsafeUtility.SizeOf<T>();
                UnsafeUtility.MemMove(dest, src, bytesToCopy);
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedList4096&lt;T&gt; at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>
        public void Insert(int index, in T item)
        {
            InsertRangeWithBeginEnd(index, index+1);
            this[index] = item;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index with the last item in the list. The list
        /// is shortened by one.
        /// </summary>
        /// <param name="index">The index of the item to delete.</param>
        public void RemoveAtSwapBack(int index)
        {
            RemoveRangeSwapBackWithBeginEnd(index, index + 1);
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index range with the items from the end the list. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeSwapBackWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                int copyFrom = math.max(Length - itemsToRemove, end);

                unsafe
                {
                    var sizeOf = UnsafeUtility.SizeOf<T>();
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                }

                Length -= itemsToRemove;
            }
        }

        /// <summary>
        /// Truncates the list by removing the item at the specified index, and shifting all remaining items to replace removed item. The list
        /// is shortened by one.
        /// </summary>
        /// <param name="index">The index of the item to delete.</param>
        /// <remarks>
        /// This method of removing item is useful only in case when list is ordered and user wants to preserve order
        /// in list after removal In majority of cases is not important and user should use more performant `RemoveAtSwapBack`.
        /// </remarks>
        public void RemoveAt(int index)
        {
            RemoveRangeWithBeginEnd(index, index + 1);
        }

        /// <summary>
        /// Truncates the list by removing the items at the specified index range, and shifting all remaining items to replace removed items. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <remarks>
        /// This method of removing item(s) is useful only in case when list is ordered and user wants to preserve order
        /// in list after removal In majority of cases is not important and user should use more performant `RemoveRangeSwapBackWithBeginEnd`.
        /// </remarks>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                unsafe
                {
                    var sizeOf = UnsafeUtility.SizeOf<T>();
                    int copyFrom = math.min(begin + itemsToRemove, Length);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                    Length -= itemsToRemove;
                }
            }
        }

        /// <summary>
        /// Creates a managed Array of T that is a copy of this FixedList4096&lt;T&gt;.
        /// </summary>
        /// <returns></returns>
        [NotBurstCompatible]
        public T[] ToArray()
        {
            var result = new T[Length];
            unsafe
            {
                byte* s = Buffer;
                fixed(T* d = result)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArray&lt;T&gt; that is a copy of this FixedList4096&lt;T&gt;.
        /// </summary>
        /// <param name="allocator">A member of the
        /// [Unity.Collections.Allocator](https://docs.unity3d.com/ScriptReference/Unity.Collections.Allocator.html) enumeration.</param>
        /// <returns></returns>
        public NativeArray<T> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                var copy = new NativeArray<T>(Length, allocator, NativeArrayOptions.UninitializedMemory);
                UnsafeUtility.MemCpy(copy.GetUnsafePtr(), Buffer, LengthInBytes);
                return copy;
            }
        }


        /// <summary>
        /// Determines whether a FixedList4096&lt;T&gt; and FixedList32&lt;T&gt; have the same value.
        /// </summary>
        /// <param name="a">The FixedList4096&lt;T&gt; to compare for equality</param>
        /// <param name="b">The FixedList32&lt;T&gt; to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedList4096<T> a, in FixedList32<T> b)
        {
            unsafe
            {
                if(a.length != b.length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedList4096&lt;T&gt; and FixedList32&lt;T&gt; have different values.
        /// </summary>
        /// <param name="a">The FixedList4096&lt;T&gt; to compare for inequality</param>
        /// <param name="b">The FixedList32&lt;T&gt; to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedList4096<T> a, in FixedList32<T> b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedList32&lt;T&gt; and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedList32&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList32&lt;T&gt; to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedList32<T> other)
        {
            unsafe
            {
                fixed(byte* a = &buffer.offset0000.byte0000)
                {
                    byte* b = &other.buffer.offset0000.byte0000;
                    var aa = a + FixedList.PaddingBytes<T>();
                    var bb = b + FixedList.PaddingBytes<T>();
                    var mini = math.min(Length, other.Length);
                    for(var i = 0; i < mini; ++i)
                    {
                        var j = UnsafeUtility.MemCmp(aa + sizeof(T) * i, bb + sizeof(T) * i, sizeof(T));
                        if(j != 0)
                            return j;
                    }
                    return Length.CompareTo(other.Length);
                }
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedList32&lt;T&gt; and indicates whether this instance
        /// is equal to the specified FixedList32&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList32&lt;T&gt; to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedList32<T> other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedList4096&lt;T&gt; that is a copy of a FixedList32&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList32&lt;T&gt; to copy</param>
        public FixedList4096(in FixedList32<T> other)
        {
            FixedList.CheckResize<FixedBytes4094,T>(other.length);
            length = other.length;
            buffer = new FixedBytes4094();
            unsafe
            {
                UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Implicitly converts a FixedList32&lt;T&gt; to a FixedList4096&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList32&lt;T&gt; to copy</param>
        /// <returns></returns>
        public static implicit operator FixedList4096<T>(in FixedList32<T> other)
        {
            return new FixedList4096<T>(other);
        }

        /// <summary>
        /// Determines whether a FixedList4096&lt;T&gt; and FixedList64&lt;T&gt; have the same value.
        /// </summary>
        /// <param name="a">The FixedList4096&lt;T&gt; to compare for equality</param>
        /// <param name="b">The FixedList64&lt;T&gt; to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedList4096<T> a, in FixedList64<T> b)
        {
            unsafe
            {
                if(a.length != b.length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedList4096&lt;T&gt; and FixedList64&lt;T&gt; have different values.
        /// </summary>
        /// <param name="a">The FixedList4096&lt;T&gt; to compare for inequality</param>
        /// <param name="b">The FixedList64&lt;T&gt; to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedList4096<T> a, in FixedList64<T> b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedList64&lt;T&gt; and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedList64&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList64&lt;T&gt; to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedList64<T> other)
        {
            unsafe
            {
                fixed(byte* a = &buffer.offset0000.byte0000)
                {
                    byte* b = &other.buffer.offset0000.byte0000;
                    var aa = a + FixedList.PaddingBytes<T>();
                    var bb = b + FixedList.PaddingBytes<T>();
                    var mini = math.min(Length, other.Length);
                    for(var i = 0; i < mini; ++i)
                    {
                        var j = UnsafeUtility.MemCmp(aa + sizeof(T) * i, bb + sizeof(T) * i, sizeof(T));
                        if(j != 0)
                            return j;
                    }
                    return Length.CompareTo(other.Length);
                }
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedList64&lt;T&gt; and indicates whether this instance
        /// is equal to the specified FixedList64&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList64&lt;T&gt; to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedList64<T> other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedList4096&lt;T&gt; that is a copy of a FixedList64&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList64&lt;T&gt; to copy</param>
        public FixedList4096(in FixedList64<T> other)
        {
            FixedList.CheckResize<FixedBytes4094,T>(other.length);
            length = other.length;
            buffer = new FixedBytes4094();
            unsafe
            {
                UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Implicitly converts a FixedList64&lt;T&gt; to a FixedList4096&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList64&lt;T&gt; to copy</param>
        /// <returns></returns>
        public static implicit operator FixedList4096<T>(in FixedList64<T> other)
        {
            return new FixedList4096<T>(other);
        }

        /// <summary>
        /// Determines whether a FixedList4096&lt;T&gt; and FixedList128&lt;T&gt; have the same value.
        /// </summary>
        /// <param name="a">The FixedList4096&lt;T&gt; to compare for equality</param>
        /// <param name="b">The FixedList128&lt;T&gt; to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedList4096<T> a, in FixedList128<T> b)
        {
            unsafe
            {
                if(a.length != b.length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedList4096&lt;T&gt; and FixedList128&lt;T&gt; have different values.
        /// </summary>
        /// <param name="a">The FixedList4096&lt;T&gt; to compare for inequality</param>
        /// <param name="b">The FixedList128&lt;T&gt; to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedList4096<T> a, in FixedList128<T> b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedList128&lt;T&gt; and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedList128&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList128&lt;T&gt; to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedList128<T> other)
        {
            unsafe
            {
                fixed(byte* a = &buffer.offset0000.byte0000)
                {
                    byte* b = &other.buffer.offset0000.byte0000;
                    var aa = a + FixedList.PaddingBytes<T>();
                    var bb = b + FixedList.PaddingBytes<T>();
                    var mini = math.min(Length, other.Length);
                    for(var i = 0; i < mini; ++i)
                    {
                        var j = UnsafeUtility.MemCmp(aa + sizeof(T) * i, bb + sizeof(T) * i, sizeof(T));
                        if(j != 0)
                            return j;
                    }
                    return Length.CompareTo(other.Length);
                }
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedList128&lt;T&gt; and indicates whether this instance
        /// is equal to the specified FixedList128&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList128&lt;T&gt; to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedList128<T> other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedList4096&lt;T&gt; that is a copy of a FixedList128&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList128&lt;T&gt; to copy</param>
        public FixedList4096(in FixedList128<T> other)
        {
            FixedList.CheckResize<FixedBytes4094,T>(other.length);
            length = other.length;
            buffer = new FixedBytes4094();
            unsafe
            {
                UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Implicitly converts a FixedList128&lt;T&gt; to a FixedList4096&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList128&lt;T&gt; to copy</param>
        /// <returns></returns>
        public static implicit operator FixedList4096<T>(in FixedList128<T> other)
        {
            return new FixedList4096<T>(other);
        }

        /// <summary>
        /// Determines whether a FixedList4096&lt;T&gt; and FixedList512&lt;T&gt; have the same value.
        /// </summary>
        /// <param name="a">The FixedList4096&lt;T&gt; to compare for equality</param>
        /// <param name="b">The FixedList512&lt;T&gt; to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedList4096<T> a, in FixedList512<T> b)
        {
            unsafe
            {
                if(a.length != b.length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedList4096&lt;T&gt; and FixedList512&lt;T&gt; have different values.
        /// </summary>
        /// <param name="a">The FixedList4096&lt;T&gt; to compare for inequality</param>
        /// <param name="b">The FixedList512&lt;T&gt; to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedList4096<T> a, in FixedList512<T> b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedList512&lt;T&gt; and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedList512&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList512&lt;T&gt; to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedList512<T> other)
        {
            unsafe
            {
                fixed(byte* a = &buffer.offset0000.byte0000)
                {
                    byte* b = &other.buffer.offset0000.byte0000;
                    var aa = a + FixedList.PaddingBytes<T>();
                    var bb = b + FixedList.PaddingBytes<T>();
                    var mini = math.min(Length, other.Length);
                    for(var i = 0; i < mini; ++i)
                    {
                        var j = UnsafeUtility.MemCmp(aa + sizeof(T) * i, bb + sizeof(T) * i, sizeof(T));
                        if(j != 0)
                            return j;
                    }
                    return Length.CompareTo(other.Length);
                }
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedList512&lt;T&gt; and indicates whether this instance
        /// is equal to the specified FixedList512&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList512&lt;T&gt; to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedList512<T> other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedList4096&lt;T&gt; that is a copy of a FixedList512&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList512&lt;T&gt; to copy</param>
        public FixedList4096(in FixedList512<T> other)
        {
            FixedList.CheckResize<FixedBytes4094,T>(other.length);
            length = other.length;
            buffer = new FixedBytes4094();
            unsafe
            {
                UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Implicitly converts a FixedList512&lt;T&gt; to a FixedList4096&lt;T&gt;.
        /// </summary>
        /// <param name="other">The FixedList512&lt;T&gt; to copy</param>
        /// <returns></returns>
        public static implicit operator FixedList4096<T>(in FixedList512<T> other)
        {
            return new FixedList4096<T>(other);
        }

        /// <summary>
        /// Determines whether a FixedList4096&lt;T&gt; and FixedList4096&lt;T&gt; have the same value.
        /// </summary>
        /// <param name="a">The FixedList4096&lt;T&gt; to compare for equality</param>
        /// <param name="b">The FixedList4096&lt;T&gt; to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedList4096<T> a, in FixedList4096<T> b)
        {
            unsafe
            {
                if(a.length != b.length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedList4096&lt;T&gt; and FixedList4096&lt;T&gt; have different values.
        /// </summary>
        /// <param name="a">The FixedList4096&lt;T&gt; to compare for inequality</param>
        /// <param name="b">The FixedList4096&lt;T&gt; to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedList4096<T> a, in FixedList4096<T> b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedList4096&lt;T&gt; and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedList4096&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList4096&lt;T&gt; to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedList4096<T> other)
        {
            unsafe
            {
                fixed(byte* a = &buffer.offset0000.byte0000)
                {
                    byte* b = &other.buffer.offset0000.byte0000;
                    var aa = a + FixedList.PaddingBytes<T>();
                    var bb = b + FixedList.PaddingBytes<T>();
                    var mini = math.min(Length, other.Length);
                    for(var i = 0; i < mini; ++i)
                    {
                        var j = UnsafeUtility.MemCmp(aa + sizeof(T) * i, bb + sizeof(T) * i, sizeof(T));
                        if(j != 0)
                            return j;
                    }
                    return Length.CompareTo(other.Length);
                }
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedList4096&lt;T&gt; and indicates whether this instance
        /// is equal to the specified FixedList4096&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified FixedList4096&lt;T&gt; to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedList4096<T> other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        /// <returns></returns>
        [NotBurstCompatible]
        public override bool Equals(object obj)
        {
            if(obj is FixedList32<T> aFixedList32) return Equals(aFixedList32);
            if(obj is FixedList64<T> aFixedList64) return Equals(aFixedList64);
            if(obj is FixedList128<T> aFixedList128) return Equals(aFixedList128);
            if(obj is FixedList512<T> aFixedList512) return Equals(aFixedList512);
            if(obj is FixedList4096<T> aFixedList4096) return Equals(aFixedList4096);
            return false;
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        public struct Enumerator : IEnumerator<T>
        {
            FixedList4096<T> m_List;
            int m_Index;

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <param name="list"><undoc /></param>
            public Enumerator(ref FixedList4096<T> list)
            {
                m_List = list;
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Dispose()
            {
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <returns><undoc /></returns>
            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Reset()
            {
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public T Current => m_List[m_Index]; // Let FixedList4096<T> indexer check for out of range.

            object IEnumerator.Current => Current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator IEnumerable.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator<T> IEnumerable<T>.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckCapacityInRange(int capacity)
        {
            if(capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }
    }

    public unsafe static class FixedList4096Extensions
    {
        /// <summary>
        /// Searches for the specified element in FixedList4096&lt;T&gt;.
        /// </summary>
        /// <typeparam name="T">The type of values in the list.</typeparam>
        /// <typeparam name="U">The value type.</typeparam>
        /// <param name="list">List to perform search.</param>
        /// <param name="value">The value to locate.</param>
        /// <returns>The zero-based index of the first occurrence element if found, otherwise returns -1.</returns>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int), typeof(int) })]
        public static int IndexOf<T, U>(this ref FixedList4096<T> list, U value) where T : unmanaged, IEquatable<U>
        {
            return NativeArrayExtensions.IndexOf<T, U>(list.Buffer, list.Length, value);
        }

        /// <summary>
        /// Determines whether an element is in the FixedList4096&lt;T&gt;.
        /// </summary>
        /// <typeparam name="T">The type of values in the list.</typeparam>
        /// <typeparam name="U">The value type.</typeparam>
        /// <param name="list">List to perform search.</param>
        /// <param name="value">The value to locate.</param>
        /// <returns>True, if element is found.</returns>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int), typeof(int) })]
        public static bool Contains<T, U>(this ref FixedList4096<T> list, U value) where T : unmanaged, IEquatable<U>
        {
            return list.IndexOf(value) != -1;
        }

        /// <summary>
        /// Searches for the specified item from the begining of the FixedList4096 forward, removes it if possible,
        /// and returns true if the item was successfully removed.
        /// </summary>
        /// <param name="item">The item to locate in the FixedList4096</param>
        /// <returns>True, if element is removed.</returns>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int), typeof(int) })]
        public static bool Remove<T, U>(this ref FixedList4096<T> list, U value) where T : unmanaged, IEquatable<U>
        {
            int index = list.IndexOf(value);
            if (index < 0)
            {
                return false;
            }

            list.RemoveAt(index);

            return true;
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedList4096&lt;T&gt; and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedList4096&lt;T&gt;.</param>
        /// <returns>Returns true if item is removed.</returns>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int), typeof(int) })]
        public static bool RemoveSwapBack<T, U>(this ref FixedList4096<T> list, U value) where T : unmanaged, IEquatable<U>
        {
            var index = list.IndexOf(value);
            if (index == -1)
            {
                return false;
            }

            list.RemoveAtSwapBack(index);

            return true;
        }
    }

    sealed class FixedList4096DebugView<T> where T : unmanaged
    {
        FixedList4096<T> m_List;
        public FixedList4096DebugView(FixedList4096<T> list)
        {
            m_List = list;
        }
        public T[] Items => m_List.ToArray();
    }


    /// <summary>
    /// An unmanaged, resizable list of byte that does not allocate memory.
    /// It is 32 bytes in size, and contains all the memory it needs.
    /// </summary>
    [Serializable]
    [StructLayout(LayoutKind.Explicit, Size=32)]
    [DebuggerTypeProxy(typeof(FixedListByte32DebugView))]
    [BurstCompatible]
    public struct FixedListByte32
    : INativeList<byte>
    , IEnumerable<byte> // Used by collection initializers.
    , IEquatable<FixedListByte32>
    , IComparable<FixedListByte32>
    , IEquatable<FixedListByte64>
    , IComparable<FixedListByte64>
    , IEquatable<FixedListByte128>
    , IComparable<FixedListByte128>
    , IEquatable<FixedListByte512>
    , IComparable<FixedListByte512>
    , IEquatable<FixedListByte4096>
    , IComparable<FixedListByte4096>
    {
        [SerializeField] [FieldOffset(0)] internal ushort length;
        [SerializeField] [FieldOffset(2)] internal FixedBytes30 buffer;

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        [CreateProperty]
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize<FixedBytes30,byte>(value);
                length = (ushort)value;
            }
        }

        /// <summary>
        /// A property in order to display items in the Entity Inspector.
        /// </summary>
        [CreateProperty] IEnumerable<byte> Elements => this.ToArray();

        /// <summary>
        /// Reports whether container is empty.
        /// </summary>
        /// <value>True if this container empty.</value>
        public bool IsEmpty => Length == 0;

        internal int LengthInBytes => Length * sizeof(byte);

        unsafe internal byte* Buffer
        {
            get
            {
                fixed(byte* b = &buffer.offset0000.byte0000)
                    return b + FixedList.PaddingBytes<byte>();
            }
        }

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity
        {
            get
            {
                return FixedList.Capacity<FixedBytes30, byte>();
            }
            set
            {
                CheckCapacityInRange(value);
            }
        }

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public byte this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    return UnsafeUtility.ReadArrayElement<byte>(Buffer, index);
                }
            }
            set
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    UnsafeUtility.WriteArrayElement<byte>(Buffer, index, value);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public ref byte ElementAt(int index)
        {
            FixedList.CheckElementAccess(index, length);
            unsafe
            {
                return ref UnsafeUtility.ArrayElementAsRef<byte>(Buffer, index);
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedListByte32.
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                return (int)CollectionHelper.Hash(Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The byte to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void Add(in byte item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRange(void* ptr, int length)
        {
            byte* data = (byte*)ptr;
            for (var i = 0; i < length; ++i)
            {
                this[Length++] = data[i];
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The byte to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void AddNoResize(byte item) => Add(item);

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRangeNoResize(void* ptr, int length) => AddRange(ptr, length);

        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }

        /// <summary>
        /// Searches for the specified byte and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListByte32 that starts at the specified index and contains the specified
        /// number of elements.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte32.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <param name="count">The number of elements in the section to search.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(byte item, int index, int count)
        {
            for(var i = index; i < index + count; ++i)
                if(this[i].Equals(item))
                  return i;
            return -1;
        }

        /// <summary>
        /// Searches for the specified byte and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListByte32 that starts at the specified index.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte32.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(byte item, int index)
        {
            return IndexOf(item, index, Length - index);
        }

        /// <summary>
        /// Determines whether an element is in the FixedListByte32.
        /// </summary>
        /// <param name="item">The object to locate in the FixedListByte32.</param>
        /// <returns></returns>
        public bool Contains(byte item)
        {
            return IndexOf(item) >= 0;
        }

        /// <summary>
        /// Searches for the specified byte and returns the zero-based index of the first occurrence within the entire FixedListByte32.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte32.</param>
        /// <returns></returns>
        public int IndexOf(byte item)
        {
            for (var i = 0; i < length; ++i)
            {
                if (this[i].Equals(item))
                {
                    return i;
                }
            }

            return -1;
        }

        /// <summary>
        /// Inserts a number of items into a FixedListByte32 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="end">The zero-based index just after where the elements should be removed.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void InsertRangeWithBeginEnd(int begin, int end)
        {
            int items = end - begin;
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(byte);
            unsafe
            {
                byte* b = Buffer;
                byte *dest = b + end * sizeof(byte);
                byte *src = b + begin * sizeof(byte);
                UnsafeUtility.MemMove(dest, src, bytesToCopy);
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedListByte32 at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>
        public void Insert(int index, byte item)
        {
            InsertRangeWithBeginEnd(index, index+1);
            this[index] = item;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index with the last item in the list. The list
        /// is shortened by one.
        /// </summary>
        /// <param name="index">The index of the item to delete.</param>
        public void RemoveAtSwapBack(int index)
        {
            RemoveRangeSwapBackWithBeginEnd(index, index + 1);
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedListByte32 and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedListByte32.</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool RemoveSwapBack(byte item)
        {
            var index = IndexOf(item);
            if (index == -1)
            {
                return false;
            }

            RemoveAtSwapBack(index);
            return true;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index range with the items from the end the list. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeSwapBackWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                int copyFrom = math.max(Length - itemsToRemove, end);

                unsafe
                {
                    var sizeOf = sizeof(byte);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                }

                Length -= itemsToRemove;
            }
        }

        /// <summary>
        /// Removes the byte at the specified index, and copies all subsequent elements backward to fill the
        /// hole so created.
        /// </summary>
        /// <param name="index">The zero-based index at which to remove the byte</param>
        public void RemoveAt(int index)
        {
            RemoveRangeWithBeginEnd(index, index+1);
        }

        /// <summary>
        /// Searches for the specified byte from the begining of the FixedListByte32 forward, removes it if possible,
        /// and returns true if the byte was successfully removed.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte32</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool Remove(byte item)
        {
            int index = IndexOf(item);
            if (index < 0)
            {
                return false;
            }

            RemoveAt(index);

            return true;
        }

        /// <summary>
        /// Truncates the list by removing the items at the specified index range, and shifting all remaining items to replace removed items. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <remarks>
        /// This method of removing item(s) is useful only in case when list is ordered and user wants to preserve order
        /// in list after removal In majority of cases is not important and user should use more performant `RemoveRangeSwapBackWithBeginEnd`.
        /// </remarks>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                unsafe
                {
                    var sizeOf = sizeof(byte);
                    int copyFrom = math.min(begin + itemsToRemove, Length);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                    Length -= itemsToRemove;
                }
            }
        }

        /// <summary>
        /// Creates a managed Array of byte that is a copy of this FixedListByte32.
        /// </summary>
        /// <returns></returns>
        [NotBurstCompatible]
        public byte[] ToArray()
        {
            var result = new byte[Length];
            unsafe
            {
                byte* s = Buffer;
                fixed(byte* d = result)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArraybyte that is a copy of this FixedListByte32.
        /// </summary>
        /// <param name="allocator">A member of the
        /// [Unity.Collections.Allocator](https://docs.unity3d.com/ScriptReference/Unity.Collections.Allocator.html) enumeration.</param>
        /// <returns></returns>
        public NativeArray<byte> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                byte* s = Buffer;
                var copy = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<byte>(s, Length, Allocator.None);
                return new NativeArray<byte>(copy, allocator);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListByte32 in ascending order.
        /// </summary>
        public void Sort()
        {
            unsafe
            {
                NativeSortExtension.Sort((byte*)Buffer, length);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListByte32 using a custom comparison function.
        /// </summary>
        /// <typeparam name="U">The comparer type.</typeparam>
        /// <param name="comp">A comparison function that indicates whether one element in the array is less than, equal to, or greater than another element.</param>
        [BurstCompatible(GenericTypeArguments = new[] { typeof(NativeSortExtension.DefaultComparer<byte>) })]
        public void Sort<U>(U comp) where U : IComparer<byte>
        {
            unsafe
            {
                NativeSortExtension.Sort((byte*)Buffer, length, comp);
            }
        }


        /// <summary>
        /// Determines whether a FixedListByte32 and FixedListByte32 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte32 to compare for equality</param>
        /// <param name="b">The FixedListByte32 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListByte32 a, in FixedListByte32 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListByte32 and FixedListByte32 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte32 to compare for inequality</param>
        /// <param name="b">The FixedListByte32 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListByte32 a, in FixedListByte32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte32 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte32.
        /// </summary>
        /// <param name="other">The specified FixedListByte32 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListByte32 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte32 and indicates whether this instance
        /// is equal to the specified FixedListByte32.
        /// </summary>
        /// <param name="other">The specified FixedListByte32 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListByte32 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Determines whether a FixedListByte32 and FixedListByte64 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte32 to compare for equality</param>
        /// <param name="b">The FixedListByte64 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListByte32 a, in FixedListByte64 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListByte32 and FixedListByte64 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte32 to compare for inequality</param>
        /// <param name="b">The FixedListByte64 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListByte32 a, in FixedListByte64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte64 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte64.
        /// </summary>
        /// <param name="other">The specified FixedListByte64 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListByte64 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte64 and indicates whether this instance
        /// is equal to the specified FixedListByte64.
        /// </summary>
        /// <param name="other">The specified FixedListByte64 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListByte64 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListByte32 that is a copy of a FixedListByte64.
        /// </summary>
        /// <param name="other">The FixedListByte64 to copy</param>
        public FixedListByte32(in FixedListByte64 other)
        {
            FixedList.CheckResize<FixedBytes30,byte>(other.length);
            length = other.length;
            buffer = new FixedBytes30();
            unsafe
            {
                fixed(FixedBytes62* s = &other.buffer)
                fixed(FixedBytes30* d = &this.buffer)
                    *d = *(FixedBytes30*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListByte64 to a FixedListByte32.
        /// </summary>
        /// <param name="other">The FixedListByte64 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListByte32(in FixedListByte64 other)
        {
            return new FixedListByte32(other);
        }

        /// <summary>
        /// Determines whether a FixedListByte32 and FixedListByte128 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte32 to compare for equality</param>
        /// <param name="b">The FixedListByte128 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListByte32 a, in FixedListByte128 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListByte32 and FixedListByte128 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte32 to compare for inequality</param>
        /// <param name="b">The FixedListByte128 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListByte32 a, in FixedListByte128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte128 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte128.
        /// </summary>
        /// <param name="other">The specified FixedListByte128 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListByte128 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte128 and indicates whether this instance
        /// is equal to the specified FixedListByte128.
        /// </summary>
        /// <param name="other">The specified FixedListByte128 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListByte128 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListByte32 that is a copy of a FixedListByte128.
        /// </summary>
        /// <param name="other">The FixedListByte128 to copy</param>
        public FixedListByte32(in FixedListByte128 other)
        {
            FixedList.CheckResize<FixedBytes30,byte>(other.length);
            length = other.length;
            buffer = new FixedBytes30();
            unsafe
            {
                fixed(FixedBytes126* s = &other.buffer)
                fixed(FixedBytes30* d = &this.buffer)
                    *d = *(FixedBytes30*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListByte128 to a FixedListByte32.
        /// </summary>
        /// <param name="other">The FixedListByte128 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListByte32(in FixedListByte128 other)
        {
            return new FixedListByte32(other);
        }

        /// <summary>
        /// Determines whether a FixedListByte32 and FixedListByte512 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte32 to compare for equality</param>
        /// <param name="b">The FixedListByte512 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListByte32 a, in FixedListByte512 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListByte32 and FixedListByte512 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte32 to compare for inequality</param>
        /// <param name="b">The FixedListByte512 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListByte32 a, in FixedListByte512 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte512 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte512.
        /// </summary>
        /// <param name="other">The specified FixedListByte512 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListByte512 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte512 and indicates whether this instance
        /// is equal to the specified FixedListByte512.
        /// </summary>
        /// <param name="other">The specified FixedListByte512 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListByte512 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListByte32 that is a copy of a FixedListByte512.
        /// </summary>
        /// <param name="other">The FixedListByte512 to copy</param>
        public FixedListByte32(in FixedListByte512 other)
        {
            FixedList.CheckResize<FixedBytes30,byte>(other.length);
            length = other.length;
            buffer = new FixedBytes30();
            unsafe
            {
                fixed(FixedBytes510* s = &other.buffer)
                fixed(FixedBytes30* d = &this.buffer)
                    *d = *(FixedBytes30*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListByte512 to a FixedListByte32.
        /// </summary>
        /// <param name="other">The FixedListByte512 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListByte32(in FixedListByte512 other)
        {
            return new FixedListByte32(other);
        }

        /// <summary>
        /// Determines whether a FixedListByte32 and FixedListByte4096 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte32 to compare for equality</param>
        /// <param name="b">The FixedListByte4096 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListByte32 a, in FixedListByte4096 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListByte32 and FixedListByte4096 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte32 to compare for inequality</param>
        /// <param name="b">The FixedListByte4096 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListByte32 a, in FixedListByte4096 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte4096 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte4096.
        /// </summary>
        /// <param name="other">The specified FixedListByte4096 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListByte4096 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte4096 and indicates whether this instance
        /// is equal to the specified FixedListByte4096.
        /// </summary>
        /// <param name="other">The specified FixedListByte4096 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListByte4096 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListByte32 that is a copy of a FixedListByte4096.
        /// </summary>
        /// <param name="other">The FixedListByte4096 to copy</param>
        public FixedListByte32(in FixedListByte4096 other)
        {
            FixedList.CheckResize<FixedBytes30,byte>(other.length);
            length = other.length;
            buffer = new FixedBytes30();
            unsafe
            {
                fixed(FixedBytes4094* s = &other.buffer)
                fixed(FixedBytes30* d = &this.buffer)
                    *d = *(FixedBytes30*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListByte4096 to a FixedListByte32.
        /// </summary>
        /// <param name="other">The FixedListByte4096 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListByte32(in FixedListByte4096 other)
        {
            return new FixedListByte32(other);
        }

        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        /// <returns></returns>
        [NotBurstCompatible]
        public override bool Equals(object obj)
        {
            if(obj is FixedListByte32 aFixedListByte32) return Equals(aFixedListByte32);
            if(obj is FixedListByte64 aFixedListByte64) return Equals(aFixedListByte64);
            if(obj is FixedListByte128 aFixedListByte128) return Equals(aFixedListByte128);
            if(obj is FixedListByte512 aFixedListByte512) return Equals(aFixedListByte512);
            if(obj is FixedListByte4096 aFixedListByte4096) return Equals(aFixedListByte4096);
            return false;
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        public struct Enumerator : IEnumerator<byte>
        {
            FixedListByte32 m_List;
            int m_Index;

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <param name="list"><undoc /></param>
            public Enumerator(ref FixedListByte32 list)
            {
                m_List = list;
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Dispose()
            {
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <returns><undoc /></returns>
            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Reset()
            {
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public byte Current => m_List[m_Index]; // Let FixedListByte32 indexer check for out of range.

            object IEnumerator.Current => Current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator IEnumerable.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator<byte> IEnumerable<byte>.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckCapacityInRange(int capacity)
        {
            if(capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }
    }

    sealed class FixedListByte32DebugView
    {
        FixedListByte32 m_List;
        public FixedListByte32DebugView(FixedListByte32 list)
        {
            m_List = list;
        }
        public byte[] Items => m_List.ToArray();
    }


    /// <summary>
    /// An unmanaged, resizable list of byte that does not allocate memory.
    /// It is 64 bytes in size, and contains all the memory it needs.
    /// </summary>
    [Serializable]
    [StructLayout(LayoutKind.Explicit, Size=64)]
    [DebuggerTypeProxy(typeof(FixedListByte64DebugView))]
    [BurstCompatible]
    public struct FixedListByte64
    : INativeList<byte>
    , IEnumerable<byte> // Used by collection initializers.
    , IEquatable<FixedListByte32>
    , IComparable<FixedListByte32>
    , IEquatable<FixedListByte64>
    , IComparable<FixedListByte64>
    , IEquatable<FixedListByte128>
    , IComparable<FixedListByte128>
    , IEquatable<FixedListByte512>
    , IComparable<FixedListByte512>
    , IEquatable<FixedListByte4096>
    , IComparable<FixedListByte4096>
    {
        [SerializeField] [FieldOffset(0)] internal ushort length;
        [SerializeField] [FieldOffset(2)] internal FixedBytes62 buffer;

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        [CreateProperty]
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize<FixedBytes62,byte>(value);
                length = (ushort)value;
            }
        }

        /// <summary>
        /// A property in order to display items in the Entity Inspector.
        /// </summary>
        [CreateProperty] IEnumerable<byte> Elements => this.ToArray();

        /// <summary>
        /// Reports whether container is empty.
        /// </summary>
        /// <value>True if this container empty.</value>
        public bool IsEmpty => Length == 0;

        internal int LengthInBytes => Length * sizeof(byte);

        unsafe internal byte* Buffer
        {
            get
            {
                fixed(byte* b = &buffer.offset0000.byte0000)
                    return b + FixedList.PaddingBytes<byte>();
            }
        }

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity
        {
            get
            {
                return FixedList.Capacity<FixedBytes62, byte>();
            }
            set
            {
                CheckCapacityInRange(value);
            }
        }

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public byte this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    return UnsafeUtility.ReadArrayElement<byte>(Buffer, index);
                }
            }
            set
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    UnsafeUtility.WriteArrayElement<byte>(Buffer, index, value);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public ref byte ElementAt(int index)
        {
            FixedList.CheckElementAccess(index, length);
            unsafe
            {
                return ref UnsafeUtility.ArrayElementAsRef<byte>(Buffer, index);
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedListByte64.
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                return (int)CollectionHelper.Hash(Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The byte to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void Add(in byte item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRange(void* ptr, int length)
        {
            byte* data = (byte*)ptr;
            for (var i = 0; i < length; ++i)
            {
                this[Length++] = data[i];
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The byte to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void AddNoResize(byte item) => Add(item);

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRangeNoResize(void* ptr, int length) => AddRange(ptr, length);

        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }

        /// <summary>
        /// Searches for the specified byte and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListByte64 that starts at the specified index and contains the specified
        /// number of elements.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte64.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <param name="count">The number of elements in the section to search.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(byte item, int index, int count)
        {
            for(var i = index; i < index + count; ++i)
                if(this[i].Equals(item))
                  return i;
            return -1;
        }

        /// <summary>
        /// Searches for the specified byte and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListByte64 that starts at the specified index.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte64.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(byte item, int index)
        {
            return IndexOf(item, index, Length - index);
        }

        /// <summary>
        /// Determines whether an element is in the FixedListByte64.
        /// </summary>
        /// <param name="item">The object to locate in the FixedListByte64.</param>
        /// <returns></returns>
        public bool Contains(byte item)
        {
            return IndexOf(item) >= 0;
        }

        /// <summary>
        /// Searches for the specified byte and returns the zero-based index of the first occurrence within the entire FixedListByte64.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte64.</param>
        /// <returns></returns>
        public int IndexOf(byte item)
        {
            for (var i = 0; i < length; ++i)
            {
                if (this[i].Equals(item))
                {
                    return i;
                }
            }

            return -1;
        }

        /// <summary>
        /// Inserts a number of items into a FixedListByte64 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="end">The zero-based index just after where the elements should be removed.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void InsertRangeWithBeginEnd(int begin, int end)
        {
            int items = end - begin;
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(byte);
            unsafe
            {
                byte* b = Buffer;
                byte *dest = b + end * sizeof(byte);
                byte *src = b + begin * sizeof(byte);
                UnsafeUtility.MemMove(dest, src, bytesToCopy);
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedListByte64 at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>
        public void Insert(int index, byte item)
        {
            InsertRangeWithBeginEnd(index, index+1);
            this[index] = item;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index with the last item in the list. The list
        /// is shortened by one.
        /// </summary>
        /// <param name="index">The index of the item to delete.</param>
        public void RemoveAtSwapBack(int index)
        {
            RemoveRangeSwapBackWithBeginEnd(index, index + 1);
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedListByte64 and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedListByte64.</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool RemoveSwapBack(byte item)
        {
            var index = IndexOf(item);
            if (index == -1)
            {
                return false;
            }

            RemoveAtSwapBack(index);
            return true;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index range with the items from the end the list. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeSwapBackWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                int copyFrom = math.max(Length - itemsToRemove, end);

                unsafe
                {
                    var sizeOf = sizeof(byte);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                }

                Length -= itemsToRemove;
            }
        }

        /// <summary>
        /// Removes the byte at the specified index, and copies all subsequent elements backward to fill the
        /// hole so created.
        /// </summary>
        /// <param name="index">The zero-based index at which to remove the byte</param>
        public void RemoveAt(int index)
        {
            RemoveRangeWithBeginEnd(index, index+1);
        }

        /// <summary>
        /// Searches for the specified byte from the begining of the FixedListByte64 forward, removes it if possible,
        /// and returns true if the byte was successfully removed.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte64</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool Remove(byte item)
        {
            int index = IndexOf(item);
            if (index < 0)
            {
                return false;
            }

            RemoveAt(index);

            return true;
        }

        /// <summary>
        /// Truncates the list by removing the items at the specified index range, and shifting all remaining items to replace removed items. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <remarks>
        /// This method of removing item(s) is useful only in case when list is ordered and user wants to preserve order
        /// in list after removal In majority of cases is not important and user should use more performant `RemoveRangeSwapBackWithBeginEnd`.
        /// </remarks>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                unsafe
                {
                    var sizeOf = sizeof(byte);
                    int copyFrom = math.min(begin + itemsToRemove, Length);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                    Length -= itemsToRemove;
                }
            }
        }

        /// <summary>
        /// Creates a managed Array of byte that is a copy of this FixedListByte64.
        /// </summary>
        /// <returns></returns>
        [NotBurstCompatible]
        public byte[] ToArray()
        {
            var result = new byte[Length];
            unsafe
            {
                byte* s = Buffer;
                fixed(byte* d = result)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArraybyte that is a copy of this FixedListByte64.
        /// </summary>
        /// <param name="allocator">A member of the
        /// [Unity.Collections.Allocator](https://docs.unity3d.com/ScriptReference/Unity.Collections.Allocator.html) enumeration.</param>
        /// <returns></returns>
        public NativeArray<byte> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                byte* s = Buffer;
                var copy = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<byte>(s, Length, Allocator.None);
                return new NativeArray<byte>(copy, allocator);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListByte64 in ascending order.
        /// </summary>
        public void Sort()
        {
            unsafe
            {
                NativeSortExtension.Sort((byte*)Buffer, length);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListByte64 using a custom comparison function.
        /// </summary>
        /// <typeparam name="U">The comparer type.</typeparam>
        /// <param name="comp">A comparison function that indicates whether one element in the array is less than, equal to, or greater than another element.</param>
        [BurstCompatible(GenericTypeArguments = new[] { typeof(NativeSortExtension.DefaultComparer<byte>) })]
        public void Sort<U>(U comp) where U : IComparer<byte>
        {
            unsafe
            {
                NativeSortExtension.Sort((byte*)Buffer, length, comp);
            }
        }


        /// <summary>
        /// Determines whether a FixedListByte64 and FixedListByte32 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte64 to compare for equality</param>
        /// <param name="b">The FixedListByte32 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListByte64 a, in FixedListByte32 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListByte64 and FixedListByte32 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte64 to compare for inequality</param>
        /// <param name="b">The FixedListByte32 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListByte64 a, in FixedListByte32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte32 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte32.
        /// </summary>
        /// <param name="other">The specified FixedListByte32 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListByte32 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte32 and indicates whether this instance
        /// is equal to the specified FixedListByte32.
        /// </summary>
        /// <param name="other">The specified FixedListByte32 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListByte32 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListByte64 that is a copy of a FixedListByte32.
        /// </summary>
        /// <param name="other">The FixedListByte32 to copy</param>
        public FixedListByte64(in FixedListByte32 other)
        {
            FixedList.CheckResize<FixedBytes62,byte>(other.length);
            length = other.length;
            buffer = new FixedBytes62();
            unsafe
            {
                fixed(FixedBytes30* s = &other.buffer)
                fixed(FixedBytes62* d = &this.buffer)
                    *(FixedBytes30*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListByte32 to a FixedListByte64.
        /// </summary>
        /// <param name="other">The FixedListByte32 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListByte64(in FixedListByte32 other)
        {
            return new FixedListByte64(other);
        }

        /// <summary>
        /// Determines whether a FixedListByte64 and FixedListByte64 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte64 to compare for equality</param>
        /// <param name="b">The FixedListByte64 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListByte64 a, in FixedListByte64 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListByte64 and FixedListByte64 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte64 to compare for inequality</param>
        /// <param name="b">The FixedListByte64 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListByte64 a, in FixedListByte64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte64 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte64.
        /// </summary>
        /// <param name="other">The specified FixedListByte64 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListByte64 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte64 and indicates whether this instance
        /// is equal to the specified FixedListByte64.
        /// </summary>
        /// <param name="other">The specified FixedListByte64 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListByte64 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Determines whether a FixedListByte64 and FixedListByte128 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte64 to compare for equality</param>
        /// <param name="b">The FixedListByte128 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListByte64 a, in FixedListByte128 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListByte64 and FixedListByte128 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte64 to compare for inequality</param>
        /// <param name="b">The FixedListByte128 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListByte64 a, in FixedListByte128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte128 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte128.
        /// </summary>
        /// <param name="other">The specified FixedListByte128 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListByte128 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte128 and indicates whether this instance
        /// is equal to the specified FixedListByte128.
        /// </summary>
        /// <param name="other">The specified FixedListByte128 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListByte128 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListByte64 that is a copy of a FixedListByte128.
        /// </summary>
        /// <param name="other">The FixedListByte128 to copy</param>
        public FixedListByte64(in FixedListByte128 other)
        {
            FixedList.CheckResize<FixedBytes62,byte>(other.length);
            length = other.length;
            buffer = new FixedBytes62();
            unsafe
            {
                fixed(FixedBytes126* s = &other.buffer)
                fixed(FixedBytes62* d = &this.buffer)
                    *d = *(FixedBytes62*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListByte128 to a FixedListByte64.
        /// </summary>
        /// <param name="other">The FixedListByte128 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListByte64(in FixedListByte128 other)
        {
            return new FixedListByte64(other);
        }

        /// <summary>
        /// Determines whether a FixedListByte64 and FixedListByte512 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte64 to compare for equality</param>
        /// <param name="b">The FixedListByte512 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListByte64 a, in FixedListByte512 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListByte64 and FixedListByte512 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte64 to compare for inequality</param>
        /// <param name="b">The FixedListByte512 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListByte64 a, in FixedListByte512 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte512 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte512.
        /// </summary>
        /// <param name="other">The specified FixedListByte512 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListByte512 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte512 and indicates whether this instance
        /// is equal to the specified FixedListByte512.
        /// </summary>
        /// <param name="other">The specified FixedListByte512 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListByte512 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListByte64 that is a copy of a FixedListByte512.
        /// </summary>
        /// <param name="other">The FixedListByte512 to copy</param>
        public FixedListByte64(in FixedListByte512 other)
        {
            FixedList.CheckResize<FixedBytes62,byte>(other.length);
            length = other.length;
            buffer = new FixedBytes62();
            unsafe
            {
                fixed(FixedBytes510* s = &other.buffer)
                fixed(FixedBytes62* d = &this.buffer)
                    *d = *(FixedBytes62*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListByte512 to a FixedListByte64.
        /// </summary>
        /// <param name="other">The FixedListByte512 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListByte64(in FixedListByte512 other)
        {
            return new FixedListByte64(other);
        }

        /// <summary>
        /// Determines whether a FixedListByte64 and FixedListByte4096 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte64 to compare for equality</param>
        /// <param name="b">The FixedListByte4096 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListByte64 a, in FixedListByte4096 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListByte64 and FixedListByte4096 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte64 to compare for inequality</param>
        /// <param name="b">The FixedListByte4096 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListByte64 a, in FixedListByte4096 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte4096 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte4096.
        /// </summary>
        /// <param name="other">The specified FixedListByte4096 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListByte4096 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte4096 and indicates whether this instance
        /// is equal to the specified FixedListByte4096.
        /// </summary>
        /// <param name="other">The specified FixedListByte4096 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListByte4096 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListByte64 that is a copy of a FixedListByte4096.
        /// </summary>
        /// <param name="other">The FixedListByte4096 to copy</param>
        public FixedListByte64(in FixedListByte4096 other)
        {
            FixedList.CheckResize<FixedBytes62,byte>(other.length);
            length = other.length;
            buffer = new FixedBytes62();
            unsafe
            {
                fixed(FixedBytes4094* s = &other.buffer)
                fixed(FixedBytes62* d = &this.buffer)
                    *d = *(FixedBytes62*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListByte4096 to a FixedListByte64.
        /// </summary>
        /// <param name="other">The FixedListByte4096 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListByte64(in FixedListByte4096 other)
        {
            return new FixedListByte64(other);
        }

        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        /// <returns></returns>
        [NotBurstCompatible]
        public override bool Equals(object obj)
        {
            if(obj is FixedListByte32 aFixedListByte32) return Equals(aFixedListByte32);
            if(obj is FixedListByte64 aFixedListByte64) return Equals(aFixedListByte64);
            if(obj is FixedListByte128 aFixedListByte128) return Equals(aFixedListByte128);
            if(obj is FixedListByte512 aFixedListByte512) return Equals(aFixedListByte512);
            if(obj is FixedListByte4096 aFixedListByte4096) return Equals(aFixedListByte4096);
            return false;
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        public struct Enumerator : IEnumerator<byte>
        {
            FixedListByte64 m_List;
            int m_Index;

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <param name="list"><undoc /></param>
            public Enumerator(ref FixedListByte64 list)
            {
                m_List = list;
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Dispose()
            {
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <returns><undoc /></returns>
            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Reset()
            {
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public byte Current => m_List[m_Index]; // Let FixedListByte64 indexer check for out of range.

            object IEnumerator.Current => Current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator IEnumerable.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator<byte> IEnumerable<byte>.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckCapacityInRange(int capacity)
        {
            if(capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }
    }

    sealed class FixedListByte64DebugView
    {
        FixedListByte64 m_List;
        public FixedListByte64DebugView(FixedListByte64 list)
        {
            m_List = list;
        }
        public byte[] Items => m_List.ToArray();
    }


    /// <summary>
    /// An unmanaged, resizable list of byte that does not allocate memory.
    /// It is 128 bytes in size, and contains all the memory it needs.
    /// </summary>
    [Serializable]
    [StructLayout(LayoutKind.Explicit, Size=128)]
    [DebuggerTypeProxy(typeof(FixedListByte128DebugView))]
    [BurstCompatible]
    public struct FixedListByte128
    : INativeList<byte>
    , IEnumerable<byte> // Used by collection initializers.
    , IEquatable<FixedListByte32>
    , IComparable<FixedListByte32>
    , IEquatable<FixedListByte64>
    , IComparable<FixedListByte64>
    , IEquatable<FixedListByte128>
    , IComparable<FixedListByte128>
    , IEquatable<FixedListByte512>
    , IComparable<FixedListByte512>
    , IEquatable<FixedListByte4096>
    , IComparable<FixedListByte4096>
    {
        [SerializeField] [FieldOffset(0)] internal ushort length;
        [SerializeField] [FieldOffset(2)] internal FixedBytes126 buffer;

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        [CreateProperty]
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize<FixedBytes126,byte>(value);
                length = (ushort)value;
            }
        }

        /// <summary>
        /// A property in order to display items in the Entity Inspector.
        /// </summary>
        [CreateProperty] IEnumerable<byte> Elements => this.ToArray();

        /// <summary>
        /// Reports whether container is empty.
        /// </summary>
        /// <value>True if this container empty.</value>
        public bool IsEmpty => Length == 0;

        internal int LengthInBytes => Length * sizeof(byte);

        unsafe internal byte* Buffer
        {
            get
            {
                fixed(byte* b = &buffer.offset0000.byte0000)
                    return b + FixedList.PaddingBytes<byte>();
            }
        }

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity
        {
            get
            {
                return FixedList.Capacity<FixedBytes126, byte>();
            }
            set
            {
                CheckCapacityInRange(value);
            }
        }

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public byte this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    return UnsafeUtility.ReadArrayElement<byte>(Buffer, index);
                }
            }
            set
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    UnsafeUtility.WriteArrayElement<byte>(Buffer, index, value);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public ref byte ElementAt(int index)
        {
            FixedList.CheckElementAccess(index, length);
            unsafe
            {
                return ref UnsafeUtility.ArrayElementAsRef<byte>(Buffer, index);
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedListByte128.
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                return (int)CollectionHelper.Hash(Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The byte to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void Add(in byte item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRange(void* ptr, int length)
        {
            byte* data = (byte*)ptr;
            for (var i = 0; i < length; ++i)
            {
                this[Length++] = data[i];
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The byte to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void AddNoResize(byte item) => Add(item);

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRangeNoResize(void* ptr, int length) => AddRange(ptr, length);

        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }

        /// <summary>
        /// Searches for the specified byte and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListByte128 that starts at the specified index and contains the specified
        /// number of elements.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte128.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <param name="count">The number of elements in the section to search.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(byte item, int index, int count)
        {
            for(var i = index; i < index + count; ++i)
                if(this[i].Equals(item))
                  return i;
            return -1;
        }

        /// <summary>
        /// Searches for the specified byte and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListByte128 that starts at the specified index.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte128.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(byte item, int index)
        {
            return IndexOf(item, index, Length - index);
        }

        /// <summary>
        /// Determines whether an element is in the FixedListByte128.
        /// </summary>
        /// <param name="item">The object to locate in the FixedListByte128.</param>
        /// <returns></returns>
        public bool Contains(byte item)
        {
            return IndexOf(item) >= 0;
        }

        /// <summary>
        /// Searches for the specified byte and returns the zero-based index of the first occurrence within the entire FixedListByte128.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte128.</param>
        /// <returns></returns>
        public int IndexOf(byte item)
        {
            for (var i = 0; i < length; ++i)
            {
                if (this[i].Equals(item))
                {
                    return i;
                }
            }

            return -1;
        }

        /// <summary>
        /// Inserts a number of items into a FixedListByte128 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="end">The zero-based index just after where the elements should be removed.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void InsertRangeWithBeginEnd(int begin, int end)
        {
            int items = end - begin;
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(byte);
            unsafe
            {
                byte* b = Buffer;
                byte *dest = b + end * sizeof(byte);
                byte *src = b + begin * sizeof(byte);
                UnsafeUtility.MemMove(dest, src, bytesToCopy);
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedListByte128 at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>
        public void Insert(int index, byte item)
        {
            InsertRangeWithBeginEnd(index, index+1);
            this[index] = item;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index with the last item in the list. The list
        /// is shortened by one.
        /// </summary>
        /// <param name="index">The index of the item to delete.</param>
        public void RemoveAtSwapBack(int index)
        {
            RemoveRangeSwapBackWithBeginEnd(index, index + 1);
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedListByte128 and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedListByte128.</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool RemoveSwapBack(byte item)
        {
            var index = IndexOf(item);
            if (index == -1)
            {
                return false;
            }

            RemoveAtSwapBack(index);
            return true;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index range with the items from the end the list. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeSwapBackWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                int copyFrom = math.max(Length - itemsToRemove, end);

                unsafe
                {
                    var sizeOf = sizeof(byte);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                }

                Length -= itemsToRemove;
            }
        }

        /// <summary>
        /// Removes the byte at the specified index, and copies all subsequent elements backward to fill the
        /// hole so created.
        /// </summary>
        /// <param name="index">The zero-based index at which to remove the byte</param>
        public void RemoveAt(int index)
        {
            RemoveRangeWithBeginEnd(index, index+1);
        }

        /// <summary>
        /// Searches for the specified byte from the begining of the FixedListByte128 forward, removes it if possible,
        /// and returns true if the byte was successfully removed.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte128</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool Remove(byte item)
        {
            int index = IndexOf(item);
            if (index < 0)
            {
                return false;
            }

            RemoveAt(index);

            return true;
        }

        /// <summary>
        /// Truncates the list by removing the items at the specified index range, and shifting all remaining items to replace removed items. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <remarks>
        /// This method of removing item(s) is useful only in case when list is ordered and user wants to preserve order
        /// in list after removal In majority of cases is not important and user should use more performant `RemoveRangeSwapBackWithBeginEnd`.
        /// </remarks>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                unsafe
                {
                    var sizeOf = sizeof(byte);
                    int copyFrom = math.min(begin + itemsToRemove, Length);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                    Length -= itemsToRemove;
                }
            }
        }

        /// <summary>
        /// Creates a managed Array of byte that is a copy of this FixedListByte128.
        /// </summary>
        /// <returns></returns>
        [NotBurstCompatible]
        public byte[] ToArray()
        {
            var result = new byte[Length];
            unsafe
            {
                byte* s = Buffer;
                fixed(byte* d = result)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArraybyte that is a copy of this FixedListByte128.
        /// </summary>
        /// <param name="allocator">A member of the
        /// [Unity.Collections.Allocator](https://docs.unity3d.com/ScriptReference/Unity.Collections.Allocator.html) enumeration.</param>
        /// <returns></returns>
        public NativeArray<byte> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                byte* s = Buffer;
                var copy = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<byte>(s, Length, Allocator.None);
                return new NativeArray<byte>(copy, allocator);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListByte128 in ascending order.
        /// </summary>
        public void Sort()
        {
            unsafe
            {
                NativeSortExtension.Sort((byte*)Buffer, length);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListByte128 using a custom comparison function.
        /// </summary>
        /// <typeparam name="U">The comparer type.</typeparam>
        /// <param name="comp">A comparison function that indicates whether one element in the array is less than, equal to, or greater than another element.</param>
        [BurstCompatible(GenericTypeArguments = new[] { typeof(NativeSortExtension.DefaultComparer<byte>) })]
        public void Sort<U>(U comp) where U : IComparer<byte>
        {
            unsafe
            {
                NativeSortExtension.Sort((byte*)Buffer, length, comp);
            }
        }


        /// <summary>
        /// Determines whether a FixedListByte128 and FixedListByte32 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte128 to compare for equality</param>
        /// <param name="b">The FixedListByte32 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListByte128 a, in FixedListByte32 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListByte128 and FixedListByte32 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte128 to compare for inequality</param>
        /// <param name="b">The FixedListByte32 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListByte128 a, in FixedListByte32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte32 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte32.
        /// </summary>
        /// <param name="other">The specified FixedListByte32 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListByte32 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte32 and indicates whether this instance
        /// is equal to the specified FixedListByte32.
        /// </summary>
        /// <param name="other">The specified FixedListByte32 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListByte32 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListByte128 that is a copy of a FixedListByte32.
        /// </summary>
        /// <param name="other">The FixedListByte32 to copy</param>
        public FixedListByte128(in FixedListByte32 other)
        {
            FixedList.CheckResize<FixedBytes126,byte>(other.length);
            length = other.length;
            buffer = new FixedBytes126();
            unsafe
            {
                fixed(FixedBytes30* s = &other.buffer)
                fixed(FixedBytes126* d = &this.buffer)
                    *(FixedBytes30*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListByte32 to a FixedListByte128.
        /// </summary>
        /// <param name="other">The FixedListByte32 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListByte128(in FixedListByte32 other)
        {
            return new FixedListByte128(other);
        }

        /// <summary>
        /// Determines whether a FixedListByte128 and FixedListByte64 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte128 to compare for equality</param>
        /// <param name="b">The FixedListByte64 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListByte128 a, in FixedListByte64 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListByte128 and FixedListByte64 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte128 to compare for inequality</param>
        /// <param name="b">The FixedListByte64 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListByte128 a, in FixedListByte64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte64 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte64.
        /// </summary>
        /// <param name="other">The specified FixedListByte64 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListByte64 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte64 and indicates whether this instance
        /// is equal to the specified FixedListByte64.
        /// </summary>
        /// <param name="other">The specified FixedListByte64 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListByte64 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListByte128 that is a copy of a FixedListByte64.
        /// </summary>
        /// <param name="other">The FixedListByte64 to copy</param>
        public FixedListByte128(in FixedListByte64 other)
        {
            FixedList.CheckResize<FixedBytes126,byte>(other.length);
            length = other.length;
            buffer = new FixedBytes126();
            unsafe
            {
                fixed(FixedBytes62* s = &other.buffer)
                fixed(FixedBytes126* d = &this.buffer)
                    *(FixedBytes62*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListByte64 to a FixedListByte128.
        /// </summary>
        /// <param name="other">The FixedListByte64 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListByte128(in FixedListByte64 other)
        {
            return new FixedListByte128(other);
        }

        /// <summary>
        /// Determines whether a FixedListByte128 and FixedListByte128 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte128 to compare for equality</param>
        /// <param name="b">The FixedListByte128 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListByte128 a, in FixedListByte128 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListByte128 and FixedListByte128 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte128 to compare for inequality</param>
        /// <param name="b">The FixedListByte128 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListByte128 a, in FixedListByte128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte128 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte128.
        /// </summary>
        /// <param name="other">The specified FixedListByte128 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListByte128 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte128 and indicates whether this instance
        /// is equal to the specified FixedListByte128.
        /// </summary>
        /// <param name="other">The specified FixedListByte128 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListByte128 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Determines whether a FixedListByte128 and FixedListByte512 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte128 to compare for equality</param>
        /// <param name="b">The FixedListByte512 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListByte128 a, in FixedListByte512 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListByte128 and FixedListByte512 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte128 to compare for inequality</param>
        /// <param name="b">The FixedListByte512 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListByte128 a, in FixedListByte512 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte512 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte512.
        /// </summary>
        /// <param name="other">The specified FixedListByte512 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListByte512 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte512 and indicates whether this instance
        /// is equal to the specified FixedListByte512.
        /// </summary>
        /// <param name="other">The specified FixedListByte512 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListByte512 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListByte128 that is a copy of a FixedListByte512.
        /// </summary>
        /// <param name="other">The FixedListByte512 to copy</param>
        public FixedListByte128(in FixedListByte512 other)
        {
            FixedList.CheckResize<FixedBytes126,byte>(other.length);
            length = other.length;
            buffer = new FixedBytes126();
            unsafe
            {
                fixed(FixedBytes510* s = &other.buffer)
                fixed(FixedBytes126* d = &this.buffer)
                    *d = *(FixedBytes126*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListByte512 to a FixedListByte128.
        /// </summary>
        /// <param name="other">The FixedListByte512 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListByte128(in FixedListByte512 other)
        {
            return new FixedListByte128(other);
        }

        /// <summary>
        /// Determines whether a FixedListByte128 and FixedListByte4096 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte128 to compare for equality</param>
        /// <param name="b">The FixedListByte4096 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListByte128 a, in FixedListByte4096 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListByte128 and FixedListByte4096 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte128 to compare for inequality</param>
        /// <param name="b">The FixedListByte4096 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListByte128 a, in FixedListByte4096 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte4096 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte4096.
        /// </summary>
        /// <param name="other">The specified FixedListByte4096 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListByte4096 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte4096 and indicates whether this instance
        /// is equal to the specified FixedListByte4096.
        /// </summary>
        /// <param name="other">The specified FixedListByte4096 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListByte4096 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListByte128 that is a copy of a FixedListByte4096.
        /// </summary>
        /// <param name="other">The FixedListByte4096 to copy</param>
        public FixedListByte128(in FixedListByte4096 other)
        {
            FixedList.CheckResize<FixedBytes126,byte>(other.length);
            length = other.length;
            buffer = new FixedBytes126();
            unsafe
            {
                fixed(FixedBytes4094* s = &other.buffer)
                fixed(FixedBytes126* d = &this.buffer)
                    *d = *(FixedBytes126*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListByte4096 to a FixedListByte128.
        /// </summary>
        /// <param name="other">The FixedListByte4096 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListByte128(in FixedListByte4096 other)
        {
            return new FixedListByte128(other);
        }

        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        /// <returns></returns>
        [NotBurstCompatible]
        public override bool Equals(object obj)
        {
            if(obj is FixedListByte32 aFixedListByte32) return Equals(aFixedListByte32);
            if(obj is FixedListByte64 aFixedListByte64) return Equals(aFixedListByte64);
            if(obj is FixedListByte128 aFixedListByte128) return Equals(aFixedListByte128);
            if(obj is FixedListByte512 aFixedListByte512) return Equals(aFixedListByte512);
            if(obj is FixedListByte4096 aFixedListByte4096) return Equals(aFixedListByte4096);
            return false;
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        public struct Enumerator : IEnumerator<byte>
        {
            FixedListByte128 m_List;
            int m_Index;

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <param name="list"><undoc /></param>
            public Enumerator(ref FixedListByte128 list)
            {
                m_List = list;
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Dispose()
            {
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <returns><undoc /></returns>
            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Reset()
            {
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public byte Current => m_List[m_Index]; // Let FixedListByte128 indexer check for out of range.

            object IEnumerator.Current => Current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator IEnumerable.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator<byte> IEnumerable<byte>.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckCapacityInRange(int capacity)
        {
            if(capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }
    }

    sealed class FixedListByte128DebugView
    {
        FixedListByte128 m_List;
        public FixedListByte128DebugView(FixedListByte128 list)
        {
            m_List = list;
        }
        public byte[] Items => m_List.ToArray();
    }


    /// <summary>
    /// An unmanaged, resizable list of byte that does not allocate memory.
    /// It is 512 bytes in size, and contains all the memory it needs.
    /// </summary>
    [Serializable]
    [StructLayout(LayoutKind.Explicit, Size=512)]
    [DebuggerTypeProxy(typeof(FixedListByte512DebugView))]
    [BurstCompatible]
    public struct FixedListByte512
    : INativeList<byte>
    , IEnumerable<byte> // Used by collection initializers.
    , IEquatable<FixedListByte32>
    , IComparable<FixedListByte32>
    , IEquatable<FixedListByte64>
    , IComparable<FixedListByte64>
    , IEquatable<FixedListByte128>
    , IComparable<FixedListByte128>
    , IEquatable<FixedListByte512>
    , IComparable<FixedListByte512>
    , IEquatable<FixedListByte4096>
    , IComparable<FixedListByte4096>
    {
        [SerializeField] [FieldOffset(0)] internal ushort length;
        [SerializeField] [FieldOffset(2)] internal FixedBytes510 buffer;

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        [CreateProperty]
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize<FixedBytes510,byte>(value);
                length = (ushort)value;
            }
        }

        /// <summary>
        /// A property in order to display items in the Entity Inspector.
        /// </summary>
        [CreateProperty] IEnumerable<byte> Elements => this.ToArray();

        /// <summary>
        /// Reports whether container is empty.
        /// </summary>
        /// <value>True if this container empty.</value>
        public bool IsEmpty => Length == 0;

        internal int LengthInBytes => Length * sizeof(byte);

        unsafe internal byte* Buffer
        {
            get
            {
                fixed(byte* b = &buffer.offset0000.byte0000)
                    return b + FixedList.PaddingBytes<byte>();
            }
        }

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity
        {
            get
            {
                return FixedList.Capacity<FixedBytes510, byte>();
            }
            set
            {
                CheckCapacityInRange(value);
            }
        }

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public byte this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    return UnsafeUtility.ReadArrayElement<byte>(Buffer, index);
                }
            }
            set
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    UnsafeUtility.WriteArrayElement<byte>(Buffer, index, value);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public ref byte ElementAt(int index)
        {
            FixedList.CheckElementAccess(index, length);
            unsafe
            {
                return ref UnsafeUtility.ArrayElementAsRef<byte>(Buffer, index);
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedListByte512.
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                return (int)CollectionHelper.Hash(Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The byte to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void Add(in byte item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRange(void* ptr, int length)
        {
            byte* data = (byte*)ptr;
            for (var i = 0; i < length; ++i)
            {
                this[Length++] = data[i];
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The byte to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void AddNoResize(byte item) => Add(item);

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRangeNoResize(void* ptr, int length) => AddRange(ptr, length);

        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }

        /// <summary>
        /// Searches for the specified byte and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListByte512 that starts at the specified index and contains the specified
        /// number of elements.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte512.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <param name="count">The number of elements in the section to search.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(byte item, int index, int count)
        {
            for(var i = index; i < index + count; ++i)
                if(this[i].Equals(item))
                  return i;
            return -1;
        }

        /// <summary>
        /// Searches for the specified byte and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListByte512 that starts at the specified index.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte512.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(byte item, int index)
        {
            return IndexOf(item, index, Length - index);
        }

        /// <summary>
        /// Determines whether an element is in the FixedListByte512.
        /// </summary>
        /// <param name="item">The object to locate in the FixedListByte512.</param>
        /// <returns></returns>
        public bool Contains(byte item)
        {
            return IndexOf(item) >= 0;
        }

        /// <summary>
        /// Searches for the specified byte and returns the zero-based index of the first occurrence within the entire FixedListByte512.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte512.</param>
        /// <returns></returns>
        public int IndexOf(byte item)
        {
            for (var i = 0; i < length; ++i)
            {
                if (this[i].Equals(item))
                {
                    return i;
                }
            }

            return -1;
        }

        /// <summary>
        /// Inserts a number of items into a FixedListByte512 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="end">The zero-based index just after where the elements should be removed.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void InsertRangeWithBeginEnd(int begin, int end)
        {
            int items = end - begin;
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(byte);
            unsafe
            {
                byte* b = Buffer;
                byte *dest = b + end * sizeof(byte);
                byte *src = b + begin * sizeof(byte);
                UnsafeUtility.MemMove(dest, src, bytesToCopy);
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedListByte512 at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>
        public void Insert(int index, byte item)
        {
            InsertRangeWithBeginEnd(index, index+1);
            this[index] = item;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index with the last item in the list. The list
        /// is shortened by one.
        /// </summary>
        /// <param name="index">The index of the item to delete.</param>
        public void RemoveAtSwapBack(int index)
        {
            RemoveRangeSwapBackWithBeginEnd(index, index + 1);
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedListByte512 and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedListByte512.</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool RemoveSwapBack(byte item)
        {
            var index = IndexOf(item);
            if (index == -1)
            {
                return false;
            }

            RemoveAtSwapBack(index);
            return true;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index range with the items from the end the list. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeSwapBackWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                int copyFrom = math.max(Length - itemsToRemove, end);

                unsafe
                {
                    var sizeOf = sizeof(byte);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                }

                Length -= itemsToRemove;
            }
        }

        /// <summary>
        /// Removes the byte at the specified index, and copies all subsequent elements backward to fill the
        /// hole so created.
        /// </summary>
        /// <param name="index">The zero-based index at which to remove the byte</param>
        public void RemoveAt(int index)
        {
            RemoveRangeWithBeginEnd(index, index+1);
        }

        /// <summary>
        /// Searches for the specified byte from the begining of the FixedListByte512 forward, removes it if possible,
        /// and returns true if the byte was successfully removed.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte512</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool Remove(byte item)
        {
            int index = IndexOf(item);
            if (index < 0)
            {
                return false;
            }

            RemoveAt(index);

            return true;
        }

        /// <summary>
        /// Truncates the list by removing the items at the specified index range, and shifting all remaining items to replace removed items. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <remarks>
        /// This method of removing item(s) is useful only in case when list is ordered and user wants to preserve order
        /// in list after removal In majority of cases is not important and user should use more performant `RemoveRangeSwapBackWithBeginEnd`.
        /// </remarks>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                unsafe
                {
                    var sizeOf = sizeof(byte);
                    int copyFrom = math.min(begin + itemsToRemove, Length);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                    Length -= itemsToRemove;
                }
            }
        }

        /// <summary>
        /// Creates a managed Array of byte that is a copy of this FixedListByte512.
        /// </summary>
        /// <returns></returns>
        [NotBurstCompatible]
        public byte[] ToArray()
        {
            var result = new byte[Length];
            unsafe
            {
                byte* s = Buffer;
                fixed(byte* d = result)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArraybyte that is a copy of this FixedListByte512.
        /// </summary>
        /// <param name="allocator">A member of the
        /// [Unity.Collections.Allocator](https://docs.unity3d.com/ScriptReference/Unity.Collections.Allocator.html) enumeration.</param>
        /// <returns></returns>
        public NativeArray<byte> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                byte* s = Buffer;
                var copy = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<byte>(s, Length, Allocator.None);
                return new NativeArray<byte>(copy, allocator);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListByte512 in ascending order.
        /// </summary>
        public void Sort()
        {
            unsafe
            {
                NativeSortExtension.Sort((byte*)Buffer, length);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListByte512 using a custom comparison function.
        /// </summary>
        /// <typeparam name="U">The comparer type.</typeparam>
        /// <param name="comp">A comparison function that indicates whether one element in the array is less than, equal to, or greater than another element.</param>
        [BurstCompatible(GenericTypeArguments = new[] { typeof(NativeSortExtension.DefaultComparer<byte>) })]
        public void Sort<U>(U comp) where U : IComparer<byte>
        {
            unsafe
            {
                NativeSortExtension.Sort((byte*)Buffer, length, comp);
            }
        }


        /// <summary>
        /// Determines whether a FixedListByte512 and FixedListByte32 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte512 to compare for equality</param>
        /// <param name="b">The FixedListByte32 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListByte512 a, in FixedListByte32 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListByte512 and FixedListByte32 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte512 to compare for inequality</param>
        /// <param name="b">The FixedListByte32 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListByte512 a, in FixedListByte32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte32 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte32.
        /// </summary>
        /// <param name="other">The specified FixedListByte32 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListByte32 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte32 and indicates whether this instance
        /// is equal to the specified FixedListByte32.
        /// </summary>
        /// <param name="other">The specified FixedListByte32 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListByte32 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListByte512 that is a copy of a FixedListByte32.
        /// </summary>
        /// <param name="other">The FixedListByte32 to copy</param>
        public FixedListByte512(in FixedListByte32 other)
        {
            FixedList.CheckResize<FixedBytes510,byte>(other.length);
            length = other.length;
            buffer = new FixedBytes510();
            unsafe
            {
                fixed(FixedBytes30* s = &other.buffer)
                fixed(FixedBytes510* d = &this.buffer)
                    *(FixedBytes30*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListByte32 to a FixedListByte512.
        /// </summary>
        /// <param name="other">The FixedListByte32 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListByte512(in FixedListByte32 other)
        {
            return new FixedListByte512(other);
        }

        /// <summary>
        /// Determines whether a FixedListByte512 and FixedListByte64 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte512 to compare for equality</param>
        /// <param name="b">The FixedListByte64 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListByte512 a, in FixedListByte64 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListByte512 and FixedListByte64 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte512 to compare for inequality</param>
        /// <param name="b">The FixedListByte64 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListByte512 a, in FixedListByte64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte64 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte64.
        /// </summary>
        /// <param name="other">The specified FixedListByte64 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListByte64 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte64 and indicates whether this instance
        /// is equal to the specified FixedListByte64.
        /// </summary>
        /// <param name="other">The specified FixedListByte64 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListByte64 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListByte512 that is a copy of a FixedListByte64.
        /// </summary>
        /// <param name="other">The FixedListByte64 to copy</param>
        public FixedListByte512(in FixedListByte64 other)
        {
            FixedList.CheckResize<FixedBytes510,byte>(other.length);
            length = other.length;
            buffer = new FixedBytes510();
            unsafe
            {
                fixed(FixedBytes62* s = &other.buffer)
                fixed(FixedBytes510* d = &this.buffer)
                    *(FixedBytes62*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListByte64 to a FixedListByte512.
        /// </summary>
        /// <param name="other">The FixedListByte64 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListByte512(in FixedListByte64 other)
        {
            return new FixedListByte512(other);
        }

        /// <summary>
        /// Determines whether a FixedListByte512 and FixedListByte128 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte512 to compare for equality</param>
        /// <param name="b">The FixedListByte128 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListByte512 a, in FixedListByte128 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListByte512 and FixedListByte128 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte512 to compare for inequality</param>
        /// <param name="b">The FixedListByte128 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListByte512 a, in FixedListByte128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte128 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte128.
        /// </summary>
        /// <param name="other">The specified FixedListByte128 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListByte128 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte128 and indicates whether this instance
        /// is equal to the specified FixedListByte128.
        /// </summary>
        /// <param name="other">The specified FixedListByte128 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListByte128 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListByte512 that is a copy of a FixedListByte128.
        /// </summary>
        /// <param name="other">The FixedListByte128 to copy</param>
        public FixedListByte512(in FixedListByte128 other)
        {
            FixedList.CheckResize<FixedBytes510,byte>(other.length);
            length = other.length;
            buffer = new FixedBytes510();
            unsafe
            {
                fixed(FixedBytes126* s = &other.buffer)
                fixed(FixedBytes510* d = &this.buffer)
                    *(FixedBytes126*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListByte128 to a FixedListByte512.
        /// </summary>
        /// <param name="other">The FixedListByte128 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListByte512(in FixedListByte128 other)
        {
            return new FixedListByte512(other);
        }

        /// <summary>
        /// Determines whether a FixedListByte512 and FixedListByte512 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte512 to compare for equality</param>
        /// <param name="b">The FixedListByte512 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListByte512 a, in FixedListByte512 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListByte512 and FixedListByte512 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte512 to compare for inequality</param>
        /// <param name="b">The FixedListByte512 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListByte512 a, in FixedListByte512 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte512 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte512.
        /// </summary>
        /// <param name="other">The specified FixedListByte512 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListByte512 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte512 and indicates whether this instance
        /// is equal to the specified FixedListByte512.
        /// </summary>
        /// <param name="other">The specified FixedListByte512 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListByte512 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Determines whether a FixedListByte512 and FixedListByte4096 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte512 to compare for equality</param>
        /// <param name="b">The FixedListByte4096 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListByte512 a, in FixedListByte4096 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListByte512 and FixedListByte4096 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte512 to compare for inequality</param>
        /// <param name="b">The FixedListByte4096 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListByte512 a, in FixedListByte4096 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte4096 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte4096.
        /// </summary>
        /// <param name="other">The specified FixedListByte4096 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListByte4096 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte4096 and indicates whether this instance
        /// is equal to the specified FixedListByte4096.
        /// </summary>
        /// <param name="other">The specified FixedListByte4096 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListByte4096 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListByte512 that is a copy of a FixedListByte4096.
        /// </summary>
        /// <param name="other">The FixedListByte4096 to copy</param>
        public FixedListByte512(in FixedListByte4096 other)
        {
            FixedList.CheckResize<FixedBytes510,byte>(other.length);
            length = other.length;
            buffer = new FixedBytes510();
            unsafe
            {
                fixed(FixedBytes4094* s = &other.buffer)
                fixed(FixedBytes510* d = &this.buffer)
                    *d = *(FixedBytes510*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListByte4096 to a FixedListByte512.
        /// </summary>
        /// <param name="other">The FixedListByte4096 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListByte512(in FixedListByte4096 other)
        {
            return new FixedListByte512(other);
        }

        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        /// <returns></returns>
        [NotBurstCompatible]
        public override bool Equals(object obj)
        {
            if(obj is FixedListByte32 aFixedListByte32) return Equals(aFixedListByte32);
            if(obj is FixedListByte64 aFixedListByte64) return Equals(aFixedListByte64);
            if(obj is FixedListByte128 aFixedListByte128) return Equals(aFixedListByte128);
            if(obj is FixedListByte512 aFixedListByte512) return Equals(aFixedListByte512);
            if(obj is FixedListByte4096 aFixedListByte4096) return Equals(aFixedListByte4096);
            return false;
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        public struct Enumerator : IEnumerator<byte>
        {
            FixedListByte512 m_List;
            int m_Index;

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <param name="list"><undoc /></param>
            public Enumerator(ref FixedListByte512 list)
            {
                m_List = list;
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Dispose()
            {
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <returns><undoc /></returns>
            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Reset()
            {
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public byte Current => m_List[m_Index]; // Let FixedListByte512 indexer check for out of range.

            object IEnumerator.Current => Current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator IEnumerable.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator<byte> IEnumerable<byte>.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckCapacityInRange(int capacity)
        {
            if(capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }
    }

    sealed class FixedListByte512DebugView
    {
        FixedListByte512 m_List;
        public FixedListByte512DebugView(FixedListByte512 list)
        {
            m_List = list;
        }
        public byte[] Items => m_List.ToArray();
    }


    /// <summary>
    /// An unmanaged, resizable list of byte that does not allocate memory.
    /// It is 4096 bytes in size, and contains all the memory it needs.
    /// </summary>
    [Serializable]
    [StructLayout(LayoutKind.Explicit, Size=4096)]
    [DebuggerTypeProxy(typeof(FixedListByte4096DebugView))]
    [BurstCompatible]
    public struct FixedListByte4096
    : INativeList<byte>
    , IEnumerable<byte> // Used by collection initializers.
    , IEquatable<FixedListByte32>
    , IComparable<FixedListByte32>
    , IEquatable<FixedListByte64>
    , IComparable<FixedListByte64>
    , IEquatable<FixedListByte128>
    , IComparable<FixedListByte128>
    , IEquatable<FixedListByte512>
    , IComparable<FixedListByte512>
    , IEquatable<FixedListByte4096>
    , IComparable<FixedListByte4096>
    {
        [SerializeField] [FieldOffset(0)] internal ushort length;
        [SerializeField] [FieldOffset(2)] internal FixedBytes4094 buffer;

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        [CreateProperty]
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize<FixedBytes4094,byte>(value);
                length = (ushort)value;
            }
        }

        /// <summary>
        /// A property in order to display items in the Entity Inspector.
        /// </summary>
        [CreateProperty] IEnumerable<byte> Elements => this.ToArray();

        /// <summary>
        /// Reports whether container is empty.
        /// </summary>
        /// <value>True if this container empty.</value>
        public bool IsEmpty => Length == 0;

        internal int LengthInBytes => Length * sizeof(byte);

        unsafe internal byte* Buffer
        {
            get
            {
                fixed(byte* b = &buffer.offset0000.byte0000)
                    return b + FixedList.PaddingBytes<byte>();
            }
        }

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity
        {
            get
            {
                return FixedList.Capacity<FixedBytes4094, byte>();
            }
            set
            {
                CheckCapacityInRange(value);
            }
        }

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public byte this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    return UnsafeUtility.ReadArrayElement<byte>(Buffer, index);
                }
            }
            set
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    UnsafeUtility.WriteArrayElement<byte>(Buffer, index, value);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public ref byte ElementAt(int index)
        {
            FixedList.CheckElementAccess(index, length);
            unsafe
            {
                return ref UnsafeUtility.ArrayElementAsRef<byte>(Buffer, index);
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedListByte4096.
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                return (int)CollectionHelper.Hash(Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The byte to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void Add(in byte item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRange(void* ptr, int length)
        {
            byte* data = (byte*)ptr;
            for (var i = 0; i < length; ++i)
            {
                this[Length++] = data[i];
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The byte to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void AddNoResize(byte item) => Add(item);

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRangeNoResize(void* ptr, int length) => AddRange(ptr, length);

        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }

        /// <summary>
        /// Searches for the specified byte and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListByte4096 that starts at the specified index and contains the specified
        /// number of elements.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte4096.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <param name="count">The number of elements in the section to search.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(byte item, int index, int count)
        {
            for(var i = index; i < index + count; ++i)
                if(this[i].Equals(item))
                  return i;
            return -1;
        }

        /// <summary>
        /// Searches for the specified byte and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListByte4096 that starts at the specified index.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte4096.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(byte item, int index)
        {
            return IndexOf(item, index, Length - index);
        }

        /// <summary>
        /// Determines whether an element is in the FixedListByte4096.
        /// </summary>
        /// <param name="item">The object to locate in the FixedListByte4096.</param>
        /// <returns></returns>
        public bool Contains(byte item)
        {
            return IndexOf(item) >= 0;
        }

        /// <summary>
        /// Searches for the specified byte and returns the zero-based index of the first occurrence within the entire FixedListByte4096.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte4096.</param>
        /// <returns></returns>
        public int IndexOf(byte item)
        {
            for (var i = 0; i < length; ++i)
            {
                if (this[i].Equals(item))
                {
                    return i;
                }
            }

            return -1;
        }

        /// <summary>
        /// Inserts a number of items into a FixedListByte4096 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="end">The zero-based index just after where the elements should be removed.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void InsertRangeWithBeginEnd(int begin, int end)
        {
            int items = end - begin;
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(byte);
            unsafe
            {
                byte* b = Buffer;
                byte *dest = b + end * sizeof(byte);
                byte *src = b + begin * sizeof(byte);
                UnsafeUtility.MemMove(dest, src, bytesToCopy);
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedListByte4096 at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>
        public void Insert(int index, byte item)
        {
            InsertRangeWithBeginEnd(index, index+1);
            this[index] = item;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index with the last item in the list. The list
        /// is shortened by one.
        /// </summary>
        /// <param name="index">The index of the item to delete.</param>
        public void RemoveAtSwapBack(int index)
        {
            RemoveRangeSwapBackWithBeginEnd(index, index + 1);
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedListByte4096 and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedListByte4096.</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool RemoveSwapBack(byte item)
        {
            var index = IndexOf(item);
            if (index == -1)
            {
                return false;
            }

            RemoveAtSwapBack(index);
            return true;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index range with the items from the end the list. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeSwapBackWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                int copyFrom = math.max(Length - itemsToRemove, end);

                unsafe
                {
                    var sizeOf = sizeof(byte);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                }

                Length -= itemsToRemove;
            }
        }

        /// <summary>
        /// Removes the byte at the specified index, and copies all subsequent elements backward to fill the
        /// hole so created.
        /// </summary>
        /// <param name="index">The zero-based index at which to remove the byte</param>
        public void RemoveAt(int index)
        {
            RemoveRangeWithBeginEnd(index, index+1);
        }

        /// <summary>
        /// Searches for the specified byte from the begining of the FixedListByte4096 forward, removes it if possible,
        /// and returns true if the byte was successfully removed.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte4096</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool Remove(byte item)
        {
            int index = IndexOf(item);
            if (index < 0)
            {
                return false;
            }

            RemoveAt(index);

            return true;
        }

        /// <summary>
        /// Truncates the list by removing the items at the specified index range, and shifting all remaining items to replace removed items. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <remarks>
        /// This method of removing item(s) is useful only in case when list is ordered and user wants to preserve order
        /// in list after removal In majority of cases is not important and user should use more performant `RemoveRangeSwapBackWithBeginEnd`.
        /// </remarks>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                unsafe
                {
                    var sizeOf = sizeof(byte);
                    int copyFrom = math.min(begin + itemsToRemove, Length);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                    Length -= itemsToRemove;
                }
            }
        }

        /// <summary>
        /// Creates a managed Array of byte that is a copy of this FixedListByte4096.
        /// </summary>
        /// <returns></returns>
        [NotBurstCompatible]
        public byte[] ToArray()
        {
            var result = new byte[Length];
            unsafe
            {
                byte* s = Buffer;
                fixed(byte* d = result)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArraybyte that is a copy of this FixedListByte4096.
        /// </summary>
        /// <param name="allocator">A member of the
        /// [Unity.Collections.Allocator](https://docs.unity3d.com/ScriptReference/Unity.Collections.Allocator.html) enumeration.</param>
        /// <returns></returns>
        public NativeArray<byte> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                byte* s = Buffer;
                var copy = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<byte>(s, Length, Allocator.None);
                return new NativeArray<byte>(copy, allocator);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListByte4096 in ascending order.
        /// </summary>
        public void Sort()
        {
            unsafe
            {
                NativeSortExtension.Sort((byte*)Buffer, length);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListByte4096 using a custom comparison function.
        /// </summary>
        /// <typeparam name="U">The comparer type.</typeparam>
        /// <param name="comp">A comparison function that indicates whether one element in the array is less than, equal to, or greater than another element.</param>
        [BurstCompatible(GenericTypeArguments = new[] { typeof(NativeSortExtension.DefaultComparer<byte>) })]
        public void Sort<U>(U comp) where U : IComparer<byte>
        {
            unsafe
            {
                NativeSortExtension.Sort((byte*)Buffer, length, comp);
            }
        }


        /// <summary>
        /// Determines whether a FixedListByte4096 and FixedListByte32 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte4096 to compare for equality</param>
        /// <param name="b">The FixedListByte32 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListByte4096 a, in FixedListByte32 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListByte4096 and FixedListByte32 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte4096 to compare for inequality</param>
        /// <param name="b">The FixedListByte32 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListByte4096 a, in FixedListByte32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte32 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte32.
        /// </summary>
        /// <param name="other">The specified FixedListByte32 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListByte32 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte32 and indicates whether this instance
        /// is equal to the specified FixedListByte32.
        /// </summary>
        /// <param name="other">The specified FixedListByte32 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListByte32 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListByte4096 that is a copy of a FixedListByte32.
        /// </summary>
        /// <param name="other">The FixedListByte32 to copy</param>
        public FixedListByte4096(in FixedListByte32 other)
        {
            FixedList.CheckResize<FixedBytes4094,byte>(other.length);
            length = other.length;
            buffer = new FixedBytes4094();
            unsafe
            {
                fixed(FixedBytes30* s = &other.buffer)
                fixed(FixedBytes4094* d = &this.buffer)
                    *(FixedBytes30*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListByte32 to a FixedListByte4096.
        /// </summary>
        /// <param name="other">The FixedListByte32 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListByte4096(in FixedListByte32 other)
        {
            return new FixedListByte4096(other);
        }

        /// <summary>
        /// Determines whether a FixedListByte4096 and FixedListByte64 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte4096 to compare for equality</param>
        /// <param name="b">The FixedListByte64 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListByte4096 a, in FixedListByte64 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListByte4096 and FixedListByte64 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte4096 to compare for inequality</param>
        /// <param name="b">The FixedListByte64 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListByte4096 a, in FixedListByte64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte64 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte64.
        /// </summary>
        /// <param name="other">The specified FixedListByte64 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListByte64 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte64 and indicates whether this instance
        /// is equal to the specified FixedListByte64.
        /// </summary>
        /// <param name="other">The specified FixedListByte64 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListByte64 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListByte4096 that is a copy of a FixedListByte64.
        /// </summary>
        /// <param name="other">The FixedListByte64 to copy</param>
        public FixedListByte4096(in FixedListByte64 other)
        {
            FixedList.CheckResize<FixedBytes4094,byte>(other.length);
            length = other.length;
            buffer = new FixedBytes4094();
            unsafe
            {
                fixed(FixedBytes62* s = &other.buffer)
                fixed(FixedBytes4094* d = &this.buffer)
                    *(FixedBytes62*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListByte64 to a FixedListByte4096.
        /// </summary>
        /// <param name="other">The FixedListByte64 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListByte4096(in FixedListByte64 other)
        {
            return new FixedListByte4096(other);
        }

        /// <summary>
        /// Determines whether a FixedListByte4096 and FixedListByte128 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte4096 to compare for equality</param>
        /// <param name="b">The FixedListByte128 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListByte4096 a, in FixedListByte128 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListByte4096 and FixedListByte128 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte4096 to compare for inequality</param>
        /// <param name="b">The FixedListByte128 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListByte4096 a, in FixedListByte128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte128 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte128.
        /// </summary>
        /// <param name="other">The specified FixedListByte128 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListByte128 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte128 and indicates whether this instance
        /// is equal to the specified FixedListByte128.
        /// </summary>
        /// <param name="other">The specified FixedListByte128 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListByte128 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListByte4096 that is a copy of a FixedListByte128.
        /// </summary>
        /// <param name="other">The FixedListByte128 to copy</param>
        public FixedListByte4096(in FixedListByte128 other)
        {
            FixedList.CheckResize<FixedBytes4094,byte>(other.length);
            length = other.length;
            buffer = new FixedBytes4094();
            unsafe
            {
                fixed(FixedBytes126* s = &other.buffer)
                fixed(FixedBytes4094* d = &this.buffer)
                    *(FixedBytes126*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListByte128 to a FixedListByte4096.
        /// </summary>
        /// <param name="other">The FixedListByte128 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListByte4096(in FixedListByte128 other)
        {
            return new FixedListByte4096(other);
        }

        /// <summary>
        /// Determines whether a FixedListByte4096 and FixedListByte512 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte4096 to compare for equality</param>
        /// <param name="b">The FixedListByte512 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListByte4096 a, in FixedListByte512 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListByte4096 and FixedListByte512 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte4096 to compare for inequality</param>
        /// <param name="b">The FixedListByte512 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListByte4096 a, in FixedListByte512 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte512 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte512.
        /// </summary>
        /// <param name="other">The specified FixedListByte512 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListByte512 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte512 and indicates whether this instance
        /// is equal to the specified FixedListByte512.
        /// </summary>
        /// <param name="other">The specified FixedListByte512 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListByte512 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListByte4096 that is a copy of a FixedListByte512.
        /// </summary>
        /// <param name="other">The FixedListByte512 to copy</param>
        public FixedListByte4096(in FixedListByte512 other)
        {
            FixedList.CheckResize<FixedBytes4094,byte>(other.length);
            length = other.length;
            buffer = new FixedBytes4094();
            unsafe
            {
                fixed(FixedBytes510* s = &other.buffer)
                fixed(FixedBytes4094* d = &this.buffer)
                    *(FixedBytes510*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListByte512 to a FixedListByte4096.
        /// </summary>
        /// <param name="other">The FixedListByte512 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListByte4096(in FixedListByte512 other)
        {
            return new FixedListByte4096(other);
        }

        /// <summary>
        /// Determines whether a FixedListByte4096 and FixedListByte4096 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte4096 to compare for equality</param>
        /// <param name="b">The FixedListByte4096 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListByte4096 a, in FixedListByte4096 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListByte4096 and FixedListByte4096 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte4096 to compare for inequality</param>
        /// <param name="b">The FixedListByte4096 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListByte4096 a, in FixedListByte4096 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte4096 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte4096.
        /// </summary>
        /// <param name="other">The specified FixedListByte4096 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListByte4096 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte4096 and indicates whether this instance
        /// is equal to the specified FixedListByte4096.
        /// </summary>
        /// <param name="other">The specified FixedListByte4096 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListByte4096 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        /// <returns></returns>
        [NotBurstCompatible]
        public override bool Equals(object obj)
        {
            if(obj is FixedListByte32 aFixedListByte32) return Equals(aFixedListByte32);
            if(obj is FixedListByte64 aFixedListByte64) return Equals(aFixedListByte64);
            if(obj is FixedListByte128 aFixedListByte128) return Equals(aFixedListByte128);
            if(obj is FixedListByte512 aFixedListByte512) return Equals(aFixedListByte512);
            if(obj is FixedListByte4096 aFixedListByte4096) return Equals(aFixedListByte4096);
            return false;
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        public struct Enumerator : IEnumerator<byte>
        {
            FixedListByte4096 m_List;
            int m_Index;

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <param name="list"><undoc /></param>
            public Enumerator(ref FixedListByte4096 list)
            {
                m_List = list;
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Dispose()
            {
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <returns><undoc /></returns>
            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Reset()
            {
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public byte Current => m_List[m_Index]; // Let FixedListByte4096 indexer check for out of range.

            object IEnumerator.Current => Current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator IEnumerable.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator<byte> IEnumerable<byte>.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckCapacityInRange(int capacity)
        {
            if(capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }
    }

    sealed class FixedListByte4096DebugView
    {
        FixedListByte4096 m_List;
        public FixedListByte4096DebugView(FixedListByte4096 list)
        {
            m_List = list;
        }
        public byte[] Items => m_List.ToArray();
    }


    /// <summary>
    /// An unmanaged, resizable list of int that does not allocate memory.
    /// It is 32 bytes in size, and contains all the memory it needs.
    /// </summary>
    [Serializable]
    [StructLayout(LayoutKind.Explicit, Size=32)]
    [DebuggerTypeProxy(typeof(FixedListInt32DebugView))]
    [BurstCompatible]
    public struct FixedListInt32
    : INativeList<int>
    , IEnumerable<int> // Used by collection initializers.
    , IEquatable<FixedListInt32>
    , IComparable<FixedListInt32>
    , IEquatable<FixedListInt64>
    , IComparable<FixedListInt64>
    , IEquatable<FixedListInt128>
    , IComparable<FixedListInt128>
    , IEquatable<FixedListInt512>
    , IComparable<FixedListInt512>
    , IEquatable<FixedListInt4096>
    , IComparable<FixedListInt4096>
    {
        [SerializeField] [FieldOffset(0)] internal ushort length;
        [SerializeField] [FieldOffset(2)] internal FixedBytes30 buffer;

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        [CreateProperty]
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize<FixedBytes30,int>(value);
                length = (ushort)value;
            }
        }

        /// <summary>
        /// A property in order to display items in the Entity Inspector.
        /// </summary>
        [CreateProperty] IEnumerable<int> Elements => this.ToArray();

        /// <summary>
        /// Reports whether container is empty.
        /// </summary>
        /// <value>True if this container empty.</value>
        public bool IsEmpty => Length == 0;

        internal int LengthInBytes => Length * sizeof(int);

        unsafe internal byte* Buffer
        {
            get
            {
                fixed(byte* b = &buffer.offset0000.byte0000)
                    return b + FixedList.PaddingBytes<int>();
            }
        }

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity
        {
            get
            {
                return FixedList.Capacity<FixedBytes30, int>();
            }
            set
            {
                CheckCapacityInRange(value);
            }
        }

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public int this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    return UnsafeUtility.ReadArrayElement<int>(Buffer, index);
                }
            }
            set
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    UnsafeUtility.WriteArrayElement<int>(Buffer, index, value);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public ref int ElementAt(int index)
        {
            FixedList.CheckElementAccess(index, length);
            unsafe
            {
                return ref UnsafeUtility.ArrayElementAsRef<int>(Buffer, index);
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedListInt32.
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                return (int)CollectionHelper.Hash(Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The int to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void Add(in int item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRange(void* ptr, int length)
        {
            int* data = (int*)ptr;
            for (var i = 0; i < length; ++i)
            {
                this[Length++] = data[i];
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The int to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void AddNoResize(int item) => Add(item);

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRangeNoResize(void* ptr, int length) => AddRange(ptr, length);

        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }

        /// <summary>
        /// Searches for the specified int and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListInt32 that starts at the specified index and contains the specified
        /// number of elements.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt32.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <param name="count">The number of elements in the section to search.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(int item, int index, int count)
        {
            for(var i = index; i < index + count; ++i)
                if(this[i].Equals(item))
                  return i;
            return -1;
        }

        /// <summary>
        /// Searches for the specified int and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListInt32 that starts at the specified index.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt32.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(int item, int index)
        {
            return IndexOf(item, index, Length - index);
        }

        /// <summary>
        /// Determines whether an element is in the FixedListInt32.
        /// </summary>
        /// <param name="item">The object to locate in the FixedListInt32.</param>
        /// <returns></returns>
        public bool Contains(int item)
        {
            return IndexOf(item) >= 0;
        }

        /// <summary>
        /// Searches for the specified int and returns the zero-based index of the first occurrence within the entire FixedListInt32.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt32.</param>
        /// <returns></returns>
        public int IndexOf(int item)
        {
            for (var i = 0; i < length; ++i)
            {
                if (this[i].Equals(item))
                {
                    return i;
                }
            }

            return -1;
        }

        /// <summary>
        /// Inserts a number of items into a FixedListInt32 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="end">The zero-based index just after where the elements should be removed.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void InsertRangeWithBeginEnd(int begin, int end)
        {
            int items = end - begin;
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(int);
            unsafe
            {
                byte* b = Buffer;
                byte *dest = b + end * sizeof(int);
                byte *src = b + begin * sizeof(int);
                UnsafeUtility.MemMove(dest, src, bytesToCopy);
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedListInt32 at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>
        public void Insert(int index, int item)
        {
            InsertRangeWithBeginEnd(index, index+1);
            this[index] = item;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index with the last item in the list. The list
        /// is shortened by one.
        /// </summary>
        /// <param name="index">The index of the item to delete.</param>
        public void RemoveAtSwapBack(int index)
        {
            RemoveRangeSwapBackWithBeginEnd(index, index + 1);
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedListInt32 and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedListInt32.</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool RemoveSwapBack(int item)
        {
            var index = IndexOf(item);
            if (index == -1)
            {
                return false;
            }

            RemoveAtSwapBack(index);
            return true;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index range with the items from the end the list. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeSwapBackWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                int copyFrom = math.max(Length - itemsToRemove, end);

                unsafe
                {
                    var sizeOf = sizeof(int);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                }

                Length -= itemsToRemove;
            }
        }

        /// <summary>
        /// Removes the int at the specified index, and copies all subsequent elements backward to fill the
        /// hole so created.
        /// </summary>
        /// <param name="index">The zero-based index at which to remove the int</param>
        public void RemoveAt(int index)
        {
            RemoveRangeWithBeginEnd(index, index+1);
        }

        /// <summary>
        /// Searches for the specified int from the begining of the FixedListInt32 forward, removes it if possible,
        /// and returns true if the int was successfully removed.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt32</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool Remove(int item)
        {
            int index = IndexOf(item);
            if (index < 0)
            {
                return false;
            }

            RemoveAt(index);

            return true;
        }

        /// <summary>
        /// Truncates the list by removing the items at the specified index range, and shifting all remaining items to replace removed items. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <remarks>
        /// This method of removing item(s) is useful only in case when list is ordered and user wants to preserve order
        /// in list after removal In majority of cases is not important and user should use more performant `RemoveRangeSwapBackWithBeginEnd`.
        /// </remarks>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                unsafe
                {
                    var sizeOf = sizeof(int);
                    int copyFrom = math.min(begin + itemsToRemove, Length);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                    Length -= itemsToRemove;
                }
            }
        }

        /// <summary>
        /// Creates a managed Array of int that is a copy of this FixedListInt32.
        /// </summary>
        /// <returns></returns>
        [NotBurstCompatible]
        public int[] ToArray()
        {
            var result = new int[Length];
            unsafe
            {
                byte* s = Buffer;
                fixed(int* d = result)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArrayint that is a copy of this FixedListInt32.
        /// </summary>
        /// <param name="allocator">A member of the
        /// [Unity.Collections.Allocator](https://docs.unity3d.com/ScriptReference/Unity.Collections.Allocator.html) enumeration.</param>
        /// <returns></returns>
        public NativeArray<int> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                byte* s = Buffer;
                var copy = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<int>(s, Length, Allocator.None);
                return new NativeArray<int>(copy, allocator);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListInt32 in ascending order.
        /// </summary>
        public void Sort()
        {
            unsafe
            {
                NativeSortExtension.Sort((int*)Buffer, length);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListInt32 using a custom comparison function.
        /// </summary>
        /// <typeparam name="U">The comparer type.</typeparam>
        /// <param name="comp">A comparison function that indicates whether one element in the array is less than, equal to, or greater than another element.</param>
        [BurstCompatible(GenericTypeArguments = new[] { typeof(NativeSortExtension.DefaultComparer<int>) })]
        public void Sort<U>(U comp) where U : IComparer<int>
        {
            unsafe
            {
                NativeSortExtension.Sort((int*)Buffer, length, comp);
            }
        }


        /// <summary>
        /// Determines whether a FixedListInt32 and FixedListInt32 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt32 to compare for equality</param>
        /// <param name="b">The FixedListInt32 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListInt32 a, in FixedListInt32 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListInt32 and FixedListInt32 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt32 to compare for inequality</param>
        /// <param name="b">The FixedListInt32 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListInt32 a, in FixedListInt32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt32 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt32.
        /// </summary>
        /// <param name="other">The specified FixedListInt32 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListInt32 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt32 and indicates whether this instance
        /// is equal to the specified FixedListInt32.
        /// </summary>
        /// <param name="other">The specified FixedListInt32 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListInt32 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Determines whether a FixedListInt32 and FixedListInt64 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt32 to compare for equality</param>
        /// <param name="b">The FixedListInt64 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListInt32 a, in FixedListInt64 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListInt32 and FixedListInt64 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt32 to compare for inequality</param>
        /// <param name="b">The FixedListInt64 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListInt32 a, in FixedListInt64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt64 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt64.
        /// </summary>
        /// <param name="other">The specified FixedListInt64 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListInt64 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt64 and indicates whether this instance
        /// is equal to the specified FixedListInt64.
        /// </summary>
        /// <param name="other">The specified FixedListInt64 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListInt64 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListInt32 that is a copy of a FixedListInt64.
        /// </summary>
        /// <param name="other">The FixedListInt64 to copy</param>
        public FixedListInt32(in FixedListInt64 other)
        {
            FixedList.CheckResize<FixedBytes30,int>(other.length);
            length = other.length;
            buffer = new FixedBytes30();
            unsafe
            {
                fixed(FixedBytes62* s = &other.buffer)
                fixed(FixedBytes30* d = &this.buffer)
                    *d = *(FixedBytes30*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListInt64 to a FixedListInt32.
        /// </summary>
        /// <param name="other">The FixedListInt64 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListInt32(in FixedListInt64 other)
        {
            return new FixedListInt32(other);
        }

        /// <summary>
        /// Determines whether a FixedListInt32 and FixedListInt128 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt32 to compare for equality</param>
        /// <param name="b">The FixedListInt128 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListInt32 a, in FixedListInt128 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListInt32 and FixedListInt128 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt32 to compare for inequality</param>
        /// <param name="b">The FixedListInt128 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListInt32 a, in FixedListInt128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt128 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt128.
        /// </summary>
        /// <param name="other">The specified FixedListInt128 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListInt128 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt128 and indicates whether this instance
        /// is equal to the specified FixedListInt128.
        /// </summary>
        /// <param name="other">The specified FixedListInt128 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListInt128 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListInt32 that is a copy of a FixedListInt128.
        /// </summary>
        /// <param name="other">The FixedListInt128 to copy</param>
        public FixedListInt32(in FixedListInt128 other)
        {
            FixedList.CheckResize<FixedBytes30,int>(other.length);
            length = other.length;
            buffer = new FixedBytes30();
            unsafe
            {
                fixed(FixedBytes126* s = &other.buffer)
                fixed(FixedBytes30* d = &this.buffer)
                    *d = *(FixedBytes30*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListInt128 to a FixedListInt32.
        /// </summary>
        /// <param name="other">The FixedListInt128 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListInt32(in FixedListInt128 other)
        {
            return new FixedListInt32(other);
        }

        /// <summary>
        /// Determines whether a FixedListInt32 and FixedListInt512 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt32 to compare for equality</param>
        /// <param name="b">The FixedListInt512 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListInt32 a, in FixedListInt512 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListInt32 and FixedListInt512 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt32 to compare for inequality</param>
        /// <param name="b">The FixedListInt512 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListInt32 a, in FixedListInt512 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt512 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt512.
        /// </summary>
        /// <param name="other">The specified FixedListInt512 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListInt512 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt512 and indicates whether this instance
        /// is equal to the specified FixedListInt512.
        /// </summary>
        /// <param name="other">The specified FixedListInt512 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListInt512 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListInt32 that is a copy of a FixedListInt512.
        /// </summary>
        /// <param name="other">The FixedListInt512 to copy</param>
        public FixedListInt32(in FixedListInt512 other)
        {
            FixedList.CheckResize<FixedBytes30,int>(other.length);
            length = other.length;
            buffer = new FixedBytes30();
            unsafe
            {
                fixed(FixedBytes510* s = &other.buffer)
                fixed(FixedBytes30* d = &this.buffer)
                    *d = *(FixedBytes30*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListInt512 to a FixedListInt32.
        /// </summary>
        /// <param name="other">The FixedListInt512 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListInt32(in FixedListInt512 other)
        {
            return new FixedListInt32(other);
        }

        /// <summary>
        /// Determines whether a FixedListInt32 and FixedListInt4096 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt32 to compare for equality</param>
        /// <param name="b">The FixedListInt4096 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListInt32 a, in FixedListInt4096 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListInt32 and FixedListInt4096 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt32 to compare for inequality</param>
        /// <param name="b">The FixedListInt4096 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListInt32 a, in FixedListInt4096 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt4096 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt4096.
        /// </summary>
        /// <param name="other">The specified FixedListInt4096 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListInt4096 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt4096 and indicates whether this instance
        /// is equal to the specified FixedListInt4096.
        /// </summary>
        /// <param name="other">The specified FixedListInt4096 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListInt4096 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListInt32 that is a copy of a FixedListInt4096.
        /// </summary>
        /// <param name="other">The FixedListInt4096 to copy</param>
        public FixedListInt32(in FixedListInt4096 other)
        {
            FixedList.CheckResize<FixedBytes30,int>(other.length);
            length = other.length;
            buffer = new FixedBytes30();
            unsafe
            {
                fixed(FixedBytes4094* s = &other.buffer)
                fixed(FixedBytes30* d = &this.buffer)
                    *d = *(FixedBytes30*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListInt4096 to a FixedListInt32.
        /// </summary>
        /// <param name="other">The FixedListInt4096 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListInt32(in FixedListInt4096 other)
        {
            return new FixedListInt32(other);
        }

        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        /// <returns></returns>
        [NotBurstCompatible]
        public override bool Equals(object obj)
        {
            if(obj is FixedListInt32 aFixedListInt32) return Equals(aFixedListInt32);
            if(obj is FixedListInt64 aFixedListInt64) return Equals(aFixedListInt64);
            if(obj is FixedListInt128 aFixedListInt128) return Equals(aFixedListInt128);
            if(obj is FixedListInt512 aFixedListInt512) return Equals(aFixedListInt512);
            if(obj is FixedListInt4096 aFixedListInt4096) return Equals(aFixedListInt4096);
            return false;
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        public struct Enumerator : IEnumerator<int>
        {
            FixedListInt32 m_List;
            int m_Index;

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <param name="list"><undoc /></param>
            public Enumerator(ref FixedListInt32 list)
            {
                m_List = list;
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Dispose()
            {
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <returns><undoc /></returns>
            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Reset()
            {
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public int Current => m_List[m_Index]; // Let FixedListInt32 indexer check for out of range.

            object IEnumerator.Current => Current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator IEnumerable.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator<int> IEnumerable<int>.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckCapacityInRange(int capacity)
        {
            if(capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }
    }

    sealed class FixedListInt32DebugView
    {
        FixedListInt32 m_List;
        public FixedListInt32DebugView(FixedListInt32 list)
        {
            m_List = list;
        }
        public int[] Items => m_List.ToArray();
    }


    /// <summary>
    /// An unmanaged, resizable list of int that does not allocate memory.
    /// It is 64 bytes in size, and contains all the memory it needs.
    /// </summary>
    [Serializable]
    [StructLayout(LayoutKind.Explicit, Size=64)]
    [DebuggerTypeProxy(typeof(FixedListInt64DebugView))]
    [BurstCompatible]
    public struct FixedListInt64
    : INativeList<int>
    , IEnumerable<int> // Used by collection initializers.
    , IEquatable<FixedListInt32>
    , IComparable<FixedListInt32>
    , IEquatable<FixedListInt64>
    , IComparable<FixedListInt64>
    , IEquatable<FixedListInt128>
    , IComparable<FixedListInt128>
    , IEquatable<FixedListInt512>
    , IComparable<FixedListInt512>
    , IEquatable<FixedListInt4096>
    , IComparable<FixedListInt4096>
    {
        [SerializeField] [FieldOffset(0)] internal ushort length;
        [SerializeField] [FieldOffset(2)] internal FixedBytes62 buffer;

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        [CreateProperty]
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize<FixedBytes62,int>(value);
                length = (ushort)value;
            }
        }

        /// <summary>
        /// A property in order to display items in the Entity Inspector.
        /// </summary>
        [CreateProperty] IEnumerable<int> Elements => this.ToArray();

        /// <summary>
        /// Reports whether container is empty.
        /// </summary>
        /// <value>True if this container empty.</value>
        public bool IsEmpty => Length == 0;

        internal int LengthInBytes => Length * sizeof(int);

        unsafe internal byte* Buffer
        {
            get
            {
                fixed(byte* b = &buffer.offset0000.byte0000)
                    return b + FixedList.PaddingBytes<int>();
            }
        }

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity
        {
            get
            {
                return FixedList.Capacity<FixedBytes62, int>();
            }
            set
            {
                CheckCapacityInRange(value);
            }
        }

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public int this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    return UnsafeUtility.ReadArrayElement<int>(Buffer, index);
                }
            }
            set
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    UnsafeUtility.WriteArrayElement<int>(Buffer, index, value);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public ref int ElementAt(int index)
        {
            FixedList.CheckElementAccess(index, length);
            unsafe
            {
                return ref UnsafeUtility.ArrayElementAsRef<int>(Buffer, index);
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedListInt64.
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                return (int)CollectionHelper.Hash(Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The int to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void Add(in int item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRange(void* ptr, int length)
        {
            int* data = (int*)ptr;
            for (var i = 0; i < length; ++i)
            {
                this[Length++] = data[i];
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The int to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void AddNoResize(int item) => Add(item);

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRangeNoResize(void* ptr, int length) => AddRange(ptr, length);

        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }

        /// <summary>
        /// Searches for the specified int and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListInt64 that starts at the specified index and contains the specified
        /// number of elements.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt64.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <param name="count">The number of elements in the section to search.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(int item, int index, int count)
        {
            for(var i = index; i < index + count; ++i)
                if(this[i].Equals(item))
                  return i;
            return -1;
        }

        /// <summary>
        /// Searches for the specified int and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListInt64 that starts at the specified index.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt64.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(int item, int index)
        {
            return IndexOf(item, index, Length - index);
        }

        /// <summary>
        /// Determines whether an element is in the FixedListInt64.
        /// </summary>
        /// <param name="item">The object to locate in the FixedListInt64.</param>
        /// <returns></returns>
        public bool Contains(int item)
        {
            return IndexOf(item) >= 0;
        }

        /// <summary>
        /// Searches for the specified int and returns the zero-based index of the first occurrence within the entire FixedListInt64.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt64.</param>
        /// <returns></returns>
        public int IndexOf(int item)
        {
            for (var i = 0; i < length; ++i)
            {
                if (this[i].Equals(item))
                {
                    return i;
                }
            }

            return -1;
        }

        /// <summary>
        /// Inserts a number of items into a FixedListInt64 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="end">The zero-based index just after where the elements should be removed.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void InsertRangeWithBeginEnd(int begin, int end)
        {
            int items = end - begin;
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(int);
            unsafe
            {
                byte* b = Buffer;
                byte *dest = b + end * sizeof(int);
                byte *src = b + begin * sizeof(int);
                UnsafeUtility.MemMove(dest, src, bytesToCopy);
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedListInt64 at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>
        public void Insert(int index, int item)
        {
            InsertRangeWithBeginEnd(index, index+1);
            this[index] = item;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index with the last item in the list. The list
        /// is shortened by one.
        /// </summary>
        /// <param name="index">The index of the item to delete.</param>
        public void RemoveAtSwapBack(int index)
        {
            RemoveRangeSwapBackWithBeginEnd(index, index + 1);
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedListInt64 and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedListInt64.</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool RemoveSwapBack(int item)
        {
            var index = IndexOf(item);
            if (index == -1)
            {
                return false;
            }

            RemoveAtSwapBack(index);
            return true;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index range with the items from the end the list. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeSwapBackWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                int copyFrom = math.max(Length - itemsToRemove, end);

                unsafe
                {
                    var sizeOf = sizeof(int);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                }

                Length -= itemsToRemove;
            }
        }

        /// <summary>
        /// Removes the int at the specified index, and copies all subsequent elements backward to fill the
        /// hole so created.
        /// </summary>
        /// <param name="index">The zero-based index at which to remove the int</param>
        public void RemoveAt(int index)
        {
            RemoveRangeWithBeginEnd(index, index+1);
        }

        /// <summary>
        /// Searches for the specified int from the begining of the FixedListInt64 forward, removes it if possible,
        /// and returns true if the int was successfully removed.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt64</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool Remove(int item)
        {
            int index = IndexOf(item);
            if (index < 0)
            {
                return false;
            }

            RemoveAt(index);

            return true;
        }

        /// <summary>
        /// Truncates the list by removing the items at the specified index range, and shifting all remaining items to replace removed items. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <remarks>
        /// This method of removing item(s) is useful only in case when list is ordered and user wants to preserve order
        /// in list after removal In majority of cases is not important and user should use more performant `RemoveRangeSwapBackWithBeginEnd`.
        /// </remarks>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                unsafe
                {
                    var sizeOf = sizeof(int);
                    int copyFrom = math.min(begin + itemsToRemove, Length);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                    Length -= itemsToRemove;
                }
            }
        }

        /// <summary>
        /// Creates a managed Array of int that is a copy of this FixedListInt64.
        /// </summary>
        /// <returns></returns>
        [NotBurstCompatible]
        public int[] ToArray()
        {
            var result = new int[Length];
            unsafe
            {
                byte* s = Buffer;
                fixed(int* d = result)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArrayint that is a copy of this FixedListInt64.
        /// </summary>
        /// <param name="allocator">A member of the
        /// [Unity.Collections.Allocator](https://docs.unity3d.com/ScriptReference/Unity.Collections.Allocator.html) enumeration.</param>
        /// <returns></returns>
        public NativeArray<int> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                byte* s = Buffer;
                var copy = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<int>(s, Length, Allocator.None);
                return new NativeArray<int>(copy, allocator);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListInt64 in ascending order.
        /// </summary>
        public void Sort()
        {
            unsafe
            {
                NativeSortExtension.Sort((int*)Buffer, length);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListInt64 using a custom comparison function.
        /// </summary>
        /// <typeparam name="U">The comparer type.</typeparam>
        /// <param name="comp">A comparison function that indicates whether one element in the array is less than, equal to, or greater than another element.</param>
        [BurstCompatible(GenericTypeArguments = new[] { typeof(NativeSortExtension.DefaultComparer<int>) })]
        public void Sort<U>(U comp) where U : IComparer<int>
        {
            unsafe
            {
                NativeSortExtension.Sort((int*)Buffer, length, comp);
            }
        }


        /// <summary>
        /// Determines whether a FixedListInt64 and FixedListInt32 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt64 to compare for equality</param>
        /// <param name="b">The FixedListInt32 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListInt64 a, in FixedListInt32 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListInt64 and FixedListInt32 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt64 to compare for inequality</param>
        /// <param name="b">The FixedListInt32 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListInt64 a, in FixedListInt32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt32 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt32.
        /// </summary>
        /// <param name="other">The specified FixedListInt32 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListInt32 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt32 and indicates whether this instance
        /// is equal to the specified FixedListInt32.
        /// </summary>
        /// <param name="other">The specified FixedListInt32 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListInt32 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListInt64 that is a copy of a FixedListInt32.
        /// </summary>
        /// <param name="other">The FixedListInt32 to copy</param>
        public FixedListInt64(in FixedListInt32 other)
        {
            FixedList.CheckResize<FixedBytes62,int>(other.length);
            length = other.length;
            buffer = new FixedBytes62();
            unsafe
            {
                fixed(FixedBytes30* s = &other.buffer)
                fixed(FixedBytes62* d = &this.buffer)
                    *(FixedBytes30*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListInt32 to a FixedListInt64.
        /// </summary>
        /// <param name="other">The FixedListInt32 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListInt64(in FixedListInt32 other)
        {
            return new FixedListInt64(other);
        }

        /// <summary>
        /// Determines whether a FixedListInt64 and FixedListInt64 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt64 to compare for equality</param>
        /// <param name="b">The FixedListInt64 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListInt64 a, in FixedListInt64 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListInt64 and FixedListInt64 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt64 to compare for inequality</param>
        /// <param name="b">The FixedListInt64 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListInt64 a, in FixedListInt64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt64 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt64.
        /// </summary>
        /// <param name="other">The specified FixedListInt64 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListInt64 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt64 and indicates whether this instance
        /// is equal to the specified FixedListInt64.
        /// </summary>
        /// <param name="other">The specified FixedListInt64 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListInt64 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Determines whether a FixedListInt64 and FixedListInt128 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt64 to compare for equality</param>
        /// <param name="b">The FixedListInt128 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListInt64 a, in FixedListInt128 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListInt64 and FixedListInt128 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt64 to compare for inequality</param>
        /// <param name="b">The FixedListInt128 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListInt64 a, in FixedListInt128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt128 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt128.
        /// </summary>
        /// <param name="other">The specified FixedListInt128 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListInt128 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt128 and indicates whether this instance
        /// is equal to the specified FixedListInt128.
        /// </summary>
        /// <param name="other">The specified FixedListInt128 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListInt128 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListInt64 that is a copy of a FixedListInt128.
        /// </summary>
        /// <param name="other">The FixedListInt128 to copy</param>
        public FixedListInt64(in FixedListInt128 other)
        {
            FixedList.CheckResize<FixedBytes62,int>(other.length);
            length = other.length;
            buffer = new FixedBytes62();
            unsafe
            {
                fixed(FixedBytes126* s = &other.buffer)
                fixed(FixedBytes62* d = &this.buffer)
                    *d = *(FixedBytes62*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListInt128 to a FixedListInt64.
        /// </summary>
        /// <param name="other">The FixedListInt128 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListInt64(in FixedListInt128 other)
        {
            return new FixedListInt64(other);
        }

        /// <summary>
        /// Determines whether a FixedListInt64 and FixedListInt512 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt64 to compare for equality</param>
        /// <param name="b">The FixedListInt512 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListInt64 a, in FixedListInt512 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListInt64 and FixedListInt512 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt64 to compare for inequality</param>
        /// <param name="b">The FixedListInt512 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListInt64 a, in FixedListInt512 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt512 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt512.
        /// </summary>
        /// <param name="other">The specified FixedListInt512 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListInt512 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt512 and indicates whether this instance
        /// is equal to the specified FixedListInt512.
        /// </summary>
        /// <param name="other">The specified FixedListInt512 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListInt512 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListInt64 that is a copy of a FixedListInt512.
        /// </summary>
        /// <param name="other">The FixedListInt512 to copy</param>
        public FixedListInt64(in FixedListInt512 other)
        {
            FixedList.CheckResize<FixedBytes62,int>(other.length);
            length = other.length;
            buffer = new FixedBytes62();
            unsafe
            {
                fixed(FixedBytes510* s = &other.buffer)
                fixed(FixedBytes62* d = &this.buffer)
                    *d = *(FixedBytes62*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListInt512 to a FixedListInt64.
        /// </summary>
        /// <param name="other">The FixedListInt512 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListInt64(in FixedListInt512 other)
        {
            return new FixedListInt64(other);
        }

        /// <summary>
        /// Determines whether a FixedListInt64 and FixedListInt4096 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt64 to compare for equality</param>
        /// <param name="b">The FixedListInt4096 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListInt64 a, in FixedListInt4096 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListInt64 and FixedListInt4096 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt64 to compare for inequality</param>
        /// <param name="b">The FixedListInt4096 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListInt64 a, in FixedListInt4096 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt4096 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt4096.
        /// </summary>
        /// <param name="other">The specified FixedListInt4096 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListInt4096 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt4096 and indicates whether this instance
        /// is equal to the specified FixedListInt4096.
        /// </summary>
        /// <param name="other">The specified FixedListInt4096 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListInt4096 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListInt64 that is a copy of a FixedListInt4096.
        /// </summary>
        /// <param name="other">The FixedListInt4096 to copy</param>
        public FixedListInt64(in FixedListInt4096 other)
        {
            FixedList.CheckResize<FixedBytes62,int>(other.length);
            length = other.length;
            buffer = new FixedBytes62();
            unsafe
            {
                fixed(FixedBytes4094* s = &other.buffer)
                fixed(FixedBytes62* d = &this.buffer)
                    *d = *(FixedBytes62*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListInt4096 to a FixedListInt64.
        /// </summary>
        /// <param name="other">The FixedListInt4096 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListInt64(in FixedListInt4096 other)
        {
            return new FixedListInt64(other);
        }

        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        /// <returns></returns>
        [NotBurstCompatible]
        public override bool Equals(object obj)
        {
            if(obj is FixedListInt32 aFixedListInt32) return Equals(aFixedListInt32);
            if(obj is FixedListInt64 aFixedListInt64) return Equals(aFixedListInt64);
            if(obj is FixedListInt128 aFixedListInt128) return Equals(aFixedListInt128);
            if(obj is FixedListInt512 aFixedListInt512) return Equals(aFixedListInt512);
            if(obj is FixedListInt4096 aFixedListInt4096) return Equals(aFixedListInt4096);
            return false;
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        public struct Enumerator : IEnumerator<int>
        {
            FixedListInt64 m_List;
            int m_Index;

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <param name="list"><undoc /></param>
            public Enumerator(ref FixedListInt64 list)
            {
                m_List = list;
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Dispose()
            {
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <returns><undoc /></returns>
            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Reset()
            {
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public int Current => m_List[m_Index]; // Let FixedListInt64 indexer check for out of range.

            object IEnumerator.Current => Current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator IEnumerable.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator<int> IEnumerable<int>.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckCapacityInRange(int capacity)
        {
            if(capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }
    }

    sealed class FixedListInt64DebugView
    {
        FixedListInt64 m_List;
        public FixedListInt64DebugView(FixedListInt64 list)
        {
            m_List = list;
        }
        public int[] Items => m_List.ToArray();
    }


    /// <summary>
    /// An unmanaged, resizable list of int that does not allocate memory.
    /// It is 128 bytes in size, and contains all the memory it needs.
    /// </summary>
    [Serializable]
    [StructLayout(LayoutKind.Explicit, Size=128)]
    [DebuggerTypeProxy(typeof(FixedListInt128DebugView))]
    [BurstCompatible]
    public struct FixedListInt128
    : INativeList<int>
    , IEnumerable<int> // Used by collection initializers.
    , IEquatable<FixedListInt32>
    , IComparable<FixedListInt32>
    , IEquatable<FixedListInt64>
    , IComparable<FixedListInt64>
    , IEquatable<FixedListInt128>
    , IComparable<FixedListInt128>
    , IEquatable<FixedListInt512>
    , IComparable<FixedListInt512>
    , IEquatable<FixedListInt4096>
    , IComparable<FixedListInt4096>
    {
        [SerializeField] [FieldOffset(0)] internal ushort length;
        [SerializeField] [FieldOffset(2)] internal FixedBytes126 buffer;

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        [CreateProperty]
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize<FixedBytes126,int>(value);
                length = (ushort)value;
            }
        }

        /// <summary>
        /// A property in order to display items in the Entity Inspector.
        /// </summary>
        [CreateProperty] IEnumerable<int> Elements => this.ToArray();

        /// <summary>
        /// Reports whether container is empty.
        /// </summary>
        /// <value>True if this container empty.</value>
        public bool IsEmpty => Length == 0;

        internal int LengthInBytes => Length * sizeof(int);

        unsafe internal byte* Buffer
        {
            get
            {
                fixed(byte* b = &buffer.offset0000.byte0000)
                    return b + FixedList.PaddingBytes<int>();
            }
        }

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity
        {
            get
            {
                return FixedList.Capacity<FixedBytes126, int>();
            }
            set
            {
                CheckCapacityInRange(value);
            }
        }

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public int this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    return UnsafeUtility.ReadArrayElement<int>(Buffer, index);
                }
            }
            set
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    UnsafeUtility.WriteArrayElement<int>(Buffer, index, value);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public ref int ElementAt(int index)
        {
            FixedList.CheckElementAccess(index, length);
            unsafe
            {
                return ref UnsafeUtility.ArrayElementAsRef<int>(Buffer, index);
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedListInt128.
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                return (int)CollectionHelper.Hash(Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The int to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void Add(in int item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRange(void* ptr, int length)
        {
            int* data = (int*)ptr;
            for (var i = 0; i < length; ++i)
            {
                this[Length++] = data[i];
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The int to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void AddNoResize(int item) => Add(item);

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRangeNoResize(void* ptr, int length) => AddRange(ptr, length);

        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }

        /// <summary>
        /// Searches for the specified int and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListInt128 that starts at the specified index and contains the specified
        /// number of elements.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt128.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <param name="count">The number of elements in the section to search.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(int item, int index, int count)
        {
            for(var i = index; i < index + count; ++i)
                if(this[i].Equals(item))
                  return i;
            return -1;
        }

        /// <summary>
        /// Searches for the specified int and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListInt128 that starts at the specified index.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt128.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(int item, int index)
        {
            return IndexOf(item, index, Length - index);
        }

        /// <summary>
        /// Determines whether an element is in the FixedListInt128.
        /// </summary>
        /// <param name="item">The object to locate in the FixedListInt128.</param>
        /// <returns></returns>
        public bool Contains(int item)
        {
            return IndexOf(item) >= 0;
        }

        /// <summary>
        /// Searches for the specified int and returns the zero-based index of the first occurrence within the entire FixedListInt128.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt128.</param>
        /// <returns></returns>
        public int IndexOf(int item)
        {
            for (var i = 0; i < length; ++i)
            {
                if (this[i].Equals(item))
                {
                    return i;
                }
            }

            return -1;
        }

        /// <summary>
        /// Inserts a number of items into a FixedListInt128 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="end">The zero-based index just after where the elements should be removed.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void InsertRangeWithBeginEnd(int begin, int end)
        {
            int items = end - begin;
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(int);
            unsafe
            {
                byte* b = Buffer;
                byte *dest = b + end * sizeof(int);
                byte *src = b + begin * sizeof(int);
                UnsafeUtility.MemMove(dest, src, bytesToCopy);
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedListInt128 at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>
        public void Insert(int index, int item)
        {
            InsertRangeWithBeginEnd(index, index+1);
            this[index] = item;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index with the last item in the list. The list
        /// is shortened by one.
        /// </summary>
        /// <param name="index">The index of the item to delete.</param>
        public void RemoveAtSwapBack(int index)
        {
            RemoveRangeSwapBackWithBeginEnd(index, index + 1);
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedListInt128 and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedListInt128.</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool RemoveSwapBack(int item)
        {
            var index = IndexOf(item);
            if (index == -1)
            {
                return false;
            }

            RemoveAtSwapBack(index);
            return true;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index range with the items from the end the list. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeSwapBackWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                int copyFrom = math.max(Length - itemsToRemove, end);

                unsafe
                {
                    var sizeOf = sizeof(int);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                }

                Length -= itemsToRemove;
            }
        }

        /// <summary>
        /// Removes the int at the specified index, and copies all subsequent elements backward to fill the
        /// hole so created.
        /// </summary>
        /// <param name="index">The zero-based index at which to remove the int</param>
        public void RemoveAt(int index)
        {
            RemoveRangeWithBeginEnd(index, index+1);
        }

        /// <summary>
        /// Searches for the specified int from the begining of the FixedListInt128 forward, removes it if possible,
        /// and returns true if the int was successfully removed.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt128</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool Remove(int item)
        {
            int index = IndexOf(item);
            if (index < 0)
            {
                return false;
            }

            RemoveAt(index);

            return true;
        }

        /// <summary>
        /// Truncates the list by removing the items at the specified index range, and shifting all remaining items to replace removed items. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <remarks>
        /// This method of removing item(s) is useful only in case when list is ordered and user wants to preserve order
        /// in list after removal In majority of cases is not important and user should use more performant `RemoveRangeSwapBackWithBeginEnd`.
        /// </remarks>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                unsafe
                {
                    var sizeOf = sizeof(int);
                    int copyFrom = math.min(begin + itemsToRemove, Length);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                    Length -= itemsToRemove;
                }
            }
        }

        /// <summary>
        /// Creates a managed Array of int that is a copy of this FixedListInt128.
        /// </summary>
        /// <returns></returns>
        [NotBurstCompatible]
        public int[] ToArray()
        {
            var result = new int[Length];
            unsafe
            {
                byte* s = Buffer;
                fixed(int* d = result)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArrayint that is a copy of this FixedListInt128.
        /// </summary>
        /// <param name="allocator">A member of the
        /// [Unity.Collections.Allocator](https://docs.unity3d.com/ScriptReference/Unity.Collections.Allocator.html) enumeration.</param>
        /// <returns></returns>
        public NativeArray<int> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                byte* s = Buffer;
                var copy = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<int>(s, Length, Allocator.None);
                return new NativeArray<int>(copy, allocator);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListInt128 in ascending order.
        /// </summary>
        public void Sort()
        {
            unsafe
            {
                NativeSortExtension.Sort((int*)Buffer, length);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListInt128 using a custom comparison function.
        /// </summary>
        /// <typeparam name="U">The comparer type.</typeparam>
        /// <param name="comp">A comparison function that indicates whether one element in the array is less than, equal to, or greater than another element.</param>
        [BurstCompatible(GenericTypeArguments = new[] { typeof(NativeSortExtension.DefaultComparer<int>) })]
        public void Sort<U>(U comp) where U : IComparer<int>
        {
            unsafe
            {
                NativeSortExtension.Sort((int*)Buffer, length, comp);
            }
        }


        /// <summary>
        /// Determines whether a FixedListInt128 and FixedListInt32 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt128 to compare for equality</param>
        /// <param name="b">The FixedListInt32 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListInt128 a, in FixedListInt32 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListInt128 and FixedListInt32 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt128 to compare for inequality</param>
        /// <param name="b">The FixedListInt32 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListInt128 a, in FixedListInt32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt32 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt32.
        /// </summary>
        /// <param name="other">The specified FixedListInt32 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListInt32 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt32 and indicates whether this instance
        /// is equal to the specified FixedListInt32.
        /// </summary>
        /// <param name="other">The specified FixedListInt32 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListInt32 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListInt128 that is a copy of a FixedListInt32.
        /// </summary>
        /// <param name="other">The FixedListInt32 to copy</param>
        public FixedListInt128(in FixedListInt32 other)
        {
            FixedList.CheckResize<FixedBytes126,int>(other.length);
            length = other.length;
            buffer = new FixedBytes126();
            unsafe
            {
                fixed(FixedBytes30* s = &other.buffer)
                fixed(FixedBytes126* d = &this.buffer)
                    *(FixedBytes30*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListInt32 to a FixedListInt128.
        /// </summary>
        /// <param name="other">The FixedListInt32 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListInt128(in FixedListInt32 other)
        {
            return new FixedListInt128(other);
        }

        /// <summary>
        /// Determines whether a FixedListInt128 and FixedListInt64 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt128 to compare for equality</param>
        /// <param name="b">The FixedListInt64 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListInt128 a, in FixedListInt64 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListInt128 and FixedListInt64 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt128 to compare for inequality</param>
        /// <param name="b">The FixedListInt64 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListInt128 a, in FixedListInt64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt64 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt64.
        /// </summary>
        /// <param name="other">The specified FixedListInt64 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListInt64 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt64 and indicates whether this instance
        /// is equal to the specified FixedListInt64.
        /// </summary>
        /// <param name="other">The specified FixedListInt64 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListInt64 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListInt128 that is a copy of a FixedListInt64.
        /// </summary>
        /// <param name="other">The FixedListInt64 to copy</param>
        public FixedListInt128(in FixedListInt64 other)
        {
            FixedList.CheckResize<FixedBytes126,int>(other.length);
            length = other.length;
            buffer = new FixedBytes126();
            unsafe
            {
                fixed(FixedBytes62* s = &other.buffer)
                fixed(FixedBytes126* d = &this.buffer)
                    *(FixedBytes62*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListInt64 to a FixedListInt128.
        /// </summary>
        /// <param name="other">The FixedListInt64 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListInt128(in FixedListInt64 other)
        {
            return new FixedListInt128(other);
        }

        /// <summary>
        /// Determines whether a FixedListInt128 and FixedListInt128 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt128 to compare for equality</param>
        /// <param name="b">The FixedListInt128 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListInt128 a, in FixedListInt128 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListInt128 and FixedListInt128 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt128 to compare for inequality</param>
        /// <param name="b">The FixedListInt128 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListInt128 a, in FixedListInt128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt128 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt128.
        /// </summary>
        /// <param name="other">The specified FixedListInt128 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListInt128 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt128 and indicates whether this instance
        /// is equal to the specified FixedListInt128.
        /// </summary>
        /// <param name="other">The specified FixedListInt128 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListInt128 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Determines whether a FixedListInt128 and FixedListInt512 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt128 to compare for equality</param>
        /// <param name="b">The FixedListInt512 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListInt128 a, in FixedListInt512 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListInt128 and FixedListInt512 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt128 to compare for inequality</param>
        /// <param name="b">The FixedListInt512 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListInt128 a, in FixedListInt512 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt512 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt512.
        /// </summary>
        /// <param name="other">The specified FixedListInt512 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListInt512 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt512 and indicates whether this instance
        /// is equal to the specified FixedListInt512.
        /// </summary>
        /// <param name="other">The specified FixedListInt512 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListInt512 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListInt128 that is a copy of a FixedListInt512.
        /// </summary>
        /// <param name="other">The FixedListInt512 to copy</param>
        public FixedListInt128(in FixedListInt512 other)
        {
            FixedList.CheckResize<FixedBytes126,int>(other.length);
            length = other.length;
            buffer = new FixedBytes126();
            unsafe
            {
                fixed(FixedBytes510* s = &other.buffer)
                fixed(FixedBytes126* d = &this.buffer)
                    *d = *(FixedBytes126*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListInt512 to a FixedListInt128.
        /// </summary>
        /// <param name="other">The FixedListInt512 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListInt128(in FixedListInt512 other)
        {
            return new FixedListInt128(other);
        }

        /// <summary>
        /// Determines whether a FixedListInt128 and FixedListInt4096 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt128 to compare for equality</param>
        /// <param name="b">The FixedListInt4096 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListInt128 a, in FixedListInt4096 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListInt128 and FixedListInt4096 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt128 to compare for inequality</param>
        /// <param name="b">The FixedListInt4096 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListInt128 a, in FixedListInt4096 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt4096 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt4096.
        /// </summary>
        /// <param name="other">The specified FixedListInt4096 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListInt4096 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt4096 and indicates whether this instance
        /// is equal to the specified FixedListInt4096.
        /// </summary>
        /// <param name="other">The specified FixedListInt4096 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListInt4096 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListInt128 that is a copy of a FixedListInt4096.
        /// </summary>
        /// <param name="other">The FixedListInt4096 to copy</param>
        public FixedListInt128(in FixedListInt4096 other)
        {
            FixedList.CheckResize<FixedBytes126,int>(other.length);
            length = other.length;
            buffer = new FixedBytes126();
            unsafe
            {
                fixed(FixedBytes4094* s = &other.buffer)
                fixed(FixedBytes126* d = &this.buffer)
                    *d = *(FixedBytes126*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListInt4096 to a FixedListInt128.
        /// </summary>
        /// <param name="other">The FixedListInt4096 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListInt128(in FixedListInt4096 other)
        {
            return new FixedListInt128(other);
        }

        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        /// <returns></returns>
        [NotBurstCompatible]
        public override bool Equals(object obj)
        {
            if(obj is FixedListInt32 aFixedListInt32) return Equals(aFixedListInt32);
            if(obj is FixedListInt64 aFixedListInt64) return Equals(aFixedListInt64);
            if(obj is FixedListInt128 aFixedListInt128) return Equals(aFixedListInt128);
            if(obj is FixedListInt512 aFixedListInt512) return Equals(aFixedListInt512);
            if(obj is FixedListInt4096 aFixedListInt4096) return Equals(aFixedListInt4096);
            return false;
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        public struct Enumerator : IEnumerator<int>
        {
            FixedListInt128 m_List;
            int m_Index;

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <param name="list"><undoc /></param>
            public Enumerator(ref FixedListInt128 list)
            {
                m_List = list;
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Dispose()
            {
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <returns><undoc /></returns>
            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Reset()
            {
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public int Current => m_List[m_Index]; // Let FixedListInt128 indexer check for out of range.

            object IEnumerator.Current => Current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator IEnumerable.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator<int> IEnumerable<int>.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckCapacityInRange(int capacity)
        {
            if(capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }
    }

    sealed class FixedListInt128DebugView
    {
        FixedListInt128 m_List;
        public FixedListInt128DebugView(FixedListInt128 list)
        {
            m_List = list;
        }
        public int[] Items => m_List.ToArray();
    }


    /// <summary>
    /// An unmanaged, resizable list of int that does not allocate memory.
    /// It is 512 bytes in size, and contains all the memory it needs.
    /// </summary>
    [Serializable]
    [StructLayout(LayoutKind.Explicit, Size=512)]
    [DebuggerTypeProxy(typeof(FixedListInt512DebugView))]
    [BurstCompatible]
    public struct FixedListInt512
    : INativeList<int>
    , IEnumerable<int> // Used by collection initializers.
    , IEquatable<FixedListInt32>
    , IComparable<FixedListInt32>
    , IEquatable<FixedListInt64>
    , IComparable<FixedListInt64>
    , IEquatable<FixedListInt128>
    , IComparable<FixedListInt128>
    , IEquatable<FixedListInt512>
    , IComparable<FixedListInt512>
    , IEquatable<FixedListInt4096>
    , IComparable<FixedListInt4096>
    {
        [SerializeField] [FieldOffset(0)] internal ushort length;
        [SerializeField] [FieldOffset(2)] internal FixedBytes510 buffer;

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        [CreateProperty]
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize<FixedBytes510,int>(value);
                length = (ushort)value;
            }
        }

        /// <summary>
        /// A property in order to display items in the Entity Inspector.
        /// </summary>
        [CreateProperty] IEnumerable<int> Elements => this.ToArray();

        /// <summary>
        /// Reports whether container is empty.
        /// </summary>
        /// <value>True if this container empty.</value>
        public bool IsEmpty => Length == 0;

        internal int LengthInBytes => Length * sizeof(int);

        unsafe internal byte* Buffer
        {
            get
            {
                fixed(byte* b = &buffer.offset0000.byte0000)
                    return b + FixedList.PaddingBytes<int>();
            }
        }

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity
        {
            get
            {
                return FixedList.Capacity<FixedBytes510, int>();
            }
            set
            {
                CheckCapacityInRange(value);
            }
        }

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public int this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    return UnsafeUtility.ReadArrayElement<int>(Buffer, index);
                }
            }
            set
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    UnsafeUtility.WriteArrayElement<int>(Buffer, index, value);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public ref int ElementAt(int index)
        {
            FixedList.CheckElementAccess(index, length);
            unsafe
            {
                return ref UnsafeUtility.ArrayElementAsRef<int>(Buffer, index);
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedListInt512.
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                return (int)CollectionHelper.Hash(Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The int to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void Add(in int item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRange(void* ptr, int length)
        {
            int* data = (int*)ptr;
            for (var i = 0; i < length; ++i)
            {
                this[Length++] = data[i];
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The int to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void AddNoResize(int item) => Add(item);

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRangeNoResize(void* ptr, int length) => AddRange(ptr, length);

        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }

        /// <summary>
        /// Searches for the specified int and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListInt512 that starts at the specified index and contains the specified
        /// number of elements.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt512.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <param name="count">The number of elements in the section to search.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(int item, int index, int count)
        {
            for(var i = index; i < index + count; ++i)
                if(this[i].Equals(item))
                  return i;
            return -1;
        }

        /// <summary>
        /// Searches for the specified int and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListInt512 that starts at the specified index.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt512.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(int item, int index)
        {
            return IndexOf(item, index, Length - index);
        }

        /// <summary>
        /// Determines whether an element is in the FixedListInt512.
        /// </summary>
        /// <param name="item">The object to locate in the FixedListInt512.</param>
        /// <returns></returns>
        public bool Contains(int item)
        {
            return IndexOf(item) >= 0;
        }

        /// <summary>
        /// Searches for the specified int and returns the zero-based index of the first occurrence within the entire FixedListInt512.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt512.</param>
        /// <returns></returns>
        public int IndexOf(int item)
        {
            for (var i = 0; i < length; ++i)
            {
                if (this[i].Equals(item))
                {
                    return i;
                }
            }

            return -1;
        }

        /// <summary>
        /// Inserts a number of items into a FixedListInt512 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="end">The zero-based index just after where the elements should be removed.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void InsertRangeWithBeginEnd(int begin, int end)
        {
            int items = end - begin;
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(int);
            unsafe
            {
                byte* b = Buffer;
                byte *dest = b + end * sizeof(int);
                byte *src = b + begin * sizeof(int);
                UnsafeUtility.MemMove(dest, src, bytesToCopy);
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedListInt512 at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>
        public void Insert(int index, int item)
        {
            InsertRangeWithBeginEnd(index, index+1);
            this[index] = item;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index with the last item in the list. The list
        /// is shortened by one.
        /// </summary>
        /// <param name="index">The index of the item to delete.</param>
        public void RemoveAtSwapBack(int index)
        {
            RemoveRangeSwapBackWithBeginEnd(index, index + 1);
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedListInt512 and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedListInt512.</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool RemoveSwapBack(int item)
        {
            var index = IndexOf(item);
            if (index == -1)
            {
                return false;
            }

            RemoveAtSwapBack(index);
            return true;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index range with the items from the end the list. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeSwapBackWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                int copyFrom = math.max(Length - itemsToRemove, end);

                unsafe
                {
                    var sizeOf = sizeof(int);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                }

                Length -= itemsToRemove;
            }
        }

        /// <summary>
        /// Removes the int at the specified index, and copies all subsequent elements backward to fill the
        /// hole so created.
        /// </summary>
        /// <param name="index">The zero-based index at which to remove the int</param>
        public void RemoveAt(int index)
        {
            RemoveRangeWithBeginEnd(index, index+1);
        }

        /// <summary>
        /// Searches for the specified int from the begining of the FixedListInt512 forward, removes it if possible,
        /// and returns true if the int was successfully removed.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt512</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool Remove(int item)
        {
            int index = IndexOf(item);
            if (index < 0)
            {
                return false;
            }

            RemoveAt(index);

            return true;
        }

        /// <summary>
        /// Truncates the list by removing the items at the specified index range, and shifting all remaining items to replace removed items. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <remarks>
        /// This method of removing item(s) is useful only in case when list is ordered and user wants to preserve order
        /// in list after removal In majority of cases is not important and user should use more performant `RemoveRangeSwapBackWithBeginEnd`.
        /// </remarks>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                unsafe
                {
                    var sizeOf = sizeof(int);
                    int copyFrom = math.min(begin + itemsToRemove, Length);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                    Length -= itemsToRemove;
                }
            }
        }

        /// <summary>
        /// Creates a managed Array of int that is a copy of this FixedListInt512.
        /// </summary>
        /// <returns></returns>
        [NotBurstCompatible]
        public int[] ToArray()
        {
            var result = new int[Length];
            unsafe
            {
                byte* s = Buffer;
                fixed(int* d = result)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArrayint that is a copy of this FixedListInt512.
        /// </summary>
        /// <param name="allocator">A member of the
        /// [Unity.Collections.Allocator](https://docs.unity3d.com/ScriptReference/Unity.Collections.Allocator.html) enumeration.</param>
        /// <returns></returns>
        public NativeArray<int> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                byte* s = Buffer;
                var copy = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<int>(s, Length, Allocator.None);
                return new NativeArray<int>(copy, allocator);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListInt512 in ascending order.
        /// </summary>
        public void Sort()
        {
            unsafe
            {
                NativeSortExtension.Sort((int*)Buffer, length);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListInt512 using a custom comparison function.
        /// </summary>
        /// <typeparam name="U">The comparer type.</typeparam>
        /// <param name="comp">A comparison function that indicates whether one element in the array is less than, equal to, or greater than another element.</param>
        [BurstCompatible(GenericTypeArguments = new[] { typeof(NativeSortExtension.DefaultComparer<int>) })]
        public void Sort<U>(U comp) where U : IComparer<int>
        {
            unsafe
            {
                NativeSortExtension.Sort((int*)Buffer, length, comp);
            }
        }


        /// <summary>
        /// Determines whether a FixedListInt512 and FixedListInt32 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt512 to compare for equality</param>
        /// <param name="b">The FixedListInt32 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListInt512 a, in FixedListInt32 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListInt512 and FixedListInt32 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt512 to compare for inequality</param>
        /// <param name="b">The FixedListInt32 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListInt512 a, in FixedListInt32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt32 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt32.
        /// </summary>
        /// <param name="other">The specified FixedListInt32 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListInt32 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt32 and indicates whether this instance
        /// is equal to the specified FixedListInt32.
        /// </summary>
        /// <param name="other">The specified FixedListInt32 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListInt32 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListInt512 that is a copy of a FixedListInt32.
        /// </summary>
        /// <param name="other">The FixedListInt32 to copy</param>
        public FixedListInt512(in FixedListInt32 other)
        {
            FixedList.CheckResize<FixedBytes510,int>(other.length);
            length = other.length;
            buffer = new FixedBytes510();
            unsafe
            {
                fixed(FixedBytes30* s = &other.buffer)
                fixed(FixedBytes510* d = &this.buffer)
                    *(FixedBytes30*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListInt32 to a FixedListInt512.
        /// </summary>
        /// <param name="other">The FixedListInt32 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListInt512(in FixedListInt32 other)
        {
            return new FixedListInt512(other);
        }

        /// <summary>
        /// Determines whether a FixedListInt512 and FixedListInt64 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt512 to compare for equality</param>
        /// <param name="b">The FixedListInt64 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListInt512 a, in FixedListInt64 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListInt512 and FixedListInt64 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt512 to compare for inequality</param>
        /// <param name="b">The FixedListInt64 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListInt512 a, in FixedListInt64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt64 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt64.
        /// </summary>
        /// <param name="other">The specified FixedListInt64 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListInt64 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt64 and indicates whether this instance
        /// is equal to the specified FixedListInt64.
        /// </summary>
        /// <param name="other">The specified FixedListInt64 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListInt64 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListInt512 that is a copy of a FixedListInt64.
        /// </summary>
        /// <param name="other">The FixedListInt64 to copy</param>
        public FixedListInt512(in FixedListInt64 other)
        {
            FixedList.CheckResize<FixedBytes510,int>(other.length);
            length = other.length;
            buffer = new FixedBytes510();
            unsafe
            {
                fixed(FixedBytes62* s = &other.buffer)
                fixed(FixedBytes510* d = &this.buffer)
                    *(FixedBytes62*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListInt64 to a FixedListInt512.
        /// </summary>
        /// <param name="other">The FixedListInt64 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListInt512(in FixedListInt64 other)
        {
            return new FixedListInt512(other);
        }

        /// <summary>
        /// Determines whether a FixedListInt512 and FixedListInt128 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt512 to compare for equality</param>
        /// <param name="b">The FixedListInt128 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListInt512 a, in FixedListInt128 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListInt512 and FixedListInt128 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt512 to compare for inequality</param>
        /// <param name="b">The FixedListInt128 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListInt512 a, in FixedListInt128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt128 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt128.
        /// </summary>
        /// <param name="other">The specified FixedListInt128 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListInt128 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt128 and indicates whether this instance
        /// is equal to the specified FixedListInt128.
        /// </summary>
        /// <param name="other">The specified FixedListInt128 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListInt128 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListInt512 that is a copy of a FixedListInt128.
        /// </summary>
        /// <param name="other">The FixedListInt128 to copy</param>
        public FixedListInt512(in FixedListInt128 other)
        {
            FixedList.CheckResize<FixedBytes510,int>(other.length);
            length = other.length;
            buffer = new FixedBytes510();
            unsafe
            {
                fixed(FixedBytes126* s = &other.buffer)
                fixed(FixedBytes510* d = &this.buffer)
                    *(FixedBytes126*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListInt128 to a FixedListInt512.
        /// </summary>
        /// <param name="other">The FixedListInt128 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListInt512(in FixedListInt128 other)
        {
            return new FixedListInt512(other);
        }

        /// <summary>
        /// Determines whether a FixedListInt512 and FixedListInt512 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt512 to compare for equality</param>
        /// <param name="b">The FixedListInt512 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListInt512 a, in FixedListInt512 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListInt512 and FixedListInt512 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt512 to compare for inequality</param>
        /// <param name="b">The FixedListInt512 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListInt512 a, in FixedListInt512 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt512 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt512.
        /// </summary>
        /// <param name="other">The specified FixedListInt512 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListInt512 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt512 and indicates whether this instance
        /// is equal to the specified FixedListInt512.
        /// </summary>
        /// <param name="other">The specified FixedListInt512 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListInt512 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Determines whether a FixedListInt512 and FixedListInt4096 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt512 to compare for equality</param>
        /// <param name="b">The FixedListInt4096 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListInt512 a, in FixedListInt4096 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListInt512 and FixedListInt4096 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt512 to compare for inequality</param>
        /// <param name="b">The FixedListInt4096 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListInt512 a, in FixedListInt4096 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt4096 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt4096.
        /// </summary>
        /// <param name="other">The specified FixedListInt4096 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListInt4096 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt4096 and indicates whether this instance
        /// is equal to the specified FixedListInt4096.
        /// </summary>
        /// <param name="other">The specified FixedListInt4096 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListInt4096 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListInt512 that is a copy of a FixedListInt4096.
        /// </summary>
        /// <param name="other">The FixedListInt4096 to copy</param>
        public FixedListInt512(in FixedListInt4096 other)
        {
            FixedList.CheckResize<FixedBytes510,int>(other.length);
            length = other.length;
            buffer = new FixedBytes510();
            unsafe
            {
                fixed(FixedBytes4094* s = &other.buffer)
                fixed(FixedBytes510* d = &this.buffer)
                    *d = *(FixedBytes510*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListInt4096 to a FixedListInt512.
        /// </summary>
        /// <param name="other">The FixedListInt4096 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListInt512(in FixedListInt4096 other)
        {
            return new FixedListInt512(other);
        }

        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        /// <returns></returns>
        [NotBurstCompatible]
        public override bool Equals(object obj)
        {
            if(obj is FixedListInt32 aFixedListInt32) return Equals(aFixedListInt32);
            if(obj is FixedListInt64 aFixedListInt64) return Equals(aFixedListInt64);
            if(obj is FixedListInt128 aFixedListInt128) return Equals(aFixedListInt128);
            if(obj is FixedListInt512 aFixedListInt512) return Equals(aFixedListInt512);
            if(obj is FixedListInt4096 aFixedListInt4096) return Equals(aFixedListInt4096);
            return false;
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        public struct Enumerator : IEnumerator<int>
        {
            FixedListInt512 m_List;
            int m_Index;

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <param name="list"><undoc /></param>
            public Enumerator(ref FixedListInt512 list)
            {
                m_List = list;
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Dispose()
            {
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <returns><undoc /></returns>
            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Reset()
            {
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public int Current => m_List[m_Index]; // Let FixedListInt512 indexer check for out of range.

            object IEnumerator.Current => Current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator IEnumerable.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator<int> IEnumerable<int>.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckCapacityInRange(int capacity)
        {
            if(capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }
    }

    sealed class FixedListInt512DebugView
    {
        FixedListInt512 m_List;
        public FixedListInt512DebugView(FixedListInt512 list)
        {
            m_List = list;
        }
        public int[] Items => m_List.ToArray();
    }


    /// <summary>
    /// An unmanaged, resizable list of int that does not allocate memory.
    /// It is 4096 bytes in size, and contains all the memory it needs.
    /// </summary>
    [Serializable]
    [StructLayout(LayoutKind.Explicit, Size=4096)]
    [DebuggerTypeProxy(typeof(FixedListInt4096DebugView))]
    [BurstCompatible]
    public struct FixedListInt4096
    : INativeList<int>
    , IEnumerable<int> // Used by collection initializers.
    , IEquatable<FixedListInt32>
    , IComparable<FixedListInt32>
    , IEquatable<FixedListInt64>
    , IComparable<FixedListInt64>
    , IEquatable<FixedListInt128>
    , IComparable<FixedListInt128>
    , IEquatable<FixedListInt512>
    , IComparable<FixedListInt512>
    , IEquatable<FixedListInt4096>
    , IComparable<FixedListInt4096>
    {
        [SerializeField] [FieldOffset(0)] internal ushort length;
        [SerializeField] [FieldOffset(2)] internal FixedBytes4094 buffer;

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        [CreateProperty]
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize<FixedBytes4094,int>(value);
                length = (ushort)value;
            }
        }

        /// <summary>
        /// A property in order to display items in the Entity Inspector.
        /// </summary>
        [CreateProperty] IEnumerable<int> Elements => this.ToArray();

        /// <summary>
        /// Reports whether container is empty.
        /// </summary>
        /// <value>True if this container empty.</value>
        public bool IsEmpty => Length == 0;

        internal int LengthInBytes => Length * sizeof(int);

        unsafe internal byte* Buffer
        {
            get
            {
                fixed(byte* b = &buffer.offset0000.byte0000)
                    return b + FixedList.PaddingBytes<int>();
            }
        }

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity
        {
            get
            {
                return FixedList.Capacity<FixedBytes4094, int>();
            }
            set
            {
                CheckCapacityInRange(value);
            }
        }

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public int this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    return UnsafeUtility.ReadArrayElement<int>(Buffer, index);
                }
            }
            set
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    UnsafeUtility.WriteArrayElement<int>(Buffer, index, value);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public ref int ElementAt(int index)
        {
            FixedList.CheckElementAccess(index, length);
            unsafe
            {
                return ref UnsafeUtility.ArrayElementAsRef<int>(Buffer, index);
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedListInt4096.
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                return (int)CollectionHelper.Hash(Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The int to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void Add(in int item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRange(void* ptr, int length)
        {
            int* data = (int*)ptr;
            for (var i = 0; i < length; ++i)
            {
                this[Length++] = data[i];
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The int to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void AddNoResize(int item) => Add(item);

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRangeNoResize(void* ptr, int length) => AddRange(ptr, length);

        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }

        /// <summary>
        /// Searches for the specified int and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListInt4096 that starts at the specified index and contains the specified
        /// number of elements.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt4096.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <param name="count">The number of elements in the section to search.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(int item, int index, int count)
        {
            for(var i = index; i < index + count; ++i)
                if(this[i].Equals(item))
                  return i;
            return -1;
        }

        /// <summary>
        /// Searches for the specified int and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListInt4096 that starts at the specified index.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt4096.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(int item, int index)
        {
            return IndexOf(item, index, Length - index);
        }

        /// <summary>
        /// Determines whether an element is in the FixedListInt4096.
        /// </summary>
        /// <param name="item">The object to locate in the FixedListInt4096.</param>
        /// <returns></returns>
        public bool Contains(int item)
        {
            return IndexOf(item) >= 0;
        }

        /// <summary>
        /// Searches for the specified int and returns the zero-based index of the first occurrence within the entire FixedListInt4096.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt4096.</param>
        /// <returns></returns>
        public int IndexOf(int item)
        {
            for (var i = 0; i < length; ++i)
            {
                if (this[i].Equals(item))
                {
                    return i;
                }
            }

            return -1;
        }

        /// <summary>
        /// Inserts a number of items into a FixedListInt4096 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="end">The zero-based index just after where the elements should be removed.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void InsertRangeWithBeginEnd(int begin, int end)
        {
            int items = end - begin;
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(int);
            unsafe
            {
                byte* b = Buffer;
                byte *dest = b + end * sizeof(int);
                byte *src = b + begin * sizeof(int);
                UnsafeUtility.MemMove(dest, src, bytesToCopy);
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedListInt4096 at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>
        public void Insert(int index, int item)
        {
            InsertRangeWithBeginEnd(index, index+1);
            this[index] = item;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index with the last item in the list. The list
        /// is shortened by one.
        /// </summary>
        /// <param name="index">The index of the item to delete.</param>
        public void RemoveAtSwapBack(int index)
        {
            RemoveRangeSwapBackWithBeginEnd(index, index + 1);
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedListInt4096 and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedListInt4096.</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool RemoveSwapBack(int item)
        {
            var index = IndexOf(item);
            if (index == -1)
            {
                return false;
            }

            RemoveAtSwapBack(index);
            return true;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index range with the items from the end the list. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeSwapBackWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                int copyFrom = math.max(Length - itemsToRemove, end);

                unsafe
                {
                    var sizeOf = sizeof(int);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                }

                Length -= itemsToRemove;
            }
        }

        /// <summary>
        /// Removes the int at the specified index, and copies all subsequent elements backward to fill the
        /// hole so created.
        /// </summary>
        /// <param name="index">The zero-based index at which to remove the int</param>
        public void RemoveAt(int index)
        {
            RemoveRangeWithBeginEnd(index, index+1);
        }

        /// <summary>
        /// Searches for the specified int from the begining of the FixedListInt4096 forward, removes it if possible,
        /// and returns true if the int was successfully removed.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt4096</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool Remove(int item)
        {
            int index = IndexOf(item);
            if (index < 0)
            {
                return false;
            }

            RemoveAt(index);

            return true;
        }

        /// <summary>
        /// Truncates the list by removing the items at the specified index range, and shifting all remaining items to replace removed items. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <remarks>
        /// This method of removing item(s) is useful only in case when list is ordered and user wants to preserve order
        /// in list after removal In majority of cases is not important and user should use more performant `RemoveRangeSwapBackWithBeginEnd`.
        /// </remarks>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                unsafe
                {
                    var sizeOf = sizeof(int);
                    int copyFrom = math.min(begin + itemsToRemove, Length);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                    Length -= itemsToRemove;
                }
            }
        }

        /// <summary>
        /// Creates a managed Array of int that is a copy of this FixedListInt4096.
        /// </summary>
        /// <returns></returns>
        [NotBurstCompatible]
        public int[] ToArray()
        {
            var result = new int[Length];
            unsafe
            {
                byte* s = Buffer;
                fixed(int* d = result)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArrayint that is a copy of this FixedListInt4096.
        /// </summary>
        /// <param name="allocator">A member of the
        /// [Unity.Collections.Allocator](https://docs.unity3d.com/ScriptReference/Unity.Collections.Allocator.html) enumeration.</param>
        /// <returns></returns>
        public NativeArray<int> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                byte* s = Buffer;
                var copy = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<int>(s, Length, Allocator.None);
                return new NativeArray<int>(copy, allocator);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListInt4096 in ascending order.
        /// </summary>
        public void Sort()
        {
            unsafe
            {
                NativeSortExtension.Sort((int*)Buffer, length);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListInt4096 using a custom comparison function.
        /// </summary>
        /// <typeparam name="U">The comparer type.</typeparam>
        /// <param name="comp">A comparison function that indicates whether one element in the array is less than, equal to, or greater than another element.</param>
        [BurstCompatible(GenericTypeArguments = new[] { typeof(NativeSortExtension.DefaultComparer<int>) })]
        public void Sort<U>(U comp) where U : IComparer<int>
        {
            unsafe
            {
                NativeSortExtension.Sort((int*)Buffer, length, comp);
            }
        }


        /// <summary>
        /// Determines whether a FixedListInt4096 and FixedListInt32 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt4096 to compare for equality</param>
        /// <param name="b">The FixedListInt32 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListInt4096 a, in FixedListInt32 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListInt4096 and FixedListInt32 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt4096 to compare for inequality</param>
        /// <param name="b">The FixedListInt32 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListInt4096 a, in FixedListInt32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt32 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt32.
        /// </summary>
        /// <param name="other">The specified FixedListInt32 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListInt32 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt32 and indicates whether this instance
        /// is equal to the specified FixedListInt32.
        /// </summary>
        /// <param name="other">The specified FixedListInt32 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListInt32 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListInt4096 that is a copy of a FixedListInt32.
        /// </summary>
        /// <param name="other">The FixedListInt32 to copy</param>
        public FixedListInt4096(in FixedListInt32 other)
        {
            FixedList.CheckResize<FixedBytes4094,int>(other.length);
            length = other.length;
            buffer = new FixedBytes4094();
            unsafe
            {
                fixed(FixedBytes30* s = &other.buffer)
                fixed(FixedBytes4094* d = &this.buffer)
                    *(FixedBytes30*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListInt32 to a FixedListInt4096.
        /// </summary>
        /// <param name="other">The FixedListInt32 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListInt4096(in FixedListInt32 other)
        {
            return new FixedListInt4096(other);
        }

        /// <summary>
        /// Determines whether a FixedListInt4096 and FixedListInt64 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt4096 to compare for equality</param>
        /// <param name="b">The FixedListInt64 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListInt4096 a, in FixedListInt64 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListInt4096 and FixedListInt64 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt4096 to compare for inequality</param>
        /// <param name="b">The FixedListInt64 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListInt4096 a, in FixedListInt64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt64 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt64.
        /// </summary>
        /// <param name="other">The specified FixedListInt64 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListInt64 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt64 and indicates whether this instance
        /// is equal to the specified FixedListInt64.
        /// </summary>
        /// <param name="other">The specified FixedListInt64 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListInt64 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListInt4096 that is a copy of a FixedListInt64.
        /// </summary>
        /// <param name="other">The FixedListInt64 to copy</param>
        public FixedListInt4096(in FixedListInt64 other)
        {
            FixedList.CheckResize<FixedBytes4094,int>(other.length);
            length = other.length;
            buffer = new FixedBytes4094();
            unsafe
            {
                fixed(FixedBytes62* s = &other.buffer)
                fixed(FixedBytes4094* d = &this.buffer)
                    *(FixedBytes62*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListInt64 to a FixedListInt4096.
        /// </summary>
        /// <param name="other">The FixedListInt64 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListInt4096(in FixedListInt64 other)
        {
            return new FixedListInt4096(other);
        }

        /// <summary>
        /// Determines whether a FixedListInt4096 and FixedListInt128 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt4096 to compare for equality</param>
        /// <param name="b">The FixedListInt128 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListInt4096 a, in FixedListInt128 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListInt4096 and FixedListInt128 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt4096 to compare for inequality</param>
        /// <param name="b">The FixedListInt128 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListInt4096 a, in FixedListInt128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt128 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt128.
        /// </summary>
        /// <param name="other">The specified FixedListInt128 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListInt128 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt128 and indicates whether this instance
        /// is equal to the specified FixedListInt128.
        /// </summary>
        /// <param name="other">The specified FixedListInt128 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListInt128 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListInt4096 that is a copy of a FixedListInt128.
        /// </summary>
        /// <param name="other">The FixedListInt128 to copy</param>
        public FixedListInt4096(in FixedListInt128 other)
        {
            FixedList.CheckResize<FixedBytes4094,int>(other.length);
            length = other.length;
            buffer = new FixedBytes4094();
            unsafe
            {
                fixed(FixedBytes126* s = &other.buffer)
                fixed(FixedBytes4094* d = &this.buffer)
                    *(FixedBytes126*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListInt128 to a FixedListInt4096.
        /// </summary>
        /// <param name="other">The FixedListInt128 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListInt4096(in FixedListInt128 other)
        {
            return new FixedListInt4096(other);
        }

        /// <summary>
        /// Determines whether a FixedListInt4096 and FixedListInt512 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt4096 to compare for equality</param>
        /// <param name="b">The FixedListInt512 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListInt4096 a, in FixedListInt512 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListInt4096 and FixedListInt512 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt4096 to compare for inequality</param>
        /// <param name="b">The FixedListInt512 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListInt4096 a, in FixedListInt512 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt512 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt512.
        /// </summary>
        /// <param name="other">The specified FixedListInt512 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListInt512 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt512 and indicates whether this instance
        /// is equal to the specified FixedListInt512.
        /// </summary>
        /// <param name="other">The specified FixedListInt512 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListInt512 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListInt4096 that is a copy of a FixedListInt512.
        /// </summary>
        /// <param name="other">The FixedListInt512 to copy</param>
        public FixedListInt4096(in FixedListInt512 other)
        {
            FixedList.CheckResize<FixedBytes4094,int>(other.length);
            length = other.length;
            buffer = new FixedBytes4094();
            unsafe
            {
                fixed(FixedBytes510* s = &other.buffer)
                fixed(FixedBytes4094* d = &this.buffer)
                    *(FixedBytes510*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListInt512 to a FixedListInt4096.
        /// </summary>
        /// <param name="other">The FixedListInt512 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListInt4096(in FixedListInt512 other)
        {
            return new FixedListInt4096(other);
        }

        /// <summary>
        /// Determines whether a FixedListInt4096 and FixedListInt4096 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt4096 to compare for equality</param>
        /// <param name="b">The FixedListInt4096 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListInt4096 a, in FixedListInt4096 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListInt4096 and FixedListInt4096 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt4096 to compare for inequality</param>
        /// <param name="b">The FixedListInt4096 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListInt4096 a, in FixedListInt4096 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt4096 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt4096.
        /// </summary>
        /// <param name="other">The specified FixedListInt4096 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListInt4096 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt4096 and indicates whether this instance
        /// is equal to the specified FixedListInt4096.
        /// </summary>
        /// <param name="other">The specified FixedListInt4096 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListInt4096 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        /// <returns></returns>
        [NotBurstCompatible]
        public override bool Equals(object obj)
        {
            if(obj is FixedListInt32 aFixedListInt32) return Equals(aFixedListInt32);
            if(obj is FixedListInt64 aFixedListInt64) return Equals(aFixedListInt64);
            if(obj is FixedListInt128 aFixedListInt128) return Equals(aFixedListInt128);
            if(obj is FixedListInt512 aFixedListInt512) return Equals(aFixedListInt512);
            if(obj is FixedListInt4096 aFixedListInt4096) return Equals(aFixedListInt4096);
            return false;
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        public struct Enumerator : IEnumerator<int>
        {
            FixedListInt4096 m_List;
            int m_Index;

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <param name="list"><undoc /></param>
            public Enumerator(ref FixedListInt4096 list)
            {
                m_List = list;
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Dispose()
            {
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <returns><undoc /></returns>
            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Reset()
            {
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public int Current => m_List[m_Index]; // Let FixedListInt4096 indexer check for out of range.

            object IEnumerator.Current => Current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator IEnumerable.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator<int> IEnumerable<int>.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckCapacityInRange(int capacity)
        {
            if(capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }
    }

    sealed class FixedListInt4096DebugView
    {
        FixedListInt4096 m_List;
        public FixedListInt4096DebugView(FixedListInt4096 list)
        {
            m_List = list;
        }
        public int[] Items => m_List.ToArray();
    }


    /// <summary>
    /// An unmanaged, resizable list of float that does not allocate memory.
    /// It is 32 bytes in size, and contains all the memory it needs.
    /// </summary>
    [Serializable]
    [StructLayout(LayoutKind.Explicit, Size=32)]
    [DebuggerTypeProxy(typeof(FixedListFloat32DebugView))]
    [BurstCompatible]
    public struct FixedListFloat32
    : INativeList<float>
    , IEnumerable<float> // Used by collection initializers.
    , IEquatable<FixedListFloat32>
    , IComparable<FixedListFloat32>
    , IEquatable<FixedListFloat64>
    , IComparable<FixedListFloat64>
    , IEquatable<FixedListFloat128>
    , IComparable<FixedListFloat128>
    , IEquatable<FixedListFloat512>
    , IComparable<FixedListFloat512>
    , IEquatable<FixedListFloat4096>
    , IComparable<FixedListFloat4096>
    {
        [SerializeField] [FieldOffset(0)] internal ushort length;
        [SerializeField] [FieldOffset(2)] internal FixedBytes30 buffer;

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        [CreateProperty]
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize<FixedBytes30,float>(value);
                length = (ushort)value;
            }
        }

        /// <summary>
        /// A property in order to display items in the Entity Inspector.
        /// </summary>
        [CreateProperty] IEnumerable<float> Elements => this.ToArray();

        /// <summary>
        /// Reports whether container is empty.
        /// </summary>
        /// <value>True if this container empty.</value>
        public bool IsEmpty => Length == 0;

        internal int LengthInBytes => Length * sizeof(float);

        unsafe internal byte* Buffer
        {
            get
            {
                fixed(byte* b = &buffer.offset0000.byte0000)
                    return b + FixedList.PaddingBytes<float>();
            }
        }

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity
        {
            get
            {
                return FixedList.Capacity<FixedBytes30, float>();
            }
            set
            {
                CheckCapacityInRange(value);
            }
        }

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public float this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    return UnsafeUtility.ReadArrayElement<float>(Buffer, index);
                }
            }
            set
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    UnsafeUtility.WriteArrayElement<float>(Buffer, index, value);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public ref float ElementAt(int index)
        {
            FixedList.CheckElementAccess(index, length);
            unsafe
            {
                return ref UnsafeUtility.ArrayElementAsRef<float>(Buffer, index);
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedListFloat32.
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                return (int)CollectionHelper.Hash(Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The float to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void Add(in float item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRange(void* ptr, int length)
        {
            float* data = (float*)ptr;
            for (var i = 0; i < length; ++i)
            {
                this[Length++] = data[i];
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The float to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void AddNoResize(float item) => Add(item);

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRangeNoResize(void* ptr, int length) => AddRange(ptr, length);

        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }

        /// <summary>
        /// Searches for the specified float and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListFloat32 that starts at the specified index and contains the specified
        /// number of elements.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat32.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <param name="count">The number of elements in the section to search.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(float item, int index, int count)
        {
            for(var i = index; i < index + count; ++i)
                if(this[i].Equals(item))
                  return i;
            return -1;
        }

        /// <summary>
        /// Searches for the specified float and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListFloat32 that starts at the specified index.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat32.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(float item, int index)
        {
            return IndexOf(item, index, Length - index);
        }

        /// <summary>
        /// Determines whether an element is in the FixedListFloat32.
        /// </summary>
        /// <param name="item">The object to locate in the FixedListFloat32.</param>
        /// <returns></returns>
        public bool Contains(float item)
        {
            return IndexOf(item) >= 0;
        }

        /// <summary>
        /// Searches for the specified float and returns the zero-based index of the first occurrence within the entire FixedListFloat32.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat32.</param>
        /// <returns></returns>
        public int IndexOf(float item)
        {
            for (var i = 0; i < length; ++i)
            {
                if (this[i].Equals(item))
                {
                    return i;
                }
            }

            return -1;
        }

        /// <summary>
        /// Inserts a number of items into a FixedListFloat32 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="end">The zero-based index just after where the elements should be removed.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void InsertRangeWithBeginEnd(int begin, int end)
        {
            int items = end - begin;
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(float);
            unsafe
            {
                byte* b = Buffer;
                byte *dest = b + end * sizeof(float);
                byte *src = b + begin * sizeof(float);
                UnsafeUtility.MemMove(dest, src, bytesToCopy);
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedListFloat32 at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>
        public void Insert(int index, float item)
        {
            InsertRangeWithBeginEnd(index, index+1);
            this[index] = item;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index with the last item in the list. The list
        /// is shortened by one.
        /// </summary>
        /// <param name="index">The index of the item to delete.</param>
        public void RemoveAtSwapBack(int index)
        {
            RemoveRangeSwapBackWithBeginEnd(index, index + 1);
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedListFloat32 and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedListFloat32.</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool RemoveSwapBack(float item)
        {
            var index = IndexOf(item);
            if (index == -1)
            {
                return false;
            }

            RemoveAtSwapBack(index);
            return true;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index range with the items from the end the list. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeSwapBackWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                int copyFrom = math.max(Length - itemsToRemove, end);

                unsafe
                {
                    var sizeOf = sizeof(float);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                }

                Length -= itemsToRemove;
            }
        }

        /// <summary>
        /// Removes the float at the specified index, and copies all subsequent elements backward to fill the
        /// hole so created.
        /// </summary>
        /// <param name="index">The zero-based index at which to remove the float</param>
        public void RemoveAt(int index)
        {
            RemoveRangeWithBeginEnd(index, index+1);
        }

        /// <summary>
        /// Searches for the specified float from the begining of the FixedListFloat32 forward, removes it if possible,
        /// and returns true if the float was successfully removed.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat32</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool Remove(float item)
        {
            int index = IndexOf(item);
            if (index < 0)
            {
                return false;
            }

            RemoveAt(index);

            return true;
        }

        /// <summary>
        /// Truncates the list by removing the items at the specified index range, and shifting all remaining items to replace removed items. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <remarks>
        /// This method of removing item(s) is useful only in case when list is ordered and user wants to preserve order
        /// in list after removal In majority of cases is not important and user should use more performant `RemoveRangeSwapBackWithBeginEnd`.
        /// </remarks>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                unsafe
                {
                    var sizeOf = sizeof(float);
                    int copyFrom = math.min(begin + itemsToRemove, Length);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                    Length -= itemsToRemove;
                }
            }
        }

        /// <summary>
        /// Creates a managed Array of float that is a copy of this FixedListFloat32.
        /// </summary>
        /// <returns></returns>
        [NotBurstCompatible]
        public float[] ToArray()
        {
            var result = new float[Length];
            unsafe
            {
                byte* s = Buffer;
                fixed(float* d = result)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArrayfloat that is a copy of this FixedListFloat32.
        /// </summary>
        /// <param name="allocator">A member of the
        /// [Unity.Collections.Allocator](https://docs.unity3d.com/ScriptReference/Unity.Collections.Allocator.html) enumeration.</param>
        /// <returns></returns>
        public NativeArray<float> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                byte* s = Buffer;
                var copy = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<float>(s, Length, Allocator.None);
                return new NativeArray<float>(copy, allocator);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListFloat32 in ascending order.
        /// </summary>
        public void Sort()
        {
            unsafe
            {
                NativeSortExtension.Sort((float*)Buffer, length);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListFloat32 using a custom comparison function.
        /// </summary>
        /// <typeparam name="U">The comparer type.</typeparam>
        /// <param name="comp">A comparison function that indicates whether one element in the array is less than, equal to, or greater than another element.</param>
        [BurstCompatible(GenericTypeArguments = new[] { typeof(NativeSortExtension.DefaultComparer<float>) })]
        public void Sort<U>(U comp) where U : IComparer<float>
        {
            unsafe
            {
                NativeSortExtension.Sort((float*)Buffer, length, comp);
            }
        }


        /// <summary>
        /// Determines whether a FixedListFloat32 and FixedListFloat32 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat32 to compare for equality</param>
        /// <param name="b">The FixedListFloat32 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListFloat32 a, in FixedListFloat32 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListFloat32 and FixedListFloat32 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat32 to compare for inequality</param>
        /// <param name="b">The FixedListFloat32 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListFloat32 a, in FixedListFloat32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat32 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat32.
        /// </summary>
        /// <param name="other">The specified FixedListFloat32 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListFloat32 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat32 and indicates whether this instance
        /// is equal to the specified FixedListFloat32.
        /// </summary>
        /// <param name="other">The specified FixedListFloat32 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListFloat32 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Determines whether a FixedListFloat32 and FixedListFloat64 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat32 to compare for equality</param>
        /// <param name="b">The FixedListFloat64 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListFloat32 a, in FixedListFloat64 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListFloat32 and FixedListFloat64 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat32 to compare for inequality</param>
        /// <param name="b">The FixedListFloat64 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListFloat32 a, in FixedListFloat64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat64 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat64.
        /// </summary>
        /// <param name="other">The specified FixedListFloat64 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListFloat64 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat64 and indicates whether this instance
        /// is equal to the specified FixedListFloat64.
        /// </summary>
        /// <param name="other">The specified FixedListFloat64 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListFloat64 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListFloat32 that is a copy of a FixedListFloat64.
        /// </summary>
        /// <param name="other">The FixedListFloat64 to copy</param>
        public FixedListFloat32(in FixedListFloat64 other)
        {
            FixedList.CheckResize<FixedBytes30,float>(other.length);
            length = other.length;
            buffer = new FixedBytes30();
            unsafe
            {
                fixed(FixedBytes62* s = &other.buffer)
                fixed(FixedBytes30* d = &this.buffer)
                    *d = *(FixedBytes30*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListFloat64 to a FixedListFloat32.
        /// </summary>
        /// <param name="other">The FixedListFloat64 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListFloat32(in FixedListFloat64 other)
        {
            return new FixedListFloat32(other);
        }

        /// <summary>
        /// Determines whether a FixedListFloat32 and FixedListFloat128 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat32 to compare for equality</param>
        /// <param name="b">The FixedListFloat128 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListFloat32 a, in FixedListFloat128 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListFloat32 and FixedListFloat128 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat32 to compare for inequality</param>
        /// <param name="b">The FixedListFloat128 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListFloat32 a, in FixedListFloat128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat128 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat128.
        /// </summary>
        /// <param name="other">The specified FixedListFloat128 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListFloat128 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat128 and indicates whether this instance
        /// is equal to the specified FixedListFloat128.
        /// </summary>
        /// <param name="other">The specified FixedListFloat128 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListFloat128 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListFloat32 that is a copy of a FixedListFloat128.
        /// </summary>
        /// <param name="other">The FixedListFloat128 to copy</param>
        public FixedListFloat32(in FixedListFloat128 other)
        {
            FixedList.CheckResize<FixedBytes30,float>(other.length);
            length = other.length;
            buffer = new FixedBytes30();
            unsafe
            {
                fixed(FixedBytes126* s = &other.buffer)
                fixed(FixedBytes30* d = &this.buffer)
                    *d = *(FixedBytes30*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListFloat128 to a FixedListFloat32.
        /// </summary>
        /// <param name="other">The FixedListFloat128 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListFloat32(in FixedListFloat128 other)
        {
            return new FixedListFloat32(other);
        }

        /// <summary>
        /// Determines whether a FixedListFloat32 and FixedListFloat512 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat32 to compare for equality</param>
        /// <param name="b">The FixedListFloat512 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListFloat32 a, in FixedListFloat512 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListFloat32 and FixedListFloat512 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat32 to compare for inequality</param>
        /// <param name="b">The FixedListFloat512 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListFloat32 a, in FixedListFloat512 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat512 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat512.
        /// </summary>
        /// <param name="other">The specified FixedListFloat512 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListFloat512 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat512 and indicates whether this instance
        /// is equal to the specified FixedListFloat512.
        /// </summary>
        /// <param name="other">The specified FixedListFloat512 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListFloat512 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListFloat32 that is a copy of a FixedListFloat512.
        /// </summary>
        /// <param name="other">The FixedListFloat512 to copy</param>
        public FixedListFloat32(in FixedListFloat512 other)
        {
            FixedList.CheckResize<FixedBytes30,float>(other.length);
            length = other.length;
            buffer = new FixedBytes30();
            unsafe
            {
                fixed(FixedBytes510* s = &other.buffer)
                fixed(FixedBytes30* d = &this.buffer)
                    *d = *(FixedBytes30*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListFloat512 to a FixedListFloat32.
        /// </summary>
        /// <param name="other">The FixedListFloat512 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListFloat32(in FixedListFloat512 other)
        {
            return new FixedListFloat32(other);
        }

        /// <summary>
        /// Determines whether a FixedListFloat32 and FixedListFloat4096 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat32 to compare for equality</param>
        /// <param name="b">The FixedListFloat4096 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListFloat32 a, in FixedListFloat4096 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListFloat32 and FixedListFloat4096 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat32 to compare for inequality</param>
        /// <param name="b">The FixedListFloat4096 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListFloat32 a, in FixedListFloat4096 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat4096 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat4096.
        /// </summary>
        /// <param name="other">The specified FixedListFloat4096 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListFloat4096 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat4096 and indicates whether this instance
        /// is equal to the specified FixedListFloat4096.
        /// </summary>
        /// <param name="other">The specified FixedListFloat4096 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListFloat4096 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListFloat32 that is a copy of a FixedListFloat4096.
        /// </summary>
        /// <param name="other">The FixedListFloat4096 to copy</param>
        public FixedListFloat32(in FixedListFloat4096 other)
        {
            FixedList.CheckResize<FixedBytes30,float>(other.length);
            length = other.length;
            buffer = new FixedBytes30();
            unsafe
            {
                fixed(FixedBytes4094* s = &other.buffer)
                fixed(FixedBytes30* d = &this.buffer)
                    *d = *(FixedBytes30*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListFloat4096 to a FixedListFloat32.
        /// </summary>
        /// <param name="other">The FixedListFloat4096 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListFloat32(in FixedListFloat4096 other)
        {
            return new FixedListFloat32(other);
        }

        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        /// <returns></returns>
        [NotBurstCompatible]
        public override bool Equals(object obj)
        {
            if(obj is FixedListFloat32 aFixedListFloat32) return Equals(aFixedListFloat32);
            if(obj is FixedListFloat64 aFixedListFloat64) return Equals(aFixedListFloat64);
            if(obj is FixedListFloat128 aFixedListFloat128) return Equals(aFixedListFloat128);
            if(obj is FixedListFloat512 aFixedListFloat512) return Equals(aFixedListFloat512);
            if(obj is FixedListFloat4096 aFixedListFloat4096) return Equals(aFixedListFloat4096);
            return false;
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        public struct Enumerator : IEnumerator<float>
        {
            FixedListFloat32 m_List;
            int m_Index;

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <param name="list"><undoc /></param>
            public Enumerator(ref FixedListFloat32 list)
            {
                m_List = list;
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Dispose()
            {
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <returns><undoc /></returns>
            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Reset()
            {
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public float Current => m_List[m_Index]; // Let FixedListFloat32 indexer check for out of range.

            object IEnumerator.Current => Current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator IEnumerable.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator<float> IEnumerable<float>.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckCapacityInRange(int capacity)
        {
            if(capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }
    }

    sealed class FixedListFloat32DebugView
    {
        FixedListFloat32 m_List;
        public FixedListFloat32DebugView(FixedListFloat32 list)
        {
            m_List = list;
        }
        public float[] Items => m_List.ToArray();
    }


    /// <summary>
    /// An unmanaged, resizable list of float that does not allocate memory.
    /// It is 64 bytes in size, and contains all the memory it needs.
    /// </summary>
    [Serializable]
    [StructLayout(LayoutKind.Explicit, Size=64)]
    [DebuggerTypeProxy(typeof(FixedListFloat64DebugView))]
    [BurstCompatible]
    public struct FixedListFloat64
    : INativeList<float>
    , IEnumerable<float> // Used by collection initializers.
    , IEquatable<FixedListFloat32>
    , IComparable<FixedListFloat32>
    , IEquatable<FixedListFloat64>
    , IComparable<FixedListFloat64>
    , IEquatable<FixedListFloat128>
    , IComparable<FixedListFloat128>
    , IEquatable<FixedListFloat512>
    , IComparable<FixedListFloat512>
    , IEquatable<FixedListFloat4096>
    , IComparable<FixedListFloat4096>
    {
        [SerializeField] [FieldOffset(0)] internal ushort length;
        [SerializeField] [FieldOffset(2)] internal FixedBytes62 buffer;

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        [CreateProperty]
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize<FixedBytes62,float>(value);
                length = (ushort)value;
            }
        }

        /// <summary>
        /// A property in order to display items in the Entity Inspector.
        /// </summary>
        [CreateProperty] IEnumerable<float> Elements => this.ToArray();

        /// <summary>
        /// Reports whether container is empty.
        /// </summary>
        /// <value>True if this container empty.</value>
        public bool IsEmpty => Length == 0;

        internal int LengthInBytes => Length * sizeof(float);

        unsafe internal byte* Buffer
        {
            get
            {
                fixed(byte* b = &buffer.offset0000.byte0000)
                    return b + FixedList.PaddingBytes<float>();
            }
        }

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity
        {
            get
            {
                return FixedList.Capacity<FixedBytes62, float>();
            }
            set
            {
                CheckCapacityInRange(value);
            }
        }

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public float this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    return UnsafeUtility.ReadArrayElement<float>(Buffer, index);
                }
            }
            set
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    UnsafeUtility.WriteArrayElement<float>(Buffer, index, value);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public ref float ElementAt(int index)
        {
            FixedList.CheckElementAccess(index, length);
            unsafe
            {
                return ref UnsafeUtility.ArrayElementAsRef<float>(Buffer, index);
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedListFloat64.
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                return (int)CollectionHelper.Hash(Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The float to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void Add(in float item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRange(void* ptr, int length)
        {
            float* data = (float*)ptr;
            for (var i = 0; i < length; ++i)
            {
                this[Length++] = data[i];
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The float to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void AddNoResize(float item) => Add(item);

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRangeNoResize(void* ptr, int length) => AddRange(ptr, length);

        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }

        /// <summary>
        /// Searches for the specified float and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListFloat64 that starts at the specified index and contains the specified
        /// number of elements.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat64.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <param name="count">The number of elements in the section to search.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(float item, int index, int count)
        {
            for(var i = index; i < index + count; ++i)
                if(this[i].Equals(item))
                  return i;
            return -1;
        }

        /// <summary>
        /// Searches for the specified float and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListFloat64 that starts at the specified index.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat64.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(float item, int index)
        {
            return IndexOf(item, index, Length - index);
        }

        /// <summary>
        /// Determines whether an element is in the FixedListFloat64.
        /// </summary>
        /// <param name="item">The object to locate in the FixedListFloat64.</param>
        /// <returns></returns>
        public bool Contains(float item)
        {
            return IndexOf(item) >= 0;
        }

        /// <summary>
        /// Searches for the specified float and returns the zero-based index of the first occurrence within the entire FixedListFloat64.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat64.</param>
        /// <returns></returns>
        public int IndexOf(float item)
        {
            for (var i = 0; i < length; ++i)
            {
                if (this[i].Equals(item))
                {
                    return i;
                }
            }

            return -1;
        }

        /// <summary>
        /// Inserts a number of items into a FixedListFloat64 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="end">The zero-based index just after where the elements should be removed.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void InsertRangeWithBeginEnd(int begin, int end)
        {
            int items = end - begin;
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(float);
            unsafe
            {
                byte* b = Buffer;
                byte *dest = b + end * sizeof(float);
                byte *src = b + begin * sizeof(float);
                UnsafeUtility.MemMove(dest, src, bytesToCopy);
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedListFloat64 at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>
        public void Insert(int index, float item)
        {
            InsertRangeWithBeginEnd(index, index+1);
            this[index] = item;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index with the last item in the list. The list
        /// is shortened by one.
        /// </summary>
        /// <param name="index">The index of the item to delete.</param>
        public void RemoveAtSwapBack(int index)
        {
            RemoveRangeSwapBackWithBeginEnd(index, index + 1);
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedListFloat64 and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedListFloat64.</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool RemoveSwapBack(float item)
        {
            var index = IndexOf(item);
            if (index == -1)
            {
                return false;
            }

            RemoveAtSwapBack(index);
            return true;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index range with the items from the end the list. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeSwapBackWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                int copyFrom = math.max(Length - itemsToRemove, end);

                unsafe
                {
                    var sizeOf = sizeof(float);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                }

                Length -= itemsToRemove;
            }
        }

        /// <summary>
        /// Removes the float at the specified index, and copies all subsequent elements backward to fill the
        /// hole so created.
        /// </summary>
        /// <param name="index">The zero-based index at which to remove the float</param>
        public void RemoveAt(int index)
        {
            RemoveRangeWithBeginEnd(index, index+1);
        }

        /// <summary>
        /// Searches for the specified float from the begining of the FixedListFloat64 forward, removes it if possible,
        /// and returns true if the float was successfully removed.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat64</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool Remove(float item)
        {
            int index = IndexOf(item);
            if (index < 0)
            {
                return false;
            }

            RemoveAt(index);

            return true;
        }

        /// <summary>
        /// Truncates the list by removing the items at the specified index range, and shifting all remaining items to replace removed items. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <remarks>
        /// This method of removing item(s) is useful only in case when list is ordered and user wants to preserve order
        /// in list after removal In majority of cases is not important and user should use more performant `RemoveRangeSwapBackWithBeginEnd`.
        /// </remarks>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                unsafe
                {
                    var sizeOf = sizeof(float);
                    int copyFrom = math.min(begin + itemsToRemove, Length);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                    Length -= itemsToRemove;
                }
            }
        }

        /// <summary>
        /// Creates a managed Array of float that is a copy of this FixedListFloat64.
        /// </summary>
        /// <returns></returns>
        [NotBurstCompatible]
        public float[] ToArray()
        {
            var result = new float[Length];
            unsafe
            {
                byte* s = Buffer;
                fixed(float* d = result)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArrayfloat that is a copy of this FixedListFloat64.
        /// </summary>
        /// <param name="allocator">A member of the
        /// [Unity.Collections.Allocator](https://docs.unity3d.com/ScriptReference/Unity.Collections.Allocator.html) enumeration.</param>
        /// <returns></returns>
        public NativeArray<float> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                byte* s = Buffer;
                var copy = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<float>(s, Length, Allocator.None);
                return new NativeArray<float>(copy, allocator);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListFloat64 in ascending order.
        /// </summary>
        public void Sort()
        {
            unsafe
            {
                NativeSortExtension.Sort((float*)Buffer, length);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListFloat64 using a custom comparison function.
        /// </summary>
        /// <typeparam name="U">The comparer type.</typeparam>
        /// <param name="comp">A comparison function that indicates whether one element in the array is less than, equal to, or greater than another element.</param>
        [BurstCompatible(GenericTypeArguments = new[] { typeof(NativeSortExtension.DefaultComparer<float>) })]
        public void Sort<U>(U comp) where U : IComparer<float>
        {
            unsafe
            {
                NativeSortExtension.Sort((float*)Buffer, length, comp);
            }
        }


        /// <summary>
        /// Determines whether a FixedListFloat64 and FixedListFloat32 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat64 to compare for equality</param>
        /// <param name="b">The FixedListFloat32 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListFloat64 a, in FixedListFloat32 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListFloat64 and FixedListFloat32 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat64 to compare for inequality</param>
        /// <param name="b">The FixedListFloat32 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListFloat64 a, in FixedListFloat32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat32 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat32.
        /// </summary>
        /// <param name="other">The specified FixedListFloat32 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListFloat32 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat32 and indicates whether this instance
        /// is equal to the specified FixedListFloat32.
        /// </summary>
        /// <param name="other">The specified FixedListFloat32 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListFloat32 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListFloat64 that is a copy of a FixedListFloat32.
        /// </summary>
        /// <param name="other">The FixedListFloat32 to copy</param>
        public FixedListFloat64(in FixedListFloat32 other)
        {
            FixedList.CheckResize<FixedBytes62,float>(other.length);
            length = other.length;
            buffer = new FixedBytes62();
            unsafe
            {
                fixed(FixedBytes30* s = &other.buffer)
                fixed(FixedBytes62* d = &this.buffer)
                    *(FixedBytes30*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListFloat32 to a FixedListFloat64.
        /// </summary>
        /// <param name="other">The FixedListFloat32 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListFloat64(in FixedListFloat32 other)
        {
            return new FixedListFloat64(other);
        }

        /// <summary>
        /// Determines whether a FixedListFloat64 and FixedListFloat64 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat64 to compare for equality</param>
        /// <param name="b">The FixedListFloat64 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListFloat64 a, in FixedListFloat64 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListFloat64 and FixedListFloat64 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat64 to compare for inequality</param>
        /// <param name="b">The FixedListFloat64 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListFloat64 a, in FixedListFloat64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat64 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat64.
        /// </summary>
        /// <param name="other">The specified FixedListFloat64 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListFloat64 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat64 and indicates whether this instance
        /// is equal to the specified FixedListFloat64.
        /// </summary>
        /// <param name="other">The specified FixedListFloat64 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListFloat64 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Determines whether a FixedListFloat64 and FixedListFloat128 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat64 to compare for equality</param>
        /// <param name="b">The FixedListFloat128 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListFloat64 a, in FixedListFloat128 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListFloat64 and FixedListFloat128 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat64 to compare for inequality</param>
        /// <param name="b">The FixedListFloat128 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListFloat64 a, in FixedListFloat128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat128 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat128.
        /// </summary>
        /// <param name="other">The specified FixedListFloat128 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListFloat128 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat128 and indicates whether this instance
        /// is equal to the specified FixedListFloat128.
        /// </summary>
        /// <param name="other">The specified FixedListFloat128 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListFloat128 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListFloat64 that is a copy of a FixedListFloat128.
        /// </summary>
        /// <param name="other">The FixedListFloat128 to copy</param>
        public FixedListFloat64(in FixedListFloat128 other)
        {
            FixedList.CheckResize<FixedBytes62,float>(other.length);
            length = other.length;
            buffer = new FixedBytes62();
            unsafe
            {
                fixed(FixedBytes126* s = &other.buffer)
                fixed(FixedBytes62* d = &this.buffer)
                    *d = *(FixedBytes62*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListFloat128 to a FixedListFloat64.
        /// </summary>
        /// <param name="other">The FixedListFloat128 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListFloat64(in FixedListFloat128 other)
        {
            return new FixedListFloat64(other);
        }

        /// <summary>
        /// Determines whether a FixedListFloat64 and FixedListFloat512 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat64 to compare for equality</param>
        /// <param name="b">The FixedListFloat512 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListFloat64 a, in FixedListFloat512 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListFloat64 and FixedListFloat512 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat64 to compare for inequality</param>
        /// <param name="b">The FixedListFloat512 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListFloat64 a, in FixedListFloat512 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat512 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat512.
        /// </summary>
        /// <param name="other">The specified FixedListFloat512 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListFloat512 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat512 and indicates whether this instance
        /// is equal to the specified FixedListFloat512.
        /// </summary>
        /// <param name="other">The specified FixedListFloat512 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListFloat512 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListFloat64 that is a copy of a FixedListFloat512.
        /// </summary>
        /// <param name="other">The FixedListFloat512 to copy</param>
        public FixedListFloat64(in FixedListFloat512 other)
        {
            FixedList.CheckResize<FixedBytes62,float>(other.length);
            length = other.length;
            buffer = new FixedBytes62();
            unsafe
            {
                fixed(FixedBytes510* s = &other.buffer)
                fixed(FixedBytes62* d = &this.buffer)
                    *d = *(FixedBytes62*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListFloat512 to a FixedListFloat64.
        /// </summary>
        /// <param name="other">The FixedListFloat512 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListFloat64(in FixedListFloat512 other)
        {
            return new FixedListFloat64(other);
        }

        /// <summary>
        /// Determines whether a FixedListFloat64 and FixedListFloat4096 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat64 to compare for equality</param>
        /// <param name="b">The FixedListFloat4096 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListFloat64 a, in FixedListFloat4096 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListFloat64 and FixedListFloat4096 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat64 to compare for inequality</param>
        /// <param name="b">The FixedListFloat4096 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListFloat64 a, in FixedListFloat4096 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat4096 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat4096.
        /// </summary>
        /// <param name="other">The specified FixedListFloat4096 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListFloat4096 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat4096 and indicates whether this instance
        /// is equal to the specified FixedListFloat4096.
        /// </summary>
        /// <param name="other">The specified FixedListFloat4096 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListFloat4096 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListFloat64 that is a copy of a FixedListFloat4096.
        /// </summary>
        /// <param name="other">The FixedListFloat4096 to copy</param>
        public FixedListFloat64(in FixedListFloat4096 other)
        {
            FixedList.CheckResize<FixedBytes62,float>(other.length);
            length = other.length;
            buffer = new FixedBytes62();
            unsafe
            {
                fixed(FixedBytes4094* s = &other.buffer)
                fixed(FixedBytes62* d = &this.buffer)
                    *d = *(FixedBytes62*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListFloat4096 to a FixedListFloat64.
        /// </summary>
        /// <param name="other">The FixedListFloat4096 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListFloat64(in FixedListFloat4096 other)
        {
            return new FixedListFloat64(other);
        }

        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        /// <returns></returns>
        [NotBurstCompatible]
        public override bool Equals(object obj)
        {
            if(obj is FixedListFloat32 aFixedListFloat32) return Equals(aFixedListFloat32);
            if(obj is FixedListFloat64 aFixedListFloat64) return Equals(aFixedListFloat64);
            if(obj is FixedListFloat128 aFixedListFloat128) return Equals(aFixedListFloat128);
            if(obj is FixedListFloat512 aFixedListFloat512) return Equals(aFixedListFloat512);
            if(obj is FixedListFloat4096 aFixedListFloat4096) return Equals(aFixedListFloat4096);
            return false;
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        public struct Enumerator : IEnumerator<float>
        {
            FixedListFloat64 m_List;
            int m_Index;

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <param name="list"><undoc /></param>
            public Enumerator(ref FixedListFloat64 list)
            {
                m_List = list;
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Dispose()
            {
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <returns><undoc /></returns>
            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Reset()
            {
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public float Current => m_List[m_Index]; // Let FixedListFloat64 indexer check for out of range.

            object IEnumerator.Current => Current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator IEnumerable.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator<float> IEnumerable<float>.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckCapacityInRange(int capacity)
        {
            if(capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }
    }

    sealed class FixedListFloat64DebugView
    {
        FixedListFloat64 m_List;
        public FixedListFloat64DebugView(FixedListFloat64 list)
        {
            m_List = list;
        }
        public float[] Items => m_List.ToArray();
    }


    /// <summary>
    /// An unmanaged, resizable list of float that does not allocate memory.
    /// It is 128 bytes in size, and contains all the memory it needs.
    /// </summary>
    [Serializable]
    [StructLayout(LayoutKind.Explicit, Size=128)]
    [DebuggerTypeProxy(typeof(FixedListFloat128DebugView))]
    [BurstCompatible]
    public struct FixedListFloat128
    : INativeList<float>
    , IEnumerable<float> // Used by collection initializers.
    , IEquatable<FixedListFloat32>
    , IComparable<FixedListFloat32>
    , IEquatable<FixedListFloat64>
    , IComparable<FixedListFloat64>
    , IEquatable<FixedListFloat128>
    , IComparable<FixedListFloat128>
    , IEquatable<FixedListFloat512>
    , IComparable<FixedListFloat512>
    , IEquatable<FixedListFloat4096>
    , IComparable<FixedListFloat4096>
    {
        [SerializeField] [FieldOffset(0)] internal ushort length;
        [SerializeField] [FieldOffset(2)] internal FixedBytes126 buffer;

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        [CreateProperty]
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize<FixedBytes126,float>(value);
                length = (ushort)value;
            }
        }

        /// <summary>
        /// A property in order to display items in the Entity Inspector.
        /// </summary>
        [CreateProperty] IEnumerable<float> Elements => this.ToArray();

        /// <summary>
        /// Reports whether container is empty.
        /// </summary>
        /// <value>True if this container empty.</value>
        public bool IsEmpty => Length == 0;

        internal int LengthInBytes => Length * sizeof(float);

        unsafe internal byte* Buffer
        {
            get
            {
                fixed(byte* b = &buffer.offset0000.byte0000)
                    return b + FixedList.PaddingBytes<float>();
            }
        }

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity
        {
            get
            {
                return FixedList.Capacity<FixedBytes126, float>();
            }
            set
            {
                CheckCapacityInRange(value);
            }
        }

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public float this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    return UnsafeUtility.ReadArrayElement<float>(Buffer, index);
                }
            }
            set
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    UnsafeUtility.WriteArrayElement<float>(Buffer, index, value);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public ref float ElementAt(int index)
        {
            FixedList.CheckElementAccess(index, length);
            unsafe
            {
                return ref UnsafeUtility.ArrayElementAsRef<float>(Buffer, index);
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedListFloat128.
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                return (int)CollectionHelper.Hash(Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The float to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void Add(in float item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRange(void* ptr, int length)
        {
            float* data = (float*)ptr;
            for (var i = 0; i < length; ++i)
            {
                this[Length++] = data[i];
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The float to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void AddNoResize(float item) => Add(item);

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRangeNoResize(void* ptr, int length) => AddRange(ptr, length);

        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }

        /// <summary>
        /// Searches for the specified float and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListFloat128 that starts at the specified index and contains the specified
        /// number of elements.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat128.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <param name="count">The number of elements in the section to search.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(float item, int index, int count)
        {
            for(var i = index; i < index + count; ++i)
                if(this[i].Equals(item))
                  return i;
            return -1;
        }

        /// <summary>
        /// Searches for the specified float and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListFloat128 that starts at the specified index.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat128.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(float item, int index)
        {
            return IndexOf(item, index, Length - index);
        }

        /// <summary>
        /// Determines whether an element is in the FixedListFloat128.
        /// </summary>
        /// <param name="item">The object to locate in the FixedListFloat128.</param>
        /// <returns></returns>
        public bool Contains(float item)
        {
            return IndexOf(item) >= 0;
        }

        /// <summary>
        /// Searches for the specified float and returns the zero-based index of the first occurrence within the entire FixedListFloat128.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat128.</param>
        /// <returns></returns>
        public int IndexOf(float item)
        {
            for (var i = 0; i < length; ++i)
            {
                if (this[i].Equals(item))
                {
                    return i;
                }
            }

            return -1;
        }

        /// <summary>
        /// Inserts a number of items into a FixedListFloat128 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="end">The zero-based index just after where the elements should be removed.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void InsertRangeWithBeginEnd(int begin, int end)
        {
            int items = end - begin;
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(float);
            unsafe
            {
                byte* b = Buffer;
                byte *dest = b + end * sizeof(float);
                byte *src = b + begin * sizeof(float);
                UnsafeUtility.MemMove(dest, src, bytesToCopy);
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedListFloat128 at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>
        public void Insert(int index, float item)
        {
            InsertRangeWithBeginEnd(index, index+1);
            this[index] = item;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index with the last item in the list. The list
        /// is shortened by one.
        /// </summary>
        /// <param name="index">The index of the item to delete.</param>
        public void RemoveAtSwapBack(int index)
        {
            RemoveRangeSwapBackWithBeginEnd(index, index + 1);
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedListFloat128 and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedListFloat128.</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool RemoveSwapBack(float item)
        {
            var index = IndexOf(item);
            if (index == -1)
            {
                return false;
            }

            RemoveAtSwapBack(index);
            return true;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index range with the items from the end the list. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeSwapBackWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                int copyFrom = math.max(Length - itemsToRemove, end);

                unsafe
                {
                    var sizeOf = sizeof(float);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                }

                Length -= itemsToRemove;
            }
        }

        /// <summary>
        /// Removes the float at the specified index, and copies all subsequent elements backward to fill the
        /// hole so created.
        /// </summary>
        /// <param name="index">The zero-based index at which to remove the float</param>
        public void RemoveAt(int index)
        {
            RemoveRangeWithBeginEnd(index, index+1);
        }

        /// <summary>
        /// Searches for the specified float from the begining of the FixedListFloat128 forward, removes it if possible,
        /// and returns true if the float was successfully removed.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat128</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool Remove(float item)
        {
            int index = IndexOf(item);
            if (index < 0)
            {
                return false;
            }

            RemoveAt(index);

            return true;
        }

        /// <summary>
        /// Truncates the list by removing the items at the specified index range, and shifting all remaining items to replace removed items. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <remarks>
        /// This method of removing item(s) is useful only in case when list is ordered and user wants to preserve order
        /// in list after removal In majority of cases is not important and user should use more performant `RemoveRangeSwapBackWithBeginEnd`.
        /// </remarks>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                unsafe
                {
                    var sizeOf = sizeof(float);
                    int copyFrom = math.min(begin + itemsToRemove, Length);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                    Length -= itemsToRemove;
                }
            }
        }

        /// <summary>
        /// Creates a managed Array of float that is a copy of this FixedListFloat128.
        /// </summary>
        /// <returns></returns>
        [NotBurstCompatible]
        public float[] ToArray()
        {
            var result = new float[Length];
            unsafe
            {
                byte* s = Buffer;
                fixed(float* d = result)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArrayfloat that is a copy of this FixedListFloat128.
        /// </summary>
        /// <param name="allocator">A member of the
        /// [Unity.Collections.Allocator](https://docs.unity3d.com/ScriptReference/Unity.Collections.Allocator.html) enumeration.</param>
        /// <returns></returns>
        public NativeArray<float> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                byte* s = Buffer;
                var copy = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<float>(s, Length, Allocator.None);
                return new NativeArray<float>(copy, allocator);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListFloat128 in ascending order.
        /// </summary>
        public void Sort()
        {
            unsafe
            {
                NativeSortExtension.Sort((float*)Buffer, length);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListFloat128 using a custom comparison function.
        /// </summary>
        /// <typeparam name="U">The comparer type.</typeparam>
        /// <param name="comp">A comparison function that indicates whether one element in the array is less than, equal to, or greater than another element.</param>
        [BurstCompatible(GenericTypeArguments = new[] { typeof(NativeSortExtension.DefaultComparer<float>) })]
        public void Sort<U>(U comp) where U : IComparer<float>
        {
            unsafe
            {
                NativeSortExtension.Sort((float*)Buffer, length, comp);
            }
        }


        /// <summary>
        /// Determines whether a FixedListFloat128 and FixedListFloat32 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat128 to compare for equality</param>
        /// <param name="b">The FixedListFloat32 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListFloat128 a, in FixedListFloat32 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListFloat128 and FixedListFloat32 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat128 to compare for inequality</param>
        /// <param name="b">The FixedListFloat32 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListFloat128 a, in FixedListFloat32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat32 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat32.
        /// </summary>
        /// <param name="other">The specified FixedListFloat32 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListFloat32 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat32 and indicates whether this instance
        /// is equal to the specified FixedListFloat32.
        /// </summary>
        /// <param name="other">The specified FixedListFloat32 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListFloat32 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListFloat128 that is a copy of a FixedListFloat32.
        /// </summary>
        /// <param name="other">The FixedListFloat32 to copy</param>
        public FixedListFloat128(in FixedListFloat32 other)
        {
            FixedList.CheckResize<FixedBytes126,float>(other.length);
            length = other.length;
            buffer = new FixedBytes126();
            unsafe
            {
                fixed(FixedBytes30* s = &other.buffer)
                fixed(FixedBytes126* d = &this.buffer)
                    *(FixedBytes30*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListFloat32 to a FixedListFloat128.
        /// </summary>
        /// <param name="other">The FixedListFloat32 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListFloat128(in FixedListFloat32 other)
        {
            return new FixedListFloat128(other);
        }

        /// <summary>
        /// Determines whether a FixedListFloat128 and FixedListFloat64 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat128 to compare for equality</param>
        /// <param name="b">The FixedListFloat64 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListFloat128 a, in FixedListFloat64 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListFloat128 and FixedListFloat64 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat128 to compare for inequality</param>
        /// <param name="b">The FixedListFloat64 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListFloat128 a, in FixedListFloat64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat64 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat64.
        /// </summary>
        /// <param name="other">The specified FixedListFloat64 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListFloat64 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat64 and indicates whether this instance
        /// is equal to the specified FixedListFloat64.
        /// </summary>
        /// <param name="other">The specified FixedListFloat64 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListFloat64 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListFloat128 that is a copy of a FixedListFloat64.
        /// </summary>
        /// <param name="other">The FixedListFloat64 to copy</param>
        public FixedListFloat128(in FixedListFloat64 other)
        {
            FixedList.CheckResize<FixedBytes126,float>(other.length);
            length = other.length;
            buffer = new FixedBytes126();
            unsafe
            {
                fixed(FixedBytes62* s = &other.buffer)
                fixed(FixedBytes126* d = &this.buffer)
                    *(FixedBytes62*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListFloat64 to a FixedListFloat128.
        /// </summary>
        /// <param name="other">The FixedListFloat64 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListFloat128(in FixedListFloat64 other)
        {
            return new FixedListFloat128(other);
        }

        /// <summary>
        /// Determines whether a FixedListFloat128 and FixedListFloat128 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat128 to compare for equality</param>
        /// <param name="b">The FixedListFloat128 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListFloat128 a, in FixedListFloat128 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListFloat128 and FixedListFloat128 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat128 to compare for inequality</param>
        /// <param name="b">The FixedListFloat128 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListFloat128 a, in FixedListFloat128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat128 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat128.
        /// </summary>
        /// <param name="other">The specified FixedListFloat128 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListFloat128 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat128 and indicates whether this instance
        /// is equal to the specified FixedListFloat128.
        /// </summary>
        /// <param name="other">The specified FixedListFloat128 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListFloat128 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Determines whether a FixedListFloat128 and FixedListFloat512 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat128 to compare for equality</param>
        /// <param name="b">The FixedListFloat512 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListFloat128 a, in FixedListFloat512 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListFloat128 and FixedListFloat512 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat128 to compare for inequality</param>
        /// <param name="b">The FixedListFloat512 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListFloat128 a, in FixedListFloat512 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat512 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat512.
        /// </summary>
        /// <param name="other">The specified FixedListFloat512 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListFloat512 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat512 and indicates whether this instance
        /// is equal to the specified FixedListFloat512.
        /// </summary>
        /// <param name="other">The specified FixedListFloat512 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListFloat512 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListFloat128 that is a copy of a FixedListFloat512.
        /// </summary>
        /// <param name="other">The FixedListFloat512 to copy</param>
        public FixedListFloat128(in FixedListFloat512 other)
        {
            FixedList.CheckResize<FixedBytes126,float>(other.length);
            length = other.length;
            buffer = new FixedBytes126();
            unsafe
            {
                fixed(FixedBytes510* s = &other.buffer)
                fixed(FixedBytes126* d = &this.buffer)
                    *d = *(FixedBytes126*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListFloat512 to a FixedListFloat128.
        /// </summary>
        /// <param name="other">The FixedListFloat512 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListFloat128(in FixedListFloat512 other)
        {
            return new FixedListFloat128(other);
        }

        /// <summary>
        /// Determines whether a FixedListFloat128 and FixedListFloat4096 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat128 to compare for equality</param>
        /// <param name="b">The FixedListFloat4096 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListFloat128 a, in FixedListFloat4096 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListFloat128 and FixedListFloat4096 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat128 to compare for inequality</param>
        /// <param name="b">The FixedListFloat4096 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListFloat128 a, in FixedListFloat4096 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat4096 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat4096.
        /// </summary>
        /// <param name="other">The specified FixedListFloat4096 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListFloat4096 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat4096 and indicates whether this instance
        /// is equal to the specified FixedListFloat4096.
        /// </summary>
        /// <param name="other">The specified FixedListFloat4096 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListFloat4096 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListFloat128 that is a copy of a FixedListFloat4096.
        /// </summary>
        /// <param name="other">The FixedListFloat4096 to copy</param>
        public FixedListFloat128(in FixedListFloat4096 other)
        {
            FixedList.CheckResize<FixedBytes126,float>(other.length);
            length = other.length;
            buffer = new FixedBytes126();
            unsafe
            {
                fixed(FixedBytes4094* s = &other.buffer)
                fixed(FixedBytes126* d = &this.buffer)
                    *d = *(FixedBytes126*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListFloat4096 to a FixedListFloat128.
        /// </summary>
        /// <param name="other">The FixedListFloat4096 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListFloat128(in FixedListFloat4096 other)
        {
            return new FixedListFloat128(other);
        }

        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        /// <returns></returns>
        [NotBurstCompatible]
        public override bool Equals(object obj)
        {
            if(obj is FixedListFloat32 aFixedListFloat32) return Equals(aFixedListFloat32);
            if(obj is FixedListFloat64 aFixedListFloat64) return Equals(aFixedListFloat64);
            if(obj is FixedListFloat128 aFixedListFloat128) return Equals(aFixedListFloat128);
            if(obj is FixedListFloat512 aFixedListFloat512) return Equals(aFixedListFloat512);
            if(obj is FixedListFloat4096 aFixedListFloat4096) return Equals(aFixedListFloat4096);
            return false;
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        public struct Enumerator : IEnumerator<float>
        {
            FixedListFloat128 m_List;
            int m_Index;

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <param name="list"><undoc /></param>
            public Enumerator(ref FixedListFloat128 list)
            {
                m_List = list;
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Dispose()
            {
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <returns><undoc /></returns>
            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Reset()
            {
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public float Current => m_List[m_Index]; // Let FixedListFloat128 indexer check for out of range.

            object IEnumerator.Current => Current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator IEnumerable.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator<float> IEnumerable<float>.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckCapacityInRange(int capacity)
        {
            if(capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }
    }

    sealed class FixedListFloat128DebugView
    {
        FixedListFloat128 m_List;
        public FixedListFloat128DebugView(FixedListFloat128 list)
        {
            m_List = list;
        }
        public float[] Items => m_List.ToArray();
    }


    /// <summary>
    /// An unmanaged, resizable list of float that does not allocate memory.
    /// It is 512 bytes in size, and contains all the memory it needs.
    /// </summary>
    [Serializable]
    [StructLayout(LayoutKind.Explicit, Size=512)]
    [DebuggerTypeProxy(typeof(FixedListFloat512DebugView))]
    [BurstCompatible]
    public struct FixedListFloat512
    : INativeList<float>
    , IEnumerable<float> // Used by collection initializers.
    , IEquatable<FixedListFloat32>
    , IComparable<FixedListFloat32>
    , IEquatable<FixedListFloat64>
    , IComparable<FixedListFloat64>
    , IEquatable<FixedListFloat128>
    , IComparable<FixedListFloat128>
    , IEquatable<FixedListFloat512>
    , IComparable<FixedListFloat512>
    , IEquatable<FixedListFloat4096>
    , IComparable<FixedListFloat4096>
    {
        [SerializeField] [FieldOffset(0)] internal ushort length;
        [SerializeField] [FieldOffset(2)] internal FixedBytes510 buffer;

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        [CreateProperty]
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize<FixedBytes510,float>(value);
                length = (ushort)value;
            }
        }

        /// <summary>
        /// A property in order to display items in the Entity Inspector.
        /// </summary>
        [CreateProperty] IEnumerable<float> Elements => this.ToArray();

        /// <summary>
        /// Reports whether container is empty.
        /// </summary>
        /// <value>True if this container empty.</value>
        public bool IsEmpty => Length == 0;

        internal int LengthInBytes => Length * sizeof(float);

        unsafe internal byte* Buffer
        {
            get
            {
                fixed(byte* b = &buffer.offset0000.byte0000)
                    return b + FixedList.PaddingBytes<float>();
            }
        }

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity
        {
            get
            {
                return FixedList.Capacity<FixedBytes510, float>();
            }
            set
            {
                CheckCapacityInRange(value);
            }
        }

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public float this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    return UnsafeUtility.ReadArrayElement<float>(Buffer, index);
                }
            }
            set
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    UnsafeUtility.WriteArrayElement<float>(Buffer, index, value);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public ref float ElementAt(int index)
        {
            FixedList.CheckElementAccess(index, length);
            unsafe
            {
                return ref UnsafeUtility.ArrayElementAsRef<float>(Buffer, index);
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedListFloat512.
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                return (int)CollectionHelper.Hash(Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The float to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void Add(in float item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRange(void* ptr, int length)
        {
            float* data = (float*)ptr;
            for (var i = 0; i < length; ++i)
            {
                this[Length++] = data[i];
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The float to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void AddNoResize(float item) => Add(item);

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRangeNoResize(void* ptr, int length) => AddRange(ptr, length);

        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }

        /// <summary>
        /// Searches for the specified float and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListFloat512 that starts at the specified index and contains the specified
        /// number of elements.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat512.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <param name="count">The number of elements in the section to search.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(float item, int index, int count)
        {
            for(var i = index; i < index + count; ++i)
                if(this[i].Equals(item))
                  return i;
            return -1;
        }

        /// <summary>
        /// Searches for the specified float and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListFloat512 that starts at the specified index.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat512.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(float item, int index)
        {
            return IndexOf(item, index, Length - index);
        }

        /// <summary>
        /// Determines whether an element is in the FixedListFloat512.
        /// </summary>
        /// <param name="item">The object to locate in the FixedListFloat512.</param>
        /// <returns></returns>
        public bool Contains(float item)
        {
            return IndexOf(item) >= 0;
        }

        /// <summary>
        /// Searches for the specified float and returns the zero-based index of the first occurrence within the entire FixedListFloat512.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat512.</param>
        /// <returns></returns>
        public int IndexOf(float item)
        {
            for (var i = 0; i < length; ++i)
            {
                if (this[i].Equals(item))
                {
                    return i;
                }
            }

            return -1;
        }

        /// <summary>
        /// Inserts a number of items into a FixedListFloat512 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="end">The zero-based index just after where the elements should be removed.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void InsertRangeWithBeginEnd(int begin, int end)
        {
            int items = end - begin;
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(float);
            unsafe
            {
                byte* b = Buffer;
                byte *dest = b + end * sizeof(float);
                byte *src = b + begin * sizeof(float);
                UnsafeUtility.MemMove(dest, src, bytesToCopy);
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedListFloat512 at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>
        public void Insert(int index, float item)
        {
            InsertRangeWithBeginEnd(index, index+1);
            this[index] = item;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index with the last item in the list. The list
        /// is shortened by one.
        /// </summary>
        /// <param name="index">The index of the item to delete.</param>
        public void RemoveAtSwapBack(int index)
        {
            RemoveRangeSwapBackWithBeginEnd(index, index + 1);
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedListFloat512 and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedListFloat512.</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool RemoveSwapBack(float item)
        {
            var index = IndexOf(item);
            if (index == -1)
            {
                return false;
            }

            RemoveAtSwapBack(index);
            return true;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index range with the items from the end the list. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeSwapBackWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                int copyFrom = math.max(Length - itemsToRemove, end);

                unsafe
                {
                    var sizeOf = sizeof(float);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                }

                Length -= itemsToRemove;
            }
        }

        /// <summary>
        /// Removes the float at the specified index, and copies all subsequent elements backward to fill the
        /// hole so created.
        /// </summary>
        /// <param name="index">The zero-based index at which to remove the float</param>
        public void RemoveAt(int index)
        {
            RemoveRangeWithBeginEnd(index, index+1);
        }

        /// <summary>
        /// Searches for the specified float from the begining of the FixedListFloat512 forward, removes it if possible,
        /// and returns true if the float was successfully removed.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat512</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool Remove(float item)
        {
            int index = IndexOf(item);
            if (index < 0)
            {
                return false;
            }

            RemoveAt(index);

            return true;
        }

        /// <summary>
        /// Truncates the list by removing the items at the specified index range, and shifting all remaining items to replace removed items. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <remarks>
        /// This method of removing item(s) is useful only in case when list is ordered and user wants to preserve order
        /// in list after removal In majority of cases is not important and user should use more performant `RemoveRangeSwapBackWithBeginEnd`.
        /// </remarks>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                unsafe
                {
                    var sizeOf = sizeof(float);
                    int copyFrom = math.min(begin + itemsToRemove, Length);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                    Length -= itemsToRemove;
                }
            }
        }

        /// <summary>
        /// Creates a managed Array of float that is a copy of this FixedListFloat512.
        /// </summary>
        /// <returns></returns>
        [NotBurstCompatible]
        public float[] ToArray()
        {
            var result = new float[Length];
            unsafe
            {
                byte* s = Buffer;
                fixed(float* d = result)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArrayfloat that is a copy of this FixedListFloat512.
        /// </summary>
        /// <param name="allocator">A member of the
        /// [Unity.Collections.Allocator](https://docs.unity3d.com/ScriptReference/Unity.Collections.Allocator.html) enumeration.</param>
        /// <returns></returns>
        public NativeArray<float> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                byte* s = Buffer;
                var copy = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<float>(s, Length, Allocator.None);
                return new NativeArray<float>(copy, allocator);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListFloat512 in ascending order.
        /// </summary>
        public void Sort()
        {
            unsafe
            {
                NativeSortExtension.Sort((float*)Buffer, length);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListFloat512 using a custom comparison function.
        /// </summary>
        /// <typeparam name="U">The comparer type.</typeparam>
        /// <param name="comp">A comparison function that indicates whether one element in the array is less than, equal to, or greater than another element.</param>
        [BurstCompatible(GenericTypeArguments = new[] { typeof(NativeSortExtension.DefaultComparer<float>) })]
        public void Sort<U>(U comp) where U : IComparer<float>
        {
            unsafe
            {
                NativeSortExtension.Sort((float*)Buffer, length, comp);
            }
        }


        /// <summary>
        /// Determines whether a FixedListFloat512 and FixedListFloat32 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat512 to compare for equality</param>
        /// <param name="b">The FixedListFloat32 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListFloat512 a, in FixedListFloat32 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListFloat512 and FixedListFloat32 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat512 to compare for inequality</param>
        /// <param name="b">The FixedListFloat32 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListFloat512 a, in FixedListFloat32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat32 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat32.
        /// </summary>
        /// <param name="other">The specified FixedListFloat32 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListFloat32 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat32 and indicates whether this instance
        /// is equal to the specified FixedListFloat32.
        /// </summary>
        /// <param name="other">The specified FixedListFloat32 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListFloat32 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListFloat512 that is a copy of a FixedListFloat32.
        /// </summary>
        /// <param name="other">The FixedListFloat32 to copy</param>
        public FixedListFloat512(in FixedListFloat32 other)
        {
            FixedList.CheckResize<FixedBytes510,float>(other.length);
            length = other.length;
            buffer = new FixedBytes510();
            unsafe
            {
                fixed(FixedBytes30* s = &other.buffer)
                fixed(FixedBytes510* d = &this.buffer)
                    *(FixedBytes30*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListFloat32 to a FixedListFloat512.
        /// </summary>
        /// <param name="other">The FixedListFloat32 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListFloat512(in FixedListFloat32 other)
        {
            return new FixedListFloat512(other);
        }

        /// <summary>
        /// Determines whether a FixedListFloat512 and FixedListFloat64 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat512 to compare for equality</param>
        /// <param name="b">The FixedListFloat64 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListFloat512 a, in FixedListFloat64 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListFloat512 and FixedListFloat64 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat512 to compare for inequality</param>
        /// <param name="b">The FixedListFloat64 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListFloat512 a, in FixedListFloat64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat64 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat64.
        /// </summary>
        /// <param name="other">The specified FixedListFloat64 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListFloat64 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat64 and indicates whether this instance
        /// is equal to the specified FixedListFloat64.
        /// </summary>
        /// <param name="other">The specified FixedListFloat64 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListFloat64 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListFloat512 that is a copy of a FixedListFloat64.
        /// </summary>
        /// <param name="other">The FixedListFloat64 to copy</param>
        public FixedListFloat512(in FixedListFloat64 other)
        {
            FixedList.CheckResize<FixedBytes510,float>(other.length);
            length = other.length;
            buffer = new FixedBytes510();
            unsafe
            {
                fixed(FixedBytes62* s = &other.buffer)
                fixed(FixedBytes510* d = &this.buffer)
                    *(FixedBytes62*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListFloat64 to a FixedListFloat512.
        /// </summary>
        /// <param name="other">The FixedListFloat64 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListFloat512(in FixedListFloat64 other)
        {
            return new FixedListFloat512(other);
        }

        /// <summary>
        /// Determines whether a FixedListFloat512 and FixedListFloat128 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat512 to compare for equality</param>
        /// <param name="b">The FixedListFloat128 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListFloat512 a, in FixedListFloat128 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListFloat512 and FixedListFloat128 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat512 to compare for inequality</param>
        /// <param name="b">The FixedListFloat128 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListFloat512 a, in FixedListFloat128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat128 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat128.
        /// </summary>
        /// <param name="other">The specified FixedListFloat128 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListFloat128 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat128 and indicates whether this instance
        /// is equal to the specified FixedListFloat128.
        /// </summary>
        /// <param name="other">The specified FixedListFloat128 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListFloat128 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListFloat512 that is a copy of a FixedListFloat128.
        /// </summary>
        /// <param name="other">The FixedListFloat128 to copy</param>
        public FixedListFloat512(in FixedListFloat128 other)
        {
            FixedList.CheckResize<FixedBytes510,float>(other.length);
            length = other.length;
            buffer = new FixedBytes510();
            unsafe
            {
                fixed(FixedBytes126* s = &other.buffer)
                fixed(FixedBytes510* d = &this.buffer)
                    *(FixedBytes126*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListFloat128 to a FixedListFloat512.
        /// </summary>
        /// <param name="other">The FixedListFloat128 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListFloat512(in FixedListFloat128 other)
        {
            return new FixedListFloat512(other);
        }

        /// <summary>
        /// Determines whether a FixedListFloat512 and FixedListFloat512 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat512 to compare for equality</param>
        /// <param name="b">The FixedListFloat512 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListFloat512 a, in FixedListFloat512 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListFloat512 and FixedListFloat512 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat512 to compare for inequality</param>
        /// <param name="b">The FixedListFloat512 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListFloat512 a, in FixedListFloat512 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat512 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat512.
        /// </summary>
        /// <param name="other">The specified FixedListFloat512 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListFloat512 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat512 and indicates whether this instance
        /// is equal to the specified FixedListFloat512.
        /// </summary>
        /// <param name="other">The specified FixedListFloat512 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListFloat512 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Determines whether a FixedListFloat512 and FixedListFloat4096 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat512 to compare for equality</param>
        /// <param name="b">The FixedListFloat4096 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListFloat512 a, in FixedListFloat4096 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListFloat512 and FixedListFloat4096 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat512 to compare for inequality</param>
        /// <param name="b">The FixedListFloat4096 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListFloat512 a, in FixedListFloat4096 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat4096 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat4096.
        /// </summary>
        /// <param name="other">The specified FixedListFloat4096 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListFloat4096 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat4096 and indicates whether this instance
        /// is equal to the specified FixedListFloat4096.
        /// </summary>
        /// <param name="other">The specified FixedListFloat4096 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListFloat4096 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListFloat512 that is a copy of a FixedListFloat4096.
        /// </summary>
        /// <param name="other">The FixedListFloat4096 to copy</param>
        public FixedListFloat512(in FixedListFloat4096 other)
        {
            FixedList.CheckResize<FixedBytes510,float>(other.length);
            length = other.length;
            buffer = new FixedBytes510();
            unsafe
            {
                fixed(FixedBytes4094* s = &other.buffer)
                fixed(FixedBytes510* d = &this.buffer)
                    *d = *(FixedBytes510*)s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListFloat4096 to a FixedListFloat512.
        /// </summary>
        /// <param name="other">The FixedListFloat4096 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListFloat512(in FixedListFloat4096 other)
        {
            return new FixedListFloat512(other);
        }

        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        /// <returns></returns>
        [NotBurstCompatible]
        public override bool Equals(object obj)
        {
            if(obj is FixedListFloat32 aFixedListFloat32) return Equals(aFixedListFloat32);
            if(obj is FixedListFloat64 aFixedListFloat64) return Equals(aFixedListFloat64);
            if(obj is FixedListFloat128 aFixedListFloat128) return Equals(aFixedListFloat128);
            if(obj is FixedListFloat512 aFixedListFloat512) return Equals(aFixedListFloat512);
            if(obj is FixedListFloat4096 aFixedListFloat4096) return Equals(aFixedListFloat4096);
            return false;
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        public struct Enumerator : IEnumerator<float>
        {
            FixedListFloat512 m_List;
            int m_Index;

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <param name="list"><undoc /></param>
            public Enumerator(ref FixedListFloat512 list)
            {
                m_List = list;
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Dispose()
            {
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <returns><undoc /></returns>
            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Reset()
            {
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public float Current => m_List[m_Index]; // Let FixedListFloat512 indexer check for out of range.

            object IEnumerator.Current => Current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator IEnumerable.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator<float> IEnumerable<float>.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckCapacityInRange(int capacity)
        {
            if(capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }
    }

    sealed class FixedListFloat512DebugView
    {
        FixedListFloat512 m_List;
        public FixedListFloat512DebugView(FixedListFloat512 list)
        {
            m_List = list;
        }
        public float[] Items => m_List.ToArray();
    }


    /// <summary>
    /// An unmanaged, resizable list of float that does not allocate memory.
    /// It is 4096 bytes in size, and contains all the memory it needs.
    /// </summary>
    [Serializable]
    [StructLayout(LayoutKind.Explicit, Size=4096)]
    [DebuggerTypeProxy(typeof(FixedListFloat4096DebugView))]
    [BurstCompatible]
    public struct FixedListFloat4096
    : INativeList<float>
    , IEnumerable<float> // Used by collection initializers.
    , IEquatable<FixedListFloat32>
    , IComparable<FixedListFloat32>
    , IEquatable<FixedListFloat64>
    , IComparable<FixedListFloat64>
    , IEquatable<FixedListFloat128>
    , IComparable<FixedListFloat128>
    , IEquatable<FixedListFloat512>
    , IComparable<FixedListFloat512>
    , IEquatable<FixedListFloat4096>
    , IComparable<FixedListFloat4096>
    {
        [SerializeField] [FieldOffset(0)] internal ushort length;
        [SerializeField] [FieldOffset(2)] internal FixedBytes4094 buffer;

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        [CreateProperty]
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize<FixedBytes4094,float>(value);
                length = (ushort)value;
            }
        }

        /// <summary>
        /// A property in order to display items in the Entity Inspector.
        /// </summary>
        [CreateProperty] IEnumerable<float> Elements => this.ToArray();

        /// <summary>
        /// Reports whether container is empty.
        /// </summary>
        /// <value>True if this container empty.</value>
        public bool IsEmpty => Length == 0;

        internal int LengthInBytes => Length * sizeof(float);

        unsafe internal byte* Buffer
        {
            get
            {
                fixed(byte* b = &buffer.offset0000.byte0000)
                    return b + FixedList.PaddingBytes<float>();
            }
        }

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity
        {
            get
            {
                return FixedList.Capacity<FixedBytes4094, float>();
            }
            set
            {
                CheckCapacityInRange(value);
            }
        }

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public float this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    return UnsafeUtility.ReadArrayElement<float>(Buffer, index);
                }
            }
            set
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    UnsafeUtility.WriteArrayElement<float>(Buffer, index, value);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public ref float ElementAt(int index)
        {
            FixedList.CheckElementAccess(index, length);
            unsafe
            {
                return ref UnsafeUtility.ArrayElementAsRef<float>(Buffer, index);
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedListFloat4096.
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                return (int)CollectionHelper.Hash(Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The float to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void Add(in float item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRange(void* ptr, int length)
        {
            float* data = (float*)ptr;
            for (var i = 0; i < length; ++i)
            {
                this[Length++] = data[i];
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The float to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void AddNoResize(float item) => Add(item);

        /// <summary>
        /// Adds elements from a buffer to this list.
        /// </summary>
        /// <param name="ptr">A pointer to the buffer.</param>
        /// <param name="length">The number of elements to add to the list.</param>
        public unsafe void AddRangeNoResize(void* ptr, int length) => AddRange(ptr, length);

        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }

        /// <summary>
        /// Searches for the specified float and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListFloat4096 that starts at the specified index and contains the specified
        /// number of elements.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat4096.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <param name="count">The number of elements in the section to search.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(float item, int index, int count)
        {
            for(var i = index; i < index + count; ++i)
                if(this[i].Equals(item))
                  return i;
            return -1;
        }

        /// <summary>
        /// Searches for the specified float and returns the zero-based index of the first occurrence within the
        /// range of elements in the FixedListFloat4096 that starts at the specified index.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat4096.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <returns></returns>
        [Obsolete("IndexOf is obsolete. Replace it with your own implementation. (RemovedAfter 2020-10-22).", false)]
        public int IndexOf(float item, int index)
        {
            return IndexOf(item, index, Length - index);
        }

        /// <summary>
        /// Determines whether an element is in the FixedListFloat4096.
        /// </summary>
        /// <param name="item">The object to locate in the FixedListFloat4096.</param>
        /// <returns></returns>
        public bool Contains(float item)
        {
            return IndexOf(item) >= 0;
        }

        /// <summary>
        /// Searches for the specified float and returns the zero-based index of the first occurrence within the entire FixedListFloat4096.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat4096.</param>
        /// <returns></returns>
        public int IndexOf(float item)
        {
            for (var i = 0; i < length; ++i)
            {
                if (this[i].Equals(item))
                {
                    return i;
                }
            }

            return -1;
        }

        /// <summary>
        /// Inserts a number of items into a FixedListFloat4096 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="end">The zero-based index just after where the elements should be removed.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void InsertRangeWithBeginEnd(int begin, int end)
        {
            int items = end - begin;
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(float);
            unsafe
            {
                byte* b = Buffer;
                byte *dest = b + end * sizeof(float);
                byte *src = b + begin * sizeof(float);
                UnsafeUtility.MemMove(dest, src, bytesToCopy);
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedListFloat4096 at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>
        public void Insert(int index, float item)
        {
            InsertRangeWithBeginEnd(index, index+1);
            this[index] = item;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index with the last item in the list. The list
        /// is shortened by one.
        /// </summary>
        /// <param name="index">The index of the item to delete.</param>
        public void RemoveAtSwapBack(int index)
        {
            RemoveRangeSwapBackWithBeginEnd(index, index + 1);
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedListFloat4096 and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedListFloat4096.</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool RemoveSwapBack(float item)
        {
            var index = IndexOf(item);
            if (index == -1)
            {
                return false;
            }

            RemoveAtSwapBack(index);
            return true;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index range with the items from the end the list. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeSwapBackWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                int copyFrom = math.max(Length - itemsToRemove, end);

                unsafe
                {
                    var sizeOf = sizeof(float);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                }

                Length -= itemsToRemove;
            }
        }

        /// <summary>
        /// Removes the float at the specified index, and copies all subsequent elements backward to fill the
        /// hole so created.
        /// </summary>
        /// <param name="index">The zero-based index at which to remove the float</param>
        public void RemoveAt(int index)
        {
            RemoveRangeWithBeginEnd(index, index+1);
        }

        /// <summary>
        /// Searches for the specified float from the begining of the FixedListFloat4096 forward, removes it if possible,
        /// and returns true if the float was successfully removed.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat4096</param>
        /// <returns>Returns true if item is removed.</returns>
        public bool Remove(float item)
        {
            int index = IndexOf(item);
            if (index < 0)
            {
                return false;
            }

            RemoveAt(index);

            return true;
        }

        /// <summary>
        /// Truncates the list by removing the items at the specified index range, and shifting all remaining items to replace removed items. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <remarks>
        /// This method of removing item(s) is useful only in case when list is ordered and user wants to preserve order
        /// in list after removal In majority of cases is not important and user should use more performant `RemoveRangeSwapBackWithBeginEnd`.
        /// </remarks>
        /// <exception cref="ArgumentException">Thrown if end argument is less than begin argument.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if begin or end arguments are not positive or out of bounds.</exception>
        public void RemoveRangeWithBeginEnd(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                unsafe
                {
                    var sizeOf = sizeof(float);
                    int copyFrom = math.min(begin + itemsToRemove, Length);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                    Length -= itemsToRemove;
                }
            }
        }

        /// <summary>
        /// Creates a managed Array of float that is a copy of this FixedListFloat4096.
        /// </summary>
        /// <returns></returns>
        [NotBurstCompatible]
        public float[] ToArray()
        {
            var result = new float[Length];
            unsafe
            {
                byte* s = Buffer;
                fixed(float* d = result)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArrayfloat that is a copy of this FixedListFloat4096.
        /// </summary>
        /// <param name="allocator">A member of the
        /// [Unity.Collections.Allocator](https://docs.unity3d.com/ScriptReference/Unity.Collections.Allocator.html) enumeration.</param>
        /// <returns></returns>
        public NativeArray<float> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                byte* s = Buffer;
                var copy = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<float>(s, Length, Allocator.None);
                return new NativeArray<float>(copy, allocator);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListFloat4096 in ascending order.
        /// </summary>
        public void Sort()
        {
            unsafe
            {
                NativeSortExtension.Sort((float*)Buffer, length);
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedListFloat4096 using a custom comparison function.
        /// </summary>
        /// <typeparam name="U">The comparer type.</typeparam>
        /// <param name="comp">A comparison function that indicates whether one element in the array is less than, equal to, or greater than another element.</param>
        [BurstCompatible(GenericTypeArguments = new[] { typeof(NativeSortExtension.DefaultComparer<float>) })]
        public void Sort<U>(U comp) where U : IComparer<float>
        {
            unsafe
            {
                NativeSortExtension.Sort((float*)Buffer, length, comp);
            }
        }


        /// <summary>
        /// Determines whether a FixedListFloat4096 and FixedListFloat32 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat4096 to compare for equality</param>
        /// <param name="b">The FixedListFloat32 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListFloat4096 a, in FixedListFloat32 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListFloat4096 and FixedListFloat32 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat4096 to compare for inequality</param>
        /// <param name="b">The FixedListFloat32 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListFloat4096 a, in FixedListFloat32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat32 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat32.
        /// </summary>
        /// <param name="other">The specified FixedListFloat32 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListFloat32 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat32 and indicates whether this instance
        /// is equal to the specified FixedListFloat32.
        /// </summary>
        /// <param name="other">The specified FixedListFloat32 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListFloat32 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListFloat4096 that is a copy of a FixedListFloat32.
        /// </summary>
        /// <param name="other">The FixedListFloat32 to copy</param>
        public FixedListFloat4096(in FixedListFloat32 other)
        {
            FixedList.CheckResize<FixedBytes4094,float>(other.length);
            length = other.length;
            buffer = new FixedBytes4094();
            unsafe
            {
                fixed(FixedBytes30* s = &other.buffer)
                fixed(FixedBytes4094* d = &this.buffer)
                    *(FixedBytes30*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListFloat32 to a FixedListFloat4096.
        /// </summary>
        /// <param name="other">The FixedListFloat32 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListFloat4096(in FixedListFloat32 other)
        {
            return new FixedListFloat4096(other);
        }

        /// <summary>
        /// Determines whether a FixedListFloat4096 and FixedListFloat64 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat4096 to compare for equality</param>
        /// <param name="b">The FixedListFloat64 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListFloat4096 a, in FixedListFloat64 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListFloat4096 and FixedListFloat64 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat4096 to compare for inequality</param>
        /// <param name="b">The FixedListFloat64 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListFloat4096 a, in FixedListFloat64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat64 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat64.
        /// </summary>
        /// <param name="other">The specified FixedListFloat64 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListFloat64 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat64 and indicates whether this instance
        /// is equal to the specified FixedListFloat64.
        /// </summary>
        /// <param name="other">The specified FixedListFloat64 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListFloat64 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListFloat4096 that is a copy of a FixedListFloat64.
        /// </summary>
        /// <param name="other">The FixedListFloat64 to copy</param>
        public FixedListFloat4096(in FixedListFloat64 other)
        {
            FixedList.CheckResize<FixedBytes4094,float>(other.length);
            length = other.length;
            buffer = new FixedBytes4094();
            unsafe
            {
                fixed(FixedBytes62* s = &other.buffer)
                fixed(FixedBytes4094* d = &this.buffer)
                    *(FixedBytes62*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListFloat64 to a FixedListFloat4096.
        /// </summary>
        /// <param name="other">The FixedListFloat64 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListFloat4096(in FixedListFloat64 other)
        {
            return new FixedListFloat4096(other);
        }

        /// <summary>
        /// Determines whether a FixedListFloat4096 and FixedListFloat128 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat4096 to compare for equality</param>
        /// <param name="b">The FixedListFloat128 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListFloat4096 a, in FixedListFloat128 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListFloat4096 and FixedListFloat128 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat4096 to compare for inequality</param>
        /// <param name="b">The FixedListFloat128 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListFloat4096 a, in FixedListFloat128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat128 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat128.
        /// </summary>
        /// <param name="other">The specified FixedListFloat128 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListFloat128 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat128 and indicates whether this instance
        /// is equal to the specified FixedListFloat128.
        /// </summary>
        /// <param name="other">The specified FixedListFloat128 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListFloat128 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListFloat4096 that is a copy of a FixedListFloat128.
        /// </summary>
        /// <param name="other">The FixedListFloat128 to copy</param>
        public FixedListFloat4096(in FixedListFloat128 other)
        {
            FixedList.CheckResize<FixedBytes4094,float>(other.length);
            length = other.length;
            buffer = new FixedBytes4094();
            unsafe
            {
                fixed(FixedBytes126* s = &other.buffer)
                fixed(FixedBytes4094* d = &this.buffer)
                    *(FixedBytes126*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListFloat128 to a FixedListFloat4096.
        /// </summary>
        /// <param name="other">The FixedListFloat128 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListFloat4096(in FixedListFloat128 other)
        {
            return new FixedListFloat4096(other);
        }

        /// <summary>
        /// Determines whether a FixedListFloat4096 and FixedListFloat512 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat4096 to compare for equality</param>
        /// <param name="b">The FixedListFloat512 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListFloat4096 a, in FixedListFloat512 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListFloat4096 and FixedListFloat512 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat4096 to compare for inequality</param>
        /// <param name="b">The FixedListFloat512 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListFloat4096 a, in FixedListFloat512 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat512 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat512.
        /// </summary>
        /// <param name="other">The specified FixedListFloat512 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListFloat512 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat512 and indicates whether this instance
        /// is equal to the specified FixedListFloat512.
        /// </summary>
        /// <param name="other">The specified FixedListFloat512 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListFloat512 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Constructs a new FixedListFloat4096 that is a copy of a FixedListFloat512.
        /// </summary>
        /// <param name="other">The FixedListFloat512 to copy</param>
        public FixedListFloat4096(in FixedListFloat512 other)
        {
            FixedList.CheckResize<FixedBytes4094,float>(other.length);
            length = other.length;
            buffer = new FixedBytes4094();
            unsafe
            {
                fixed(FixedBytes510* s = &other.buffer)
                fixed(FixedBytes4094* d = &this.buffer)
                    *(FixedBytes510*)d = *s;
            }
        }

        /// <summary>
        /// Implicitly converts a FixedListFloat512 to a FixedListFloat4096.
        /// </summary>
        /// <param name="other">The FixedListFloat512 to copy</param>
        /// <returns></returns>
        public static implicit operator FixedListFloat4096(in FixedListFloat512 other)
        {
            return new FixedListFloat4096(other);
        }

        /// <summary>
        /// Determines whether a FixedListFloat4096 and FixedListFloat4096 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat4096 to compare for equality</param>
        /// <param name="b">The FixedListFloat4096 to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in FixedListFloat4096 a, in FixedListFloat4096 b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a FixedListFloat4096 and FixedListFloat4096 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat4096 to compare for inequality</param>
        /// <param name="b">The FixedListFloat4096 to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in FixedListFloat4096 a, in FixedListFloat4096 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat4096 and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat4096.
        /// </summary>
        /// <param name="other">The specified FixedListFloat4096 to compare with</param>
        /// <returns></returns>
        public int CompareTo(FixedListFloat4096 other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat4096 and indicates whether this instance
        /// is equal to the specified FixedListFloat4096.
        /// </summary>
        /// <param name="other">The specified FixedListFloat4096 to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(FixedListFloat4096 other)
        {
            return CompareTo(other) == 0;
        }


        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        /// <returns></returns>
        [NotBurstCompatible]
        public override bool Equals(object obj)
        {
            if(obj is FixedListFloat32 aFixedListFloat32) return Equals(aFixedListFloat32);
            if(obj is FixedListFloat64 aFixedListFloat64) return Equals(aFixedListFloat64);
            if(obj is FixedListFloat128 aFixedListFloat128) return Equals(aFixedListFloat128);
            if(obj is FixedListFloat512 aFixedListFloat512) return Equals(aFixedListFloat512);
            if(obj is FixedListFloat4096 aFixedListFloat4096) return Equals(aFixedListFloat4096);
            return false;
        }

        /// <summary>
        /// <undoc />
        /// </summary>
        public struct Enumerator : IEnumerator<float>
        {
            FixedListFloat4096 m_List;
            int m_Index;

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <param name="list"><undoc /></param>
            public Enumerator(ref FixedListFloat4096 list)
            {
                m_List = list;
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Dispose()
            {
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <returns><undoc /></returns>
            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Reset()
            {
                m_Index = -1;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public float Current => m_List[m_Index]; // Let FixedListFloat4096 indexer check for out of range.

            object IEnumerator.Current => Current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator IEnumerable.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// This method is not implemented. It will throw NotImplementedException if it is used.
        /// </summary>
        /// <remarks>Use Enumerator GetEnumerator() instead.</remarks>
        /// <returns>Throws NotImplementedException.</returns>
        /// <exception cref="NotImplementedException">Method is not implemented.</exception>
        IEnumerator<float> IEnumerable<float>.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckCapacityInRange(int capacity)
        {
            if(capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }
    }

    sealed class FixedListFloat4096DebugView
    {
        FixedListFloat4096 m_List;
        public FixedListFloat4096DebugView(FixedListFloat4096 list)
        {
            m_List = list;
        }
        public float[] Items => m_List.ToArray();
    }

    /// <summary>
    /// <undoc />
    /// </summary>
    public static class FixedListExtensions
    {

        /// <summary>
        /// Sorts the elements in this FixedList32&lt;T&gt; in ascending order.
        /// </summary>
        /// <typeparam name="T">The type of the elements in the container.</typeparam>
        /// <param name="data">Container to perform sort.</param>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int) })]
        public static void Sort<T>(this ref FixedList32<T> data)
        where T : unmanaged, IComparable<T>
        {
            unsafe
            {
                fixed(byte* b = &data.buffer.offset0000.byte0000)
                {
                    var c = b + FixedList.PaddingBytes<T>();
                    NativeSortExtension.Sort((T*)c, data.Length);
                }
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedList32&lt;T&gt; using a custom comparison function.
        /// </summary>
        /// <typeparam name="T">The type of the elements in the container.</typeparam>
        /// <typeparam name="U">The comparer type.</typeparam>
        /// <param name="data">Container to perform sort.</param>
        /// <param name="comp">A comparison function that indicates whether one element in the array is less than, equal to, or greater than another element.</param>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int), typeof(NativeSortExtension.DefaultComparer<int>) })]
        public static void Sort<T, U>(this ref FixedList32<T> data, U comp)
        where T : unmanaged, IComparable<T>
        where U : IComparer<T>
        {
            unsafe
            {
                fixed(byte* b = &data.buffer.offset0000.byte0000)
                {
                    var c = b + FixedList.PaddingBytes<T>();
                    NativeSortExtension.Sort((T*)c, data.Length, comp);
                }
            }
        }


        /// <summary>
        /// Sorts the elements in this FixedList64&lt;T&gt; in ascending order.
        /// </summary>
        /// <typeparam name="T">The type of the elements in the container.</typeparam>
        /// <param name="data">Container to perform sort.</param>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int) })]
        public static void Sort<T>(this ref FixedList64<T> data)
        where T : unmanaged, IComparable<T>
        {
            unsafe
            {
                fixed(byte* b = &data.buffer.offset0000.byte0000)
                {
                    var c = b + FixedList.PaddingBytes<T>();
                    NativeSortExtension.Sort((T*)c, data.Length);
                }
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedList64&lt;T&gt; using a custom comparison function.
        /// </summary>
        /// <typeparam name="T">The type of the elements in the container.</typeparam>
        /// <typeparam name="U">The comparer type.</typeparam>
        /// <param name="data">Container to perform sort.</param>
        /// <param name="comp">A comparison function that indicates whether one element in the array is less than, equal to, or greater than another element.</param>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int), typeof(NativeSortExtension.DefaultComparer<int>) })]
        public static void Sort<T, U>(this ref FixedList64<T> data, U comp)
        where T : unmanaged, IComparable<T>
        where U : IComparer<T>
        {
            unsafe
            {
                fixed(byte* b = &data.buffer.offset0000.byte0000)
                {
                    var c = b + FixedList.PaddingBytes<T>();
                    NativeSortExtension.Sort((T*)c, data.Length, comp);
                }
            }
        }


        /// <summary>
        /// Sorts the elements in this FixedList128&lt;T&gt; in ascending order.
        /// </summary>
        /// <typeparam name="T">The type of the elements in the container.</typeparam>
        /// <param name="data">Container to perform sort.</param>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int) })]
        public static void Sort<T>(this ref FixedList128<T> data)
        where T : unmanaged, IComparable<T>
        {
            unsafe
            {
                fixed(byte* b = &data.buffer.offset0000.byte0000)
                {
                    var c = b + FixedList.PaddingBytes<T>();
                    NativeSortExtension.Sort((T*)c, data.Length);
                }
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedList128&lt;T&gt; using a custom comparison function.
        /// </summary>
        /// <typeparam name="T">The type of the elements in the container.</typeparam>
        /// <typeparam name="U">The comparer type.</typeparam>
        /// <param name="data">Container to perform sort.</param>
        /// <param name="comp">A comparison function that indicates whether one element in the array is less than, equal to, or greater than another element.</param>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int), typeof(NativeSortExtension.DefaultComparer<int>) })]
        public static void Sort<T, U>(this ref FixedList128<T> data, U comp)
        where T : unmanaged, IComparable<T>
        where U : IComparer<T>
        {
            unsafe
            {
                fixed(byte* b = &data.buffer.offset0000.byte0000)
                {
                    var c = b + FixedList.PaddingBytes<T>();
                    NativeSortExtension.Sort((T*)c, data.Length, comp);
                }
            }
        }


        /// <summary>
        /// Sorts the elements in this FixedList512&lt;T&gt; in ascending order.
        /// </summary>
        /// <typeparam name="T">The type of the elements in the container.</typeparam>
        /// <param name="data">Container to perform sort.</param>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int) })]
        public static void Sort<T>(this ref FixedList512<T> data)
        where T : unmanaged, IComparable<T>
        {
            unsafe
            {
                fixed(byte* b = &data.buffer.offset0000.byte0000)
                {
                    var c = b + FixedList.PaddingBytes<T>();
                    NativeSortExtension.Sort((T*)c, data.Length);
                }
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedList512&lt;T&gt; using a custom comparison function.
        /// </summary>
        /// <typeparam name="T">The type of the elements in the container.</typeparam>
        /// <typeparam name="U">The comparer type.</typeparam>
        /// <param name="data">Container to perform sort.</param>
        /// <param name="comp">A comparison function that indicates whether one element in the array is less than, equal to, or greater than another element.</param>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int), typeof(NativeSortExtension.DefaultComparer<int>) })]
        public static void Sort<T, U>(this ref FixedList512<T> data, U comp)
        where T : unmanaged, IComparable<T>
        where U : IComparer<T>
        {
            unsafe
            {
                fixed(byte* b = &data.buffer.offset0000.byte0000)
                {
                    var c = b + FixedList.PaddingBytes<T>();
                    NativeSortExtension.Sort((T*)c, data.Length, comp);
                }
            }
        }


        /// <summary>
        /// Sorts the elements in this FixedList4096&lt;T&gt; in ascending order.
        /// </summary>
        /// <typeparam name="T">The type of the elements in the container.</typeparam>
        /// <param name="data">Container to perform sort.</param>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int) })]
        public static void Sort<T>(this ref FixedList4096<T> data)
        where T : unmanaged, IComparable<T>
        {
            unsafe
            {
                fixed(byte* b = &data.buffer.offset0000.byte0000)
                {
                    var c = b + FixedList.PaddingBytes<T>();
                    NativeSortExtension.Sort((T*)c, data.Length);
                }
            }
        }

        /// <summary>
        /// Sorts the elements in this FixedList4096&lt;T&gt; using a custom comparison function.
        /// </summary>
        /// <typeparam name="T">The type of the elements in the container.</typeparam>
        /// <typeparam name="U">The comparer type.</typeparam>
        /// <param name="data">Container to perform sort.</param>
        /// <param name="comp">A comparison function that indicates whether one element in the array is less than, equal to, or greater than another element.</param>
        [BurstCompatible(GenericTypeArguments = new [] { typeof(int), typeof(NativeSortExtension.DefaultComparer<int>) })]
        public static void Sort<T, U>(this ref FixedList4096<T> data, U comp)
        where T : unmanaged, IComparable<T>
        where U : IComparer<T>
        {
            unsafe
            {
                fixed(byte* b = &data.buffer.offset0000.byte0000)
                {
                    var c = b + FixedList.PaddingBytes<T>();
                    NativeSortExtension.Sort((T*)c, data.Length, comp);
                }
            }
        }

    }
}
